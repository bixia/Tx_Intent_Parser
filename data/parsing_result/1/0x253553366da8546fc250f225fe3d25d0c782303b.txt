{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 28, 'end_line': 30, 'offset_start': 912, 'offset_end': 974, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 43, 'end_line': 45, 'offset_start': 1201, 'offset_end': 1285, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._checkOwner', 'start_line': 50, 'end_line': 52, 'offset_start': 1359, 'offset_end': 1488, 'content': 'function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 61, 'end_line': 63, 'offset_start': 1831, 'offset_end': 1931, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 69, 'end_line': 72, 'offset_start': 2081, 'offset_end': 2278, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 78, 'end_line': 82, 'offset_start': 2433, 'offset_end': 2619, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IABIResolver.ABI', 'start_line': 99, 'end_line': 102, 'offset_start': 3100, 'offset_end': 3216, 'content': 'function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);', 'contract_name': 'IABIResolver', 'contract_code': '{\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\n\n    /**\n     * Returns the ABI associated with an ENS node.\n     * Defined in EIP205.\n     * @param node The ENS node to query\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\n     * @return contentType The content type of the return value\n     * @return data The ABI data\n     */\n    function ABI(\n        bytes32 node,\n        uint256 contentTypes\n    ) external view returns (uint256, bytes memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 128, 'end_line': 128, 'offset_start': 3995, 'offset_end': 4070, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IExtendedResolver.resolve', 'start_line': 135, 'end_line': 138, 'offset_start': 4166, 'offset_end': 4279, 'content': 'function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);', 'contract_name': 'IExtendedResolver', 'contract_code': '{\n    function resolve(\n        bytes memory name,\n        bytes memory data\n    ) external view returns (bytes memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameResolver.name', 'start_line': 153, 'end_line': 153, 'offset_start': 4625, 'offset_end': 4690, 'content': 'function name(bytes32 node) external view returns (string memory);', 'contract_name': 'INameResolver', 'contract_code': '{\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IPubkeyResolver.pubkey', 'start_line': 169, 'end_line': 169, 'offset_start': 5154, 'offset_end': 5228, 'content': 'function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);', 'contract_name': 'IPubkeyResolver', 'contract_code': '{\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\n\n    /**\n     * Returns the SECP256k1 public key associated with an ENS node.\n     * Defined in EIP 619.\n     * @param node The ENS node to query\n     * @return x The X coordinate of the curve point for the public key.\n     * @return y The Y coordinate of the curve point for the public key.\n     */\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 192, 'end_line': 197, 'offset_start': 6057, 'offset_end': 6216, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 216, 'end_line': 218, 'offset_start': 6861, 'offset_end': 6956, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 220, 'end_line': 222, 'offset_start': 6963, 'offset_end': 7061, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 243, 'end_line': 245, 'offset_start': 7479, 'offset_end': 7582, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 250, 'end_line': 252, 'offset_start': 7654, 'offset_end': 7757, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 258, 'end_line': 261, 'offset_start': 7871, 'offset_end': 8023, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 269, 'end_line': 272, 'offset_start': 8223, 'offset_end': 8416, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 279, 'end_line': 359, 'offset_start': 8733, 'offset_end': 12657, 'content': "function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }", 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 364, 'end_line': 375, 'offset_start': 12790, 'offset_end': 13126, 'content': 'function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 382, 'end_line': 413, 'offset_start': 13346, 'offset_end': 14983, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 418, 'end_line': 423, 'offset_start': 15084, 'offset_end': 15320, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 429, 'end_line': 465, 'offset_start': 15445, 'offset_end': 16427, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 471, 'end_line': 476, 'offset_start': 16581, 'offset_end': 16825, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 482, 'end_line': 514, 'offset_start': 16951, 'offset_end': 17840, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 520, 'end_line': 525, 'offset_start': 17995, 'offset_end': 18240, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 533, 'end_line': 557, 'offset_start': 18492, 'offset_end': 19154, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 563, 'end_line': 568, 'offset_start': 19309, 'offset_end': 19563, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel\'s lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don\'t need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.\'s "Hacker\'s Delight" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton\'s method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'StringUtils.strlen', 'start_line': 580, 'end_line': 601, 'offset_start': 19790, 'offset_end': 20411, 'content': 'function strlen(string memory s) internal pure returns (uint256) {\n        uint256 len;\n        uint256 i = 0;\n        uint256 bytelength = bytes(s).length;\n        for (len = 0; i < bytelength; len++) {\n            bytes1 b = bytes(s)[i];\n            if (b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }', 'contract_name': 'StringUtils', 'contract_code': '{\n    /**\n     * @dev Returns the length of a given string\n     *\n     * @param s The string to measure the length of\n     * @return The length of the input string\n     */\n    function strlen(string memory s) internal pure returns (uint256) {\n        uint256 len;\n        uint256 i = 0;\n        uint256 bytelength = bytes(s).length;\n        for (len = 0; i < bytelength; len++) {\n            bytes1 b = bytes(s)[i];\n            if (b < 0x80) {\n                i += 1;\n            } else if (b < 0xE0) {\n                i += 2;\n            } else if (b < 0xF0) {\n                i += 3;\n            } else if (b < 0xF8) {\n                i += 4;\n            } else if (b < 0xFC) {\n                i += 5;\n            } else {\n                i += 6;\n            }\n        }\n        return len;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.balanceOf', 'start_line': 657, 'end_line': 657, 'offset_start': 22193, 'offset_end': 22272, 'content': 'function balanceOf(address account, uint256 id) external view returns (uint256);', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.balanceOfBatch', 'start_line': 666, 'end_line': 669, 'offset_start': 22472, 'offset_end': 22613, 'content': 'function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.setApprovalForAll', 'start_line': 680, 'end_line': 680, 'offset_start': 22873, 'offset_end': 22941, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.isApprovedForAll', 'start_line': 687, 'end_line': 687, 'offset_start': 23088, 'offset_end': 23177, 'content': 'function isApprovedForAll(address account, address operator) external view returns (bool);', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.safeTransferFrom', 'start_line': 702, 'end_line': 708, 'offset_start': 23745, 'offset_end': 23900, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1155.safeBatchTransferFrom', 'start_line': 721, 'end_line': 727, 'offset_start': 24302, 'offset_end': 24486, 'content': 'function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;', 'contract_name': 'IERC1155', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setApprovalForAll', 'start_line': 766, 'end_line': 766, 'offset_start': 25543, 'offset_end': 25593, 'content': 'function setApprovalForAll(address, bool) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.approve', 'start_line': 768, 'end_line': 768, 'offset_start': 25600, 'offset_end': 25672, 'content': 'function approve(bytes32 node, address delegate, bool approved) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.isApprovedForAll', 'start_line': 770, 'end_line': 770, 'offset_start': 25679, 'offset_end': 25748, 'content': 'function isApprovedForAll(address account, address operator) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.isApprovedFor', 'start_line': 772, 'end_line': 776, 'offset_start': 25755, 'offset_end': 25863, 'content': 'function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setABI', 'start_line': 778, 'end_line': 782, 'offset_start': 25870, 'offset_end': 25980, 'content': 'function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setAddr', 'start_line': 784, 'end_line': 784, 'offset_start': 25987, 'offset_end': 26040, 'content': 'function setAddr(bytes32 node, address addr) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setAddr', 'start_line': 786, 'end_line': 786, 'offset_start': 26047, 'offset_end': 26122, 'content': 'function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setContenthash', 'start_line': 788, 'end_line': 788, 'offset_start': 26129, 'offset_end': 26196, 'content': 'function setContenthash(bytes32 node, bytes calldata hash) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setDnsrr', 'start_line': 790, 'end_line': 790, 'offset_start': 26203, 'offset_end': 26264, 'content': 'function setDnsrr(bytes32 node, bytes calldata data) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setName', 'start_line': 792, 'end_line': 792, 'offset_start': 26271, 'offset_end': 26333, 'content': 'function setName(bytes32 node, string calldata _name) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setPubkey', 'start_line': 794, 'end_line': 794, 'offset_start': 26340, 'offset_end': 26403, 'content': 'function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setText', 'start_line': 796, 'end_line': 800, 'offset_start': 26410, 'offset_end': 26523, 'content': 'function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setInterface', 'start_line': 802, 'end_line': 806, 'offset_start': 26530, 'offset_end': 26645, 'content': 'function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.multicall', 'start_line': 808, 'end_line': 810, 'offset_start': 26652, 'offset_end': 26749, 'content': 'function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.multicallWithNodeCheck', 'start_line': 812, 'end_line': 815, 'offset_start': 26756, 'offset_end': 26892, 'content': 'function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.content', 'start_line': 818, 'end_line': 818, 'offset_start': 26930, 'offset_end': 26992, 'content': 'function content(bytes32 node) external view returns (bytes32);', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.multihash', 'start_line': 820, 'end_line': 820, 'offset_start': 26999, 'offset_end': 27068, 'content': 'function multihash(bytes32 node) external view returns (bytes memory);', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setContent', 'start_line': 822, 'end_line': 822, 'offset_start': 27075, 'offset_end': 27131, 'content': 'function setContent(bytes32 node, bytes32 hash) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Resolver.setMultihash', 'start_line': 824, 'end_line': 824, 'offset_start': 27138, 'offset_end': 27203, 'content': 'function setMultihash(bytes32 node, bytes calldata hash) external;', 'contract_name': 'Resolver', 'contract_code': '{\n    /* Deprecated events */\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\n\n    function setApprovalForAll(address, bool) external;\n\n    function approve(bytes32 node, address delegate, bool approved) external;\n\n    function isApprovedForAll(address account, address operator) external;\n\n    function isApprovedFor(\n        address owner,\n        bytes32 node,\n        address delegate\n    ) external;\n\n    function setABI(\n        bytes32 node,\n        uint256 contentType,\n        bytes calldata data\n    ) external;\n\n    function setAddr(bytes32 node, address addr) external;\n\n    function setAddr(bytes32 node, uint256 coinType, bytes calldata a) external;\n\n    function setContenthash(bytes32 node, bytes calldata hash) external;\n\n    function setDnsrr(bytes32 node, bytes calldata data) external;\n\n    function setName(bytes32 node, string calldata _name) external;\n\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) external;\n\n    function setText(\n        bytes32 node,\n        string calldata key,\n        string calldata value\n    ) external;\n\n    function setInterface(\n        bytes32 node,\n        bytes4 interfaceID,\n        address implementer\n    ) external;\n\n    function multicall(\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    function multicallWithNodeCheck(\n        bytes32 nodehash,\n        bytes[] calldata data\n    ) external returns (bytes[] memory results);\n\n    /* Deprecated functions */\n    function content(bytes32 node) external view returns (bytes32);\n\n    function multihash(bytes32 node) external view returns (bytes memory);\n\n    function setContent(bytes32 node, bytes32 hash) external;\n\n    function setMultihash(bytes32 node, bytes calldata hash) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IAddressResolver.addr', 'start_line': 840, 'end_line': 843, 'offset_start': 27474, 'offset_end': 27578, 'content': 'function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);', 'contract_name': 'IAddressResolver', 'contract_code': '{\n    event AddressChanged(\n        bytes32 indexed node,\n        uint256 coinType,\n        bytes newAddress\n    );\n\n    function addr(\n        bytes32 node,\n        uint256 coinType\n    ) external view returns (bytes memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'NameResolver.setName', 'start_line': 854, 'end_line': 854, 'offset_start': 27799, 'offset_end': 27864, 'content': 'function setName(bytes32 node, string memory name) public virtual;', 'contract_name': 'NameResolver', 'contract_code': '{\n    function setName(bytes32 node, string memory name) public virtual;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.tor', 'start_line': 874, 'end_line': 884, 'offset_start': 28478, 'offset_end': 28820, 'content': 'constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.setDefaultResolver', 'start_line': 897, 'end_line': 904, 'offset_start': 29190, 'offset_end': 29515, 'content': 'function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.claim', 'start_line': 912, 'end_line': 914, 'offset_start': 29783, 'offset_end': 29927, 'content': 'function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.claimForAddr', 'start_line': 924, 'end_line': 936, 'offset_start': 30296, 'offset_end': 30769, 'content': 'function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.claimWithResolver', 'start_line': 945, 'end_line': 950, 'offset_start': 31118, 'offset_end': 31298, 'content': 'function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.setName', 'start_line': 959, 'end_line': 967, 'offset_start': 31618, 'offset_end': 31872, 'content': 'function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.setNameForAddr', 'start_line': 979, 'end_line': 988, 'offset_start': 32367, 'offset_end': 32669, 'content': 'function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.node', 'start_line': 995, 'end_line': 1000, 'offset_start': 32838, 'offset_end': 33038, 'content': 'function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.sha3HexAddress', 'start_line': 1009, 'end_line': 1026, 'offset_start': 33344, 'offset_end': 33847, 'content': 'function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseRegistrar.ownsContract', 'start_line': 1028, 'end_line': 1034, 'offset_start': 33854, 'offset_end': 34079, 'content': 'function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }', 'contract_name': 'ReverseRegistrar', 'contract_code': '{\n    ENS public immutable ens;\n    NameResolver public defaultResolver;\n\n    event ReverseClaimed(address indexed addr, bytes32 indexed node);\n    event DefaultResolverChanged(NameResolver indexed resolver);\n\n    /**\n     * @dev Constructor\n     * @param ensAddr The address of the ENS registry.\n     */\n    constructor(ENS ensAddr) {\n        ens = ensAddr;\n\n        // Assign ownership of the reverse record to our deployer\n        ReverseRegistrar oldRegistrar = ReverseRegistrar(\n            ensAddr.owner(ADDR_REVERSE_NODE)\n        );\n        if (address(oldRegistrar) != address(0x0)) {\n            oldRegistrar.claim(msg.sender);\n        }\n    }\n\n    modifier authorised(address addr) {\n        require(\n            addr == msg.sender ||\n                controllers[msg.sender] ||\n                ens.isApprovedForAll(addr, msg.sender) ||\n                ownsContract(addr),\n            "ReverseRegistrar: Caller is not a controller or authorised by address or the address itself"\n        );\n        _;\n    }\n\n    function setDefaultResolver(address resolver) public override onlyOwner {\n        require(\n            address(resolver) != address(0),\n            "ReverseRegistrar: Resolver address must not be 0"\n        );\n        defaultResolver = NameResolver(resolver);\n        emit DefaultResolverChanged(NameResolver(resolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claim(address owner) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, address(defaultResolver));\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param addr The reverse record to set\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The resolver of the reverse node\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) public override authorised(addr) returns (bytes32) {\n        bytes32 labelHash = sha3HexAddress(addr);\n        bytes32 reverseNode = keccak256(\n            abi.encodePacked(ADDR_REVERSE_NODE, labelHash)\n        );\n        emit ReverseClaimed(addr, reverseNode);\n        ens.setSubnodeRecord(ADDR_REVERSE_NODE, labelHash, owner, resolver, 0);\n        return reverseNode;\n    }\n\n    /**\n     * @dev Transfers ownership of the reverse ENS record associated with the\n     *      calling account.\n     * @param owner The address to set as the owner of the reverse record in ENS.\n     * @param resolver The address of the resolver to set; 0 to leave unchanged.\n     * @return The ENS node hash of the reverse record.\n     */\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) public override returns (bytes32) {\n        return claimForAddr(msg.sender, owner, resolver);\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the calling account. First updates the resolver to the default reverse\n     * resolver if necessary.\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setName(string memory name) public override returns (bytes32) {\n        return\n            setNameForAddr(\n                msg.sender,\n                msg.sender,\n                address(defaultResolver),\n                name\n            );\n    }\n\n    /**\n     * @dev Sets the `name()` record for the reverse ENS record associated with\n     * the account provided. Updates the resolver to a designated resolver\n     * Only callable by controllers and authorised users\n     * @param addr The reverse record to set\n     * @param owner The owner of the reverse node\n     * @param resolver The resolver of the reverse node\n     * @param name The name to set for this address.\n     * @return The ENS node hash of the reverse record.\n     */\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) public override returns (bytes32) {\n        bytes32 node = claimForAddr(addr, owner, resolver);\n        NameResolver(resolver).setName(node, name);\n        return node;\n    }\n\n    /**\n     * @dev Returns the node hash for a given account\'s reverse records.\n     * @param addr The address to hash\n     * @return The ENS node hash.\n     */\n    function node(address addr) public pure override returns (bytes32) {\n        return\n            keccak256(\n                abi.encodePacked(ADDR_REVERSE_NODE, sha3HexAddress(addr))\n            );\n    }\n\n    /**\n     * @dev An optimised function to compute the sha3 of the lower-case\n     *      hexadecimal representation of an Ethereum address.\n     * @param addr The address to hash\n     * @return ret The SHA3 hash of the lower-case hexadecimal encoding of the\n     *         input address.\n     */\n    function sha3HexAddress(address addr) private pure returns (bytes32 ret) {\n        assembly {\n            for {\n                let i := 40\n            } gt(i, 0) {\n\n            } {\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n                i := sub(i, 1)\n                mstore8(i, byte(and(addr, 0xf), lookup))\n                addr := div(addr, 0x10)\n            }\n\n            ret := keccak256(0, 40)\n        }\n    }\n\n    function ownsContract(address addr) internal view returns (bool) {\n        try Ownable(addr).owner() returns (address owner) {\n            return owner == msg.sender;\n        } catch {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IMetadataService.uri', 'start_line': 1041, 'end_line': 1041, 'offset_start': 34174, 'offset_end': 34233, 'content': 'function uri(uint256) external view returns (string memory);', 'contract_name': 'IMetadataService', 'contract_code': '{\n    function uri(uint256) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapperUpgrade.wrapFromUpgrade', 'start_line': 1048, 'end_line': 1055, 'offset_start': 34331, 'offset_end': 34534, 'content': 'function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;', 'contract_name': 'INameWrapperUpgrade', 'contract_code': '{\n    function wrapFromUpgrade(\n        bytes calldata name,\n        address wrappedOwner,\n        uint32 fuses,\n        uint64 expiry,\n        address approved,\n        bytes calldata extraData\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IPriceOracle.price', 'start_line': 1074, 'end_line': 1078, 'offset_start': 35081, 'offset_end': 35221, 'content': 'function price(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view returns (Price calldata);', 'contract_name': 'IPriceOracle', 'contract_code': '{\n    struct Price {\n        uint256 base;\n        uint256 premium;\n    }\n\n    /**\n     * @dev Returns the price to register or renew a name.\n     * @param name The name being registered or renewed.\n     * @param expires When the name presently expires (0 if this is a new registration).\n     * @param duration How long the name is being registered or extended for, in seconds.\n     * @return base premium tuple of base price + premium price\n     */\n    function price(\n        string calldata name,\n        uint256 expires,\n        uint256 duration\n    ) external view returns (Price calldata);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ReverseClaimer.tor', 'start_line': 1091, 'end_line': 1096, 'offset_start': 35558, 'offset_end': 35761, 'content': 'constructor(ENS ens, address claimant) {\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        reverseRegistrar.claim(claimant);\n    }', 'contract_name': 'ReverseClaimer', 'contract_code': '{\n    bytes32 constant ADDR_REVERSE_NODE =\n        0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    constructor(ENS ens, address claimant) {\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(\n            ens.owner(ADDR_REVERSE_NODE)\n        );\n        reverseRegistrar.claim(claimant);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 1134, 'end_line': 1140, 'offset_start': 36941, 'offset_end': 37260, 'content': 'function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 1158, 'end_line': 1163, 'offset_start': 38178, 'offset_end': 38489, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1183, 'end_line': 1185, 'offset_start': 39232, 'offset_end': 39416, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 1193, 'end_line': 1199, 'offset_start': 39639, 'offset_end': 39861, 'content': 'function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1212, 'end_line': 1218, 'offset_start': 40224, 'offset_end': 40477, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 1226, 'end_line': 1235, 'offset_start': 40726, 'offset_end': 41171, 'content': 'function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1243, 'end_line': 1245, 'offset_start': 41349, 'offset_end': 41545, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 1253, 'end_line': 1260, 'offset_start': 41730, 'offset_end': 42055, 'content': 'function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1268, 'end_line': 1270, 'offset_start': 42235, 'offset_end': 42432, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 1278, 'end_line': 1285, 'offset_start': 42619, 'offset_end': 42943, 'content': 'function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 1293, 'end_line': 1309, 'offset_start': 43232, 'offset_end': 43859, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 1317, 'end_line': 1327, 'offset_start': 44081, 'offset_end': 44375, 'content': 'function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 1329, 'end_line': 1341, 'offset_start': 44382, 'offset_end': 44921, 'content': 'function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn\'t rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity\'s `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n\n        (bool success, ) = recipient.call{value: amount}("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, "Address: low-level call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), "Address: call to non-contract");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn\'t, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.ens', 'start_line': 1383, 'end_line': 1383, 'offset_start': 46212, 'offset_end': 46254, 'content': 'function ens() external view returns (ENS);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.registrar', 'start_line': 1385, 'end_line': 1385, 'offset_start': 46261, 'offset_end': 46320, 'content': 'function registrar() external view returns (IBaseRegistrar);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.metadataService', 'start_line': 1387, 'end_line': 1387, 'offset_start': 46327, 'offset_end': 46394, 'content': 'function metadataService() external view returns (IMetadataService);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.names', 'start_line': 1389, 'end_line': 1389, 'offset_start': 46401, 'offset_end': 46461, 'content': 'function names(bytes32) external view returns (bytes memory);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.name', 'start_line': 1391, 'end_line': 1391, 'offset_start': 46468, 'offset_end': 46521, 'content': 'function name() external view returns (string memory);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.upgradeContract', 'start_line': 1393, 'end_line': 1393, 'offset_start': 46528, 'offset_end': 46598, 'content': 'function upgradeContract() external view returns (INameWrapperUpgrade);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.supportsInterface', 'start_line': 1395, 'end_line': 1395, 'offset_start': 46605, 'offset_end': 46680, 'content': 'function supportsInterface(bytes4 interfaceID) external view returns (bool);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.wrap', 'start_line': 1397, 'end_line': 1401, 'offset_start': 46687, 'offset_end': 46800, 'content': 'function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.wrapETH2LD', 'start_line': 1403, 'end_line': 1408, 'offset_start': 46807, 'offset_end': 46990, 'content': 'function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.registerAndWrapETH2LD', 'start_line': 1410, 'end_line': 1416, 'offset_start': 46997, 'offset_end': 47226, 'content': 'function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.renew', 'start_line': 1418, 'end_line': 1421, 'offset_start': 47233, 'offset_end': 47341, 'content': 'function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.unwrap', 'start_line': 1423, 'end_line': 1423, 'offset_start': 47348, 'offset_end': 47416, 'content': 'function unwrap(bytes32 node, bytes32 label, address owner) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.unwrapETH2LD', 'start_line': 1425, 'end_line': 1429, 'offset_start': 47423, 'offset_end': 47544, 'content': 'function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.upgrade', 'start_line': 1431, 'end_line': 1431, 'offset_start': 47551, 'offset_end': 47623, 'content': 'function upgrade(bytes calldata name, bytes calldata extraData) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setFuses', 'start_line': 1433, 'end_line': 1436, 'offset_start': 47630, 'offset_end': 47747, 'content': 'function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setChildFuses', 'start_line': 1438, 'end_line': 1443, 'offset_start': 47754, 'offset_end': 47891, 'content': 'function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setSubnodeRecord', 'start_line': 1445, 'end_line': 1453, 'offset_start': 47898, 'offset_end': 48123, 'content': 'function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setRecord', 'start_line': 1455, 'end_line': 1460, 'offset_start': 48130, 'offset_end': 48254, 'content': 'function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setSubnodeOwner', 'start_line': 1462, 'end_line': 1468, 'offset_start': 48261, 'offset_end': 48442, 'content': 'function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.extendExpiry', 'start_line': 1470, 'end_line': 1474, 'offset_start': 48449, 'offset_end': 48574, 'content': 'function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.canModifyName', 'start_line': 1476, 'end_line': 1479, 'offset_start': 48581, 'offset_end': 48682, 'content': 'function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setResolver', 'start_line': 1481, 'end_line': 1481, 'offset_start': 48689, 'offset_end': 48750, 'content': 'function setResolver(bytes32 node, address resolver) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setTTL', 'start_line': 1483, 'end_line': 1483, 'offset_start': 48757, 'offset_end': 48807, 'content': 'function setTTL(bytes32 node, uint64 ttl) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.ownerOf', 'start_line': 1485, 'end_line': 1485, 'offset_start': 48814, 'offset_end': 48880, 'content': 'function ownerOf(uint256 id) external view returns (address owner);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.approve', 'start_line': 1487, 'end_line': 1487, 'offset_start': 48887, 'offset_end': 48941, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.getApproved', 'start_line': 1489, 'end_line': 1489, 'offset_start': 48948, 'offset_end': 49017, 'content': 'function getApproved(uint256 tokenId) external view returns (address);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.getData', 'start_line': 1491, 'end_line': 1493, 'offset_start': 49024, 'offset_end': 49114, 'content': 'function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setMetadataService', 'start_line': 1495, 'end_line': 1495, 'offset_start': 49121, 'offset_end': 49192, 'content': 'function setMetadataService(IMetadataService _metadataService) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.uri', 'start_line': 1497, 'end_line': 1497, 'offset_start': 49199, 'offset_end': 49266, 'content': 'function uri(uint256 tokenId) external view returns (string memory);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.setUpgradeContract', 'start_line': 1499, 'end_line': 1499, 'offset_start': 49273, 'offset_end': 49346, 'content': 'function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.allFusesBurned', 'start_line': 1501, 'end_line': 1504, 'offset_start': 49353, 'offset_end': 49458, 'content': 'function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.isWrapped', 'start_line': 1506, 'end_line': 1506, 'offset_start': 49465, 'offset_end': 49521, 'content': 'function isWrapped(bytes32) external view returns (bool);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'INameWrapper.isWrapped', 'start_line': 1508, 'end_line': 1508, 'offset_start': 49528, 'offset_end': 49593, 'content': 'function isWrapped(bytes32, bytes32) external view returns (bool);', 'contract_name': 'INameWrapper', 'contract_code': '{\n    event NameWrapped(\n        bytes32 indexed node,\n        bytes name,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    );\n\n    event NameUnwrapped(bytes32 indexed node, address owner);\n\n    event FusesSet(bytes32 indexed node, uint32 fuses);\n    event ExpiryExtended(bytes32 indexed node, uint64 expiry);\n\n    function ens() external view returns (ENS);\n\n    function registrar() external view returns (IBaseRegistrar);\n\n    function metadataService() external view returns (IMetadataService);\n\n    function names(bytes32) external view returns (bytes memory);\n\n    function name() external view returns (string memory);\n\n    function upgradeContract() external view returns (INameWrapperUpgrade);\n\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n\n    function wrap(\n        bytes calldata name,\n        address wrappedOwner,\n        address resolver\n    ) external;\n\n    function wrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint16 ownerControlledFuses,\n        address resolver\n    ) external returns (uint64 expires);\n\n    function registerAndWrapETH2LD(\n        string calldata label,\n        address wrappedOwner,\n        uint256 duration,\n        address resolver,\n        uint16 ownerControlledFuses\n    ) external returns (uint256 registrarExpiry);\n\n    function renew(\n        uint256 labelHash,\n        uint256 duration\n    ) external returns (uint256 expires);\n\n    function unwrap(bytes32 node, bytes32 label, address owner) external;\n\n    function unwrapETH2LD(\n        bytes32 label,\n        address newRegistrant,\n        address newController\n    ) external;\n\n    function upgrade(bytes calldata name, bytes calldata extraData) external;\n\n    function setFuses(\n        bytes32 node,\n        uint16 ownerControlledFuses\n    ) external returns (uint32 newFuses);\n\n    function setChildFuses(\n        bytes32 parentNode,\n        bytes32 labelhash,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        string calldata label,\n        address newOwner,\n        uint32 fuses,\n        uint64 expiry\n    ) external returns (bytes32);\n\n    function extendExpiry(\n        bytes32 node,\n        bytes32 labelhash,\n        uint64 expiry\n    ) external returns (uint64);\n\n    function canModifyName(\n        bytes32 node,\n        address addr\n    ) external view returns (bool);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function ownerOf(uint256 id) external view returns (address owner);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getData(\n        uint256 id\n    ) external view returns (address, uint32, uint64);\n\n    function setMetadataService(IMetadataService _metadataService) external;\n\n    function uri(uint256 tokenId) external view returns (string memory);\n\n    function setUpgradeContract(INameWrapperUpgrade _upgradeAddress) external;\n\n    function allFusesBurned(\n        bytes32 node,\n        uint32 fuseMask\n    ) external view returns (bool);\n\n    function isWrapped(bytes32) external view returns (bool);\n\n    function isWrapped(bytes32, bytes32) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 1540, 'end_line': 1540, 'offset_start': 50552, 'offset_end': 50625, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 1549, 'end_line': 1549, 'offset_start': 50768, 'offset_end': 50839, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 1564, 'end_line': 1569, 'offset_start': 51407, 'offset_end': 51543, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 1585, 'end_line': 1589, 'offset_start': 52242, 'offset_end': 52349, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 1607, 'end_line': 1611, 'offset_start': 53093, 'offset_end': 53196, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 1626, 'end_line': 1626, 'offset_start': 53660, 'offset_end': 53714, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 1638, 'end_line': 1638, 'offset_start': 54035, 'offset_end': 54104, 'content': 'function setApprovalForAll(address operator, bool _approved) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 1647, 'end_line': 1647, 'offset_start': 54255, 'offset_end': 54333, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 1654, 'end_line': 1654, 'offset_start': 54483, 'offset_end': 54570, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 1672, 'end_line': 1672, 'offset_start': 54978, 'offset_end': 55031, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 1677, 'end_line': 1677, 'offset_start': 55103, 'offset_end': 55158, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 1682, 'end_line': 1682, 'offset_start': 55260, 'offset_end': 55332, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setRecord', 'start_line': 1707, 'end_line': 1712, 'offset_start': 56059, 'offset_end': 56183, 'content': 'function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setSubnodeRecord', 'start_line': 1714, 'end_line': 1720, 'offset_start': 56190, 'offset_end': 56344, 'content': 'function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setSubnodeOwner', 'start_line': 1722, 'end_line': 1726, 'offset_start': 56351, 'offset_end': 56476, 'content': 'function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setResolver', 'start_line': 1728, 'end_line': 1728, 'offset_start': 56483, 'offset_end': 56544, 'content': 'function setResolver(bytes32 node, address resolver) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setOwner', 'start_line': 1730, 'end_line': 1730, 'offset_start': 56551, 'offset_end': 56606, 'content': 'function setOwner(bytes32 node, address owner) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setTTL', 'start_line': 1732, 'end_line': 1732, 'offset_start': 56613, 'offset_end': 56663, 'content': 'function setTTL(bytes32 node, uint64 ttl) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.setApprovalForAll', 'start_line': 1734, 'end_line': 1734, 'offset_start': 56670, 'offset_end': 56738, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.owner', 'start_line': 1736, 'end_line': 1736, 'offset_start': 56745, 'offset_end': 56805, 'content': 'function owner(bytes32 node) external view returns (address);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.resolver', 'start_line': 1738, 'end_line': 1738, 'offset_start': 56812, 'offset_end': 56875, 'content': 'function resolver(bytes32 node) external view returns (address);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.ttl', 'start_line': 1740, 'end_line': 1740, 'offset_start': 56882, 'offset_end': 56939, 'content': 'function ttl(bytes32 node) external view returns (uint64);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.recordExists', 'start_line': 1742, 'end_line': 1742, 'offset_start': 56946, 'offset_end': 57010, 'content': 'function recordExists(bytes32 node) external view returns (bool);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ENS.isApprovedForAll', 'start_line': 1744, 'end_line': 1747, 'offset_start': 57017, 'offset_end': 57126, 'content': 'function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);', 'contract_name': 'ENS', 'contract_code': '{\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165.supportsInterface', 'start_line': 1775, 'end_line': 1777, 'offset_start': 57960, 'offset_end': 58114, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165', 'contract_code': '{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation._isApprovedOrOwner', 'start_line': 1823, 'end_line': 1831, 'offset_start': 60216, 'offset_end': 60516, 'content': 'function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.tor', 'start_line': 1833, 'end_line': 1836, 'offset_start': 60523, 'offset_end': 60635, 'content': 'constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.ownerOf', 'start_line': 1854, 'end_line': 1859, 'offset_start': 61108, 'offset_end': 61311, 'content': 'function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.addController', 'start_line': 1862, 'end_line': 1865, 'offset_start': 61386, 'offset_end': 61545, 'content': 'function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.removeController', 'start_line': 1868, 'end_line': 1871, 'offset_start': 61604, 'offset_end': 61769, 'content': 'function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.setResolver', 'start_line': 1874, 'end_line': 1876, 'offset_start': 61836, 'offset_end': 61954, 'content': 'function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.nameExpires', 'start_line': 1879, 'end_line': 1881, 'offset_start': 62022, 'offset_end': 62131, 'content': 'function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.available', 'start_line': 1884, 'end_line': 1887, 'offset_start': 62212, 'offset_end': 62420, 'content': "function available(uint256 id) public view override returns (bool) {\n        // Not available if it's registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }", 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.register', 'start_line': 1895, 'end_line': 1901, 'offset_start': 62659, 'offset_end': 62847, 'content': 'function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.registerOnly', 'start_line': 1909, 'end_line': 1915, 'offset_start': 63118, 'offset_end': 63302, 'content': 'function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation._register', 'start_line': 1917, 'end_line': 1942, 'offset_start': 63309, 'offset_end': 64083, 'content': 'function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.renew', 'start_line': 1944, 'end_line': 1956, 'offset_start': 64090, 'offset_end': 64575, 'content': 'function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.reclaim', 'start_line': 1961, 'end_line': 1964, 'offset_start': 64678, 'offset_end': 64863, 'content': 'function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'BaseRegistrarImplementation.supportsInterface', 'start_line': 1966, 'end_line': 1973, 'offset_start': 64870, 'offset_end': 65132, 'content': 'function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }', 'contract_name': 'BaseRegistrarImplementation', 'contract_code': '{\n    // A map of expiry times\n    mapping(uint256 => uint256) expiries;\n    // The ENS registry\n    ENS public ens;\n    // The namehash of the TLD this registrar owns (eg, .eth)\n    bytes32 public baseNode;\n    // A map of addresses that are authorised to register and renew names.\n    mapping(address => bool) public controllers;\n    uint256 public constant GRACE_PERIOD = 90 days;\n    bytes4 private constant INTERFACE_META_ID =\n        bytes4(keccak256("supportsInterface(bytes4)"));\n    bytes4 private constant ERC721_ID =\n        bytes4(\n            keccak256("balanceOf(address)") ^\n                keccak256("ownerOf(uint256)") ^\n                keccak256("approve(address,uint256)") ^\n                keccak256("getApproved(uint256)") ^\n                keccak256("setApprovalForAll(address,bool)") ^\n                keccak256("isApprovedForAll(address,address)") ^\n                keccak256("transferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256)") ^\n                keccak256("safeTransferFrom(address,address,uint256,bytes)")\n        );\n    bytes4 private constant RECLAIM_ID =\n        bytes4(keccak256("reclaim(uint256,address)"));\n\n    /**\n     * v2.1.3 version of _isApprovedOrOwner which calls ownerOf(tokenId) and takes grace period into consideration instead of ERC721.ownerOf(tokenId);\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.1.3/contracts/token/ERC721/ERC721.sol#L187\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     *    is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(\n        address spender,\n        uint256 tokenId\n    ) internal view override returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(owner, spender));\n    }\n\n    constructor(ENS _ens, bytes32 _baseNode) ERC721("", "") {\n        ens = _ens;\n        baseNode = _baseNode;\n    }\n\n    modifier live() {\n        require(ens.owner(baseNode) == address(this));\n        _;\n    }\n\n    modifier onlyController() {\n        require(controllers[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID. Names become unowned\n     *      when their registration expires.\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(\n        uint256 tokenId\n    ) public view override(IERC721, ERC721) returns (address) {\n        require(expiries[tokenId] > block.timestamp);\n        return super.ownerOf(tokenId);\n    }\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external override onlyOwner {\n        controllers[controller] = true;\n        emit ControllerAdded(controller);\n    }\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external override onlyOwner {\n        controllers[controller] = false;\n        emit ControllerRemoved(controller);\n    }\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external override onlyOwner {\n        ens.setResolver(baseNode, resolver);\n    }\n\n    // Returns the expiration timestamp of the specified id.\n    function nameExpires(uint256 id) external view override returns (uint256) {\n        return expiries[id];\n    }\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) public view override returns (bool) {\n        // Not available if it\'s registered here or in its grace period.\n        return expiries[id] + GRACE_PERIOD < block.timestamp;\n    }\n\n    /**\n     * @dev Register a name.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external override returns (uint256) {\n        return _register(id, owner, duration, true);\n    }\n\n    /**\n     * @dev Register a name, without modifying the registry.\n     * @param id The token ID (keccak256 of the label).\n     * @param owner The address that should own the registration.\n     * @param duration Duration in seconds for the registration.\n     */\n    function registerOnly(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256) {\n        return _register(id, owner, duration, false);\n    }\n\n    function _register(\n        uint256 id,\n        address owner,\n        uint256 duration,\n        bool updateRegistry\n    ) internal live onlyController returns (uint256) {\n        require(available(id));\n        require(\n            block.timestamp + duration + GRACE_PERIOD >\n                block.timestamp + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] = block.timestamp + duration;\n        if (_exists(id)) {\n            // Name was previously owned, and expired\n            _burn(id);\n        }\n        _mint(owner, id);\n        if (updateRegistry) {\n            ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n        }\n\n        emit NameRegistered(id, owner, block.timestamp + duration);\n\n        return block.timestamp + duration;\n    }\n\n    function renew(\n        uint256 id,\n        uint256 duration\n    ) external override live onlyController returns (uint256) {\n        require(expiries[id] + GRACE_PERIOD >= block.timestamp); // Name must be registered here or in grace period\n        require(\n            expiries[id] + duration + GRACE_PERIOD > duration + GRACE_PERIOD\n        ); // Prevent future overflow\n\n        expiries[id] += duration;\n        emit NameRenewed(id, expiries[id]);\n        return expiries[id];\n    }\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external override live {\n        require(_isApprovedOrOwner(msg.sender, id));\n        ens.setSubnodeOwner(baseNode, bytes32(id), owner);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) public view override(ERC721, IERC165) returns (bool) {\n        return\n            interfaceID == INTERFACE_META_ID ||\n            interfaceID == ERC721_ID ||\n            interfaceID == RECLAIM_ID;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.addController', 'start_line': 1996, 'end_line': 1996, 'offset_start': 65771, 'offset_end': 65822, 'content': 'function addController(address controller) external;', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.removeController', 'start_line': 1999, 'end_line': 1999, 'offset_start': 65881, 'offset_end': 65935, 'content': 'function removeController(address controller) external;', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.setResolver', 'start_line': 2002, 'end_line': 2002, 'offset_start': 66002, 'offset_end': 66049, 'content': 'function setResolver(address resolver) external;', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.nameExpires', 'start_line': 2005, 'end_line': 2005, 'offset_start': 66125, 'offset_end': 66189, 'content': 'function nameExpires(uint256 id) external view returns (uint256);', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.available', 'start_line': 2008, 'end_line': 2008, 'offset_start': 66270, 'offset_end': 66329, 'content': 'function available(uint256 id) external view returns (bool);', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.register', 'start_line': 2013, 'end_line': 2017, 'offset_start': 66381, 'offset_end': 66500, 'content': 'function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.renew', 'start_line': 2019, 'end_line': 2019, 'offset_start': 66507, 'offset_end': 66578, 'content': 'function renew(uint256 id, uint256 duration) external returns (uint256);', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IBaseRegistrar.reclaim', 'start_line': 2024, 'end_line': 2024, 'offset_start': 66681, 'offset_end': 66733, 'content': 'function reclaim(uint256 id, address owner) external;', 'contract_name': 'IBaseRegistrar', 'contract_code': '{\n    event ControllerAdded(address indexed controller);\n    event ControllerRemoved(address indexed controller);\n    event NameMigrated(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRegistered(\n        uint256 indexed id,\n        address indexed owner,\n        uint256 expires\n    );\n    event NameRenewed(uint256 indexed id, uint256 expires);\n\n    // Authorises a controller, who can register and renew domains.\n    function addController(address controller) external;\n\n    // Revoke controller permission for an address.\n    function removeController(address controller) external;\n\n    // Set the resolver for the TLD this registrar manages.\n    function setResolver(address resolver) external;\n\n    // Returns the expiration timestamp of the specified label hash.\n    function nameExpires(uint256 id) external view returns (uint256);\n\n    // Returns true iff the specified name is available for registration.\n    function available(uint256 id) external view returns (bool);\n\n    /**\n     * @dev Register a name.\n     */\n    function register(\n        uint256 id,\n        address owner,\n        uint256 duration\n    ) external returns (uint256);\n\n    function renew(uint256 id, uint256 duration) external returns (uint256);\n\n    /**\n     * @dev Reclaim ownership of a name in ENS, if you own it in the registrar.\n     */\n    function reclaim(uint256 id, address owner) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 2053, 'end_line': 2053, 'offset_start': 67512, 'offset_end': 67566, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 2058, 'end_line': 2058, 'offset_start': 67650, 'offset_end': 67717, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 2067, 'end_line': 2067, 'offset_start': 67931, 'offset_end': 68000, 'content': 'function transfer(address to, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 2076, 'end_line': 2076, 'offset_start': 68276, 'offset_end': 68358, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 2092, 'end_line': 2092, 'offset_start': 69012, 'offset_end': 69085, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 2103, 'end_line': 2107, 'offset_start': 69384, 'offset_end': 69501, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': "{\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Controllable.setController', 'start_line': 2127, 'end_line': 2130, 'offset_start': 69916, 'offset_end': 70092, 'content': 'function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }', 'contract_name': 'Controllable', 'contract_code': '{\n    mapping(address => bool) public controllers;\n\n    event ControllerChanged(address indexed controller, bool enabled);\n\n    modifier onlyController() {\n        require(\n            controllers[msg.sender],\n            "Controllable: Caller is not a controller"\n        );\n        _;\n    }\n\n    function setController(address controller, bool enabled) public onlyOwner {\n        controllers[controller] = enabled;\n        emit ControllerChanged(controller, enabled);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IInterfaceResolver.interfaceImplementer', 'start_line': 2153, 'end_line': 2156, 'offset_start': 70951, 'offset_end': 71068, 'content': 'function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);', 'contract_name': 'IInterfaceResolver', 'contract_code': '{\n    event InterfaceChanged(\n        bytes32 indexed node,\n        bytes4 indexed interfaceID,\n        address implementer\n    );\n\n    /**\n     * Returns the address of a contract that implements the specified interface for this name.\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\n     * will be returned.\n     * @param node The ENS node to query.\n     * @param interfaceID The EIP 165 interface ID to check for.\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\n     */\n    function interfaceImplementer(\n        bytes32 node,\n        bytes4 interfaceID\n    ) external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IContentHashResolver.contenthash', 'start_line': 2170, 'end_line': 2170, 'offset_start': 71394, 'offset_end': 71465, 'content': 'function contenthash(bytes32 node) external view returns (bytes memory);', 'contract_name': 'IContentHashResolver', 'contract_code': '{\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\n\n    /**\n     * Returns the contenthash associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function contenthash(bytes32 node) external view returns (bytes memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20Recoverable.recoverFunds', 'start_line': 2191, 'end_line': 2197, 'offset_start': 72103, 'offset_end': 72273, 'content': 'function recoverFunds(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_token).transfer(_to, _amount);\n    }', 'contract_name': 'ERC20Recoverable', 'contract_code': '{\n    /**\n    @notice Recover ERC20 tokens sent to the contract by mistake.\n    @dev The contract is Ownable and only the owner can call the recover function.\n    @param _to The address to send the tokens to.\n@param _token The address of the ERC20 token to recover\n    @param _amount The amount of tokens to recover.\n */\n    function recoverFunds(\n        address _token,\n        address _to,\n        uint256 _amount\n    ) external onlyOwner {\n        IERC20(_token).transfer(_to, _amount);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDNSZoneResolver.zonehash', 'start_line': 2216, 'end_line': 2216, 'offset_start': 72719, 'offset_end': 72787, 'content': 'function zonehash(bytes32 node) external view returns (bytes memory);', 'contract_name': 'IDNSZoneResolver', 'contract_code': "{\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\n    event DNSZonehashChanged(\n        bytes32 indexed node,\n        bytes lastzonehash,\n        bytes zonehash\n    );\n\n    /**\n     * zonehash obtains the hash for the zone.\n     * @param node The ENS node to query.\n     * @return The associated contenthash.\n     */\n    function zonehash(bytes32 node) external view returns (bytes memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.tor', 'start_line': 2288, 'end_line': 2311, 'offset_start': 75216, 'offset_end': 75953, 'content': 'constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.rentPrice', 'start_line': 2313, 'end_line': 2319, 'offset_start': 75960, 'offset_end': 76236, 'content': 'function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.valid', 'start_line': 2321, 'end_line': 2323, 'offset_start': 76243, 'offset_end': 76346, 'content': 'function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.available', 'start_line': 2325, 'end_line': 2328, 'offset_start': 76353, 'offset_end': 76544, 'content': 'function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.makeCommitment', 'start_line': 2330, 'end_line': 2357, 'offset_start': 76551, 'offset_end': 77362, 'content': 'function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.commit', 'start_line': 2359, 'end_line': 2364, 'offset_start': 77369, 'offset_end': 77623, 'content': 'function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.register', 'start_line': 2366, 'end_line': 2426, 'offset_start': 77630, 'offset_end': 79174, 'content': 'function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.renew', 'start_line': 2428, 'end_line': 2445, 'offset_start': 79181, 'offset_end': 79788, 'content': 'function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.withdraw', 'start_line': 2447, 'end_line': 2449, 'offset_start': 79795, 'offset_end': 79886, 'content': 'function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController.supportsInterface', 'start_line': 2451, 'end_line': 2457, 'offset_start': 79893, 'offset_end': 80130, 'content': 'function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController._consumeCommitment', 'start_line': 2461, 'end_line': 2484, 'offset_start': 80167, 'offset_end': 80926, 'content': 'function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController._setRecords', 'start_line': 2486, 'end_line': 2495, 'offset_start': 80933, 'offset_end': 81286, 'content': 'function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ETHRegistrarController._setReverseRecord', 'start_line': 2497, 'end_line': 2508, 'offset_start': 81293, 'offset_end': 81575, 'content': 'function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }', 'contract_name': 'ETHRegistrarController', 'contract_code': '{\n    using StringUtils for *;\n    using Address for address;\n\n    uint256 public constant MIN_REGISTRATION_DURATION = 28 days;\n    bytes32 private constant ETH_NODE =\n        0x93cdeb708b7545dc668eb9280176169d1c33cfd8ed6f04690a0bcc88a93fc4ae;\n    uint64 private constant MAX_EXPIRY = type(uint64).max;\n    BaseRegistrarImplementation immutable base;\n    IPriceOracle public immutable prices;\n    uint256 public immutable minCommitmentAge;\n    uint256 public immutable maxCommitmentAge;\n    ReverseRegistrar public immutable reverseRegistrar;\n    INameWrapper public immutable nameWrapper;\n\n    mapping(bytes32 => uint256) public commitments;\n\n    event NameRegistered(\n        string name,\n        bytes32 indexed label,\n        address indexed owner,\n        uint256 baseCost,\n        uint256 premium,\n        uint256 expires\n    );\n    event NameRenewed(\n        string name,\n        bytes32 indexed label,\n        uint256 cost,\n        uint256 expires\n    );\n\n    constructor(\n        BaseRegistrarImplementation _base,\n        IPriceOracle _prices,\n        uint256 _minCommitmentAge,\n        uint256 _maxCommitmentAge,\n        ReverseRegistrar _reverseRegistrar,\n        INameWrapper _nameWrapper,\n        ENS _ens\n    ) ReverseClaimer(_ens, msg.sender) {\n        if (_maxCommitmentAge <= _minCommitmentAge) {\n            revert MaxCommitmentAgeTooLow();\n        }\n\n        if (_maxCommitmentAge > block.timestamp) {\n            revert MaxCommitmentAgeTooHigh();\n        }\n\n        base = _base;\n        prices = _prices;\n        minCommitmentAge = _minCommitmentAge;\n        maxCommitmentAge = _maxCommitmentAge;\n        reverseRegistrar = _reverseRegistrar;\n        nameWrapper = _nameWrapper;\n    }\n\n    function rentPrice(\n        string memory name,\n        uint256 duration\n    ) public view override returns (IPriceOracle.Price memory price) {\n        bytes32 label = keccak256(bytes(name));\n        price = prices.price(name, base.nameExpires(uint256(label)), duration);\n    }\n\n    function valid(string memory name) public pure returns (bool) {\n        return name.strlen() >= 3;\n    }\n\n    function available(string memory name) public view override returns (bool) {\n        bytes32 label = keccak256(bytes(name));\n        return valid(name) && base.available(uint256(label));\n    }\n\n    function makeCommitment(\n        string memory name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public pure override returns (bytes32) {\n        bytes32 label = keccak256(bytes(name));\n        if (data.length > 0 && resolver == address(0)) {\n            revert ResolverRequiredWhenDataSupplied();\n        }\n        return\n            keccak256(\n                abi.encode(\n                    label,\n                    owner,\n                    duration,\n                    secret,\n                    resolver,\n                    data,\n                    reverseRecord,\n                    ownerControlledFuses\n                )\n            );\n    }\n\n    function commit(bytes32 commitment) public override {\n        if (commitments[commitment] + maxCommitmentAge >= block.timestamp) {\n            revert UnexpiredCommitmentExists(commitment);\n        }\n        commitments[commitment] = block.timestamp;\n    }\n\n    function register(\n        string calldata name,\n        address owner,\n        uint256 duration,\n        bytes32 secret,\n        address resolver,\n        bytes[] calldata data,\n        bool reverseRecord,\n        uint16 ownerControlledFuses\n    ) public payable override {\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base + price.premium) {\n            revert InsufficientValue();\n        }\n\n        _consumeCommitment(\n            name,\n            duration,\n            makeCommitment(\n                name,\n                owner,\n                duration,\n                secret,\n                resolver,\n                data,\n                reverseRecord,\n                ownerControlledFuses\n            )\n        );\n\n        uint256 expires = nameWrapper.registerAndWrapETH2LD(\n            name,\n            owner,\n            duration,\n            resolver,\n            ownerControlledFuses\n        );\n\n        if (data.length > 0) {\n            _setRecords(resolver, keccak256(bytes(name)), data);\n        }\n\n        if (reverseRecord) {\n            _setReverseRecord(name, resolver, msg.sender);\n        }\n\n        emit NameRegistered(\n            name,\n            keccak256(bytes(name)),\n            owner,\n            price.base,\n            price.premium,\n            expires\n        );\n\n        if (msg.value > (price.base + price.premium)) {\n            payable(msg.sender).transfer(\n                msg.value - (price.base + price.premium)\n            );\n        }\n    }\n\n    function renew(\n        string calldata name,\n        uint256 duration\n    ) external payable override {\n        bytes32 labelhash = keccak256(bytes(name));\n        uint256 tokenId = uint256(labelhash);\n        IPriceOracle.Price memory price = rentPrice(name, duration);\n        if (msg.value < price.base) {\n            revert InsufficientValue();\n        }\n        uint256 expires = nameWrapper.renew(tokenId, duration);\n\n        if (msg.value > price.base) {\n            payable(msg.sender).transfer(msg.value - price.base);\n        }\n\n        emit NameRenewed(name, labelhash, msg.value, expires);\n    }\n\n    function withdraw() public {\n        payable(owner()).transfer(address(this).balance);\n    }\n\n    function supportsInterface(\n        bytes4 interfaceID\n    ) external pure returns (bool) {\n        return\n            interfaceID == type(IERC165).interfaceId ||\n            interfaceID == type(IETHRegistrarController).interfaceId;\n    }\n\n    /* Internal functions */\n\n    function _consumeCommitment(\n        string memory name,\n        uint256 duration,\n        bytes32 commitment\n    ) internal {\n        // Require an old enough commitment.\n        if (commitments[commitment] + minCommitmentAge > block.timestamp) {\n            revert CommitmentTooNew(commitment);\n        }\n\n        // If the commitment is too old, or the name is registered, stop\n        if (commitments[commitment] + maxCommitmentAge <= block.timestamp) {\n            revert CommitmentTooOld(commitment);\n        }\n        if (!available(name)) {\n            revert NameNotAvailable(name);\n        }\n\n        delete (commitments[commitment]);\n\n        if (duration < MIN_REGISTRATION_DURATION) {\n            revert DurationTooShort(duration);\n        }\n    }\n\n    function _setRecords(\n        address resolverAddress,\n        bytes32 label,\n        bytes[] calldata data\n    ) internal {\n        // use hardcoded .eth namehash\n        bytes32 nodehash = keccak256(abi.encodePacked(ETH_NODE, label));\n        Resolver resolver = Resolver(resolverAddress);\n        resolver.multicallWithNodeCheck(nodehash, data);\n    }\n\n    function _setReverseRecord(\n        string memory name,\n        address resolver,\n        address owner\n    ) internal {\n        reverseRegistrar.setNameForAddr(\n            msg.sender,\n            owner,\n            resolver,\n            string.concat(name, ".eth")\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 2528, 'end_line': 2548, 'offset_start': 81995, 'offset_end': 82690, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 2553, 'end_line': 2557, 'offset_start': 82796, 'offset_end': 82969, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 2562, 'end_line': 2572, 'offset_start': 83093, 'offset_end': 83529, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 2577, 'end_line': 2579, 'offset_start': 83682, 'offset_end': 83830, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _SYMBOLS = "0123456789abcdef";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.rentPrice', 'start_line': 2588, 'end_line': 2591, 'offset_start': 83962, 'offset_end': 84076, 'content': 'function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.available', 'start_line': 2593, 'end_line': 2593, 'offset_start': 84083, 'offset_end': 84140, 'content': 'function available(string memory) external returns (bool);', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.makeCommitment', 'start_line': 2595, 'end_line': 2604, 'offset_start': 84147, 'offset_end': 84355, 'content': 'function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.commit', 'start_line': 2606, 'end_line': 2606, 'offset_start': 84362, 'offset_end': 84395, 'content': 'function commit(bytes32) external;', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.register', 'start_line': 2608, 'end_line': 2617, 'offset_start': 84402, 'offset_end': 84591, 'content': 'function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IETHRegistrarController.renew', 'start_line': 2619, 'end_line': 2619, 'offset_start': 84598, 'offset_end': 84655, 'content': 'function renew(string calldata, uint256) external payable;', 'contract_name': 'IETHRegistrarController', 'contract_code': '{\n    function rentPrice(\n        string memory,\n        uint256\n    ) external view returns (IPriceOracle.Price memory);\n\n    function available(string memory) external returns (bool);\n\n    function makeCommitment(\n        string memory,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external pure returns (bytes32);\n\n    function commit(bytes32) external;\n\n    function register(\n        string calldata,\n        address,\n        uint256,\n        bytes32,\n        address,\n        bytes[] calldata,\n        bool,\n        uint16\n    ) external payable;\n\n    function renew(string calldata, uint256) external payable;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.setDefaultResolver', 'start_line': 2625, 'end_line': 2625, 'offset_start': 84720, 'offset_end': 84774, 'content': 'function setDefaultResolver(address resolver) external;', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.claim', 'start_line': 2627, 'end_line': 2627, 'offset_start': 84781, 'offset_end': 84837, 'content': 'function claim(address owner) external returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.claimForAddr', 'start_line': 2629, 'end_line': 2633, 'offset_start': 84844, 'offset_end': 84969, 'content': 'function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.claimWithResolver', 'start_line': 2635, 'end_line': 2638, 'offset_start': 84976, 'offset_end': 85084, 'content': 'function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.setName', 'start_line': 2640, 'end_line': 2640, 'offset_start': 85091, 'offset_end': 85154, 'content': 'function setName(string memory name) external returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.setNameForAddr', 'start_line': 2642, 'end_line': 2647, 'offset_start': 85161, 'offset_end': 85316, 'content': 'function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IReverseRegistrar.node', 'start_line': 2649, 'end_line': 2649, 'offset_start': 85323, 'offset_end': 85382, 'content': 'function node(address addr) external pure returns (bytes32);', 'contract_name': 'IReverseRegistrar', 'contract_code': '{\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IAddrResolver.addr', 'start_line': 2666, 'end_line': 2666, 'offset_start': 85747, 'offset_end': 85814, 'content': 'function addr(bytes32 node) external view returns (address payable);', 'contract_name': 'IAddrResolver', 'contract_code': '{\n    event AddrChanged(bytes32 indexed node, address a);\n\n    /**\n     * Returns the address associated with an ENS node.\n     * @param node The ENS node to query.\n     * @return The associated address.\n     */\n    function addr(bytes32 node) external view returns (address payable);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDNSRecordResolver.dnsRecord', 'start_line': 2690, 'end_line': 2694, 'offset_start': 86701, 'offset_end': 86831, 'content': 'function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);', 'contract_name': 'IDNSRecordResolver', 'contract_code': "{\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\n    event DNSRecordChanged(\n        bytes32 indexed node,\n        bytes name,\n        uint16 resource,\n        bytes record\n    );\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\n\n    /**\n     * Obtain a DNS record.\n     * @param node the namehash of the node for which to fetch the record\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\n     * @return the DNS record in wire format if present, otherwise empty\n     */\n    function dnsRecord(\n        bytes32 node,\n        bytes32 name,\n        uint16 resource\n    ) external view returns (bytes memory);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tor', 'start_line': 2740, 'end_line': 2743, 'offset_start': 88226, 'offset_end': 88338, 'content': 'constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.supportsInterface', 'start_line': 2748, 'end_line': 2753, 'offset_start': 88406, 'offset_end': 88705, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.balanceOf', 'start_line': 2758, 'end_line': 2761, 'offset_start': 88765, 'offset_end': 88968, 'content': 'function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.ownerOf', 'start_line': 2766, 'end_line': 2770, 'offset_start': 89026, 'offset_end': 89244, 'content': 'function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.name', 'start_line': 2775, 'end_line': 2777, 'offset_start': 89307, 'offset_end': 89404, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.symbol', 'start_line': 2782, 'end_line': 2784, 'offset_start': 89469, 'offset_end': 89570, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.tokenURI', 'start_line': 2789, 'end_line': 2794, 'offset_start': 89637, 'offset_end': 89912, 'content': 'function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._baseURI', 'start_line': 2801, 'end_line': 2803, 'offset_start': 90155, 'offset_end': 90246, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.approve', 'start_line': 2808, 'end_line': 2818, 'offset_start': 90304, 'offset_end': 90709, 'content': 'function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.getApproved', 'start_line': 2823, 'end_line': 2827, 'offset_start': 90771, 'offset_end': 90937, 'content': 'function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.setApprovalForAll', 'start_line': 2832, 'end_line': 2834, 'offset_start': 91005, 'offset_end': 91157, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.isApprovedForAll', 'start_line': 2839, 'end_line': 2841, 'offset_start': 91224, 'offset_end': 91385, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.transferFrom', 'start_line': 2846, 'end_line': 2855, 'offset_start': 91448, 'offset_end': 91773, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 2860, 'end_line': 2866, 'offset_start': 91840, 'offset_end': 92018, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721.safeTransferFrom', 'start_line': 2871, 'end_line': 2879, 'offset_start': 92085, 'offset_end': 92398, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeTransfer', 'start_line': 2899, 'end_line': 2907, 'offset_start': 93260, 'offset_end': 93564, 'content': 'function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._ownerOf', 'start_line': 2912, 'end_line': 2914, 'offset_start': 93674, 'offset_end': 93788, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._exists', 'start_line': 2924, 'end_line': 2926, 'offset_start': 94092, 'offset_end': 94217, 'content': 'function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._isApprovedOrOwner', 'start_line': 2935, 'end_line': 2938, 'offset_start': 94376, 'offset_end': 94636, 'content': 'function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 2950, 'end_line': 2952, 'offset_start': 94967, 'offset_end': 95074, 'content': 'function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._safeMint', 'start_line': 2958, 'end_line': 2968, 'offset_start': 95296, 'offset_end': 95604, 'content': 'function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._mint', 'start_line': 2982, 'end_line': 3004, 'offset_start': 95927, 'offset_end': 96846, 'content': 'function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._burn', 'start_line': 3017, 'end_line': 3038, 'offset_start': 97173, 'offset_end': 97934, 'content': 'function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._transfer', 'start_line': 3051, 'end_line': 3081, 'offset_start': 98259, 'offset_end': 99491, 'content': 'function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._approve', 'start_line': 3088, 'end_line': 3091, 'offset_start': 99604, 'offset_end': 99774, 'content': 'function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._setApprovalForAll', 'start_line': 3098, 'end_line': 3106, 'offset_start': 99911, 'offset_end': 100217, 'content': 'function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._requireMinted', 'start_line': 3111, 'end_line': 3113, 'offset_start': 100302, 'offset_end': 100434, 'content': 'function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._checkOnERC721Received', 'start_line': 3125, 'end_line': 3147, 'offset_start': 100987, 'offset_end': 101817, 'content': 'function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._beforeTokenTransfer', 'start_line': 3163, 'end_line': 3177, 'offset_start': 102534, 'offset_end': 102929, 'content': 'function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721._afterTokenTransfer', 'start_line': 3193, 'end_line': 3198, 'offset_start': 103636, 'offset_end': 103788, 'content': 'function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}', 'contract_name': 'ERC721', 'contract_code': '{\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), "ERC721: address zero is not a valid owner");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), "ERC721: invalid token ID");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, "ERC721: approval to current owner");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            "ERC721: approve caller is not token owner or approved for all"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn\'t exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, "");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            "ERC721: transfer to non ERC721Receiver implementer"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), "ERC721: mint to the zero address");\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), "ERC721: token already minted");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n        require(to != address(0), "ERC721: transfer to the zero address");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`\'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, "ERC721: approve to caller");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), "ERC721: invalid token ID");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert("ERC721: transfer to non ERC721Receiver implementer");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``\'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``\'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
{'type': 'FunctionDefinition', 'name': 'ITextResolver.text', 'start_line': 3218, 'end_line': 3221, 'offset_start': 104229, 'offset_end': 104337, 'content': 'function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);', 'contract_name': 'ITextResolver', 'contract_code': '{\n    event TextChanged(\n        bytes32 indexed node,\n        string indexed indexedKey,\n        string key,\n        string value\n    );\n\n    /**\n     * Returns the text data associated with an ENS node and key.\n     * @param node The ENS node to query.\n     * @param key The text data key to query.\n     * @return The associated text data.\n     */\n    function text(\n        bytes32 node,\n        string calldata key\n    ) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x253553366da8546fc250f225fe3d25d0c782303b/0x253553366da8546fc250f225fe3d25d0c782303b.sol'}
