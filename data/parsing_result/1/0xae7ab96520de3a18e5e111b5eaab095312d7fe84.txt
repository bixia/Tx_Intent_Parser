{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 9, 'end_line': 11, 'offset_start': 100, 'offset_end': 188, 'content': 'function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 13, 'end_line': 15, 'offset_start': 195, 'offset_end': 295, 'content': 'function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 17, 'end_line': 19, 'offset_start': 302, 'offset_end': 427, 'content': 'function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 21, 'end_line': 23, 'offset_start': 434, 'offset_end': 534, 'content': 'function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 25, 'end_line': 27, 'offset_start': 541, 'offset_end': 666, 'content': 'function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 29, 'end_line': 31, 'offset_start': 673, 'offset_end': 805, 'content': 'function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 33, 'end_line': 35, 'offset_start': 812, 'offset_end': 960, 'content': 'function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 37, 'end_line': 39, 'offset_start': 967, 'offset_end': 1092, 'content': 'function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 41, 'end_line': 43, 'offset_start': 1099, 'offset_end': 1272, 'content': 'function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 45, 'end_line': 47, 'offset_start': 1279, 'offset_end': 1429, 'content': 'function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 49, 'end_line': 51, 'offset_start': 1436, 'offset_end': 1586, 'content': 'function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 53, 'end_line': 56, 'offset_start': 1593, 'offset_end': 1709, 'content': 'function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 58, 'end_line': 62, 'offset_start': 1716, 'offset_end': 1863, 'content': 'function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 64, 'end_line': 69, 'offset_start': 1870, 'offset_end': 2048, 'content': 'function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 71, 'end_line': 77, 'offset_start': 2055, 'offset_end': 2264, 'content': 'function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLSyntaxSugar.arr', 'start_line': 79, 'end_line': 86, 'offset_start': 2271, 'offset_end': 2511, 'content': 'function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }', 'contract_name': 'ACLSyntaxSugar', 'contract_code': '{\n    function arr() internal pure returns (uint256[]) {\n        return new uint256[](0);\n    }\n\n    function arr(bytes32 _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(bytes32 _a, bytes32 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a) internal pure returns (uint256[] r) {\n        return arr(uint256(_a));\n    }\n\n    function arr(address _a, address _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c);\n    }\n\n    function arr(address _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), _b, _c, _d);\n    }\n\n    function arr(address _a, uint256 _b) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b));\n    }\n\n    function arr(address _a, address _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), _c, _d, _e);\n    }\n\n    function arr(address _a, address _b, address _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(address _a, address _b, uint256 _c) internal pure returns (uint256[] r) {\n        return arr(uint256(_a), uint256(_b), uint256(_c));\n    }\n\n    function arr(uint256 _a) internal pure returns (uint256[] r) {\n        r = new uint256[](1);\n        r[0] = _a;\n    }\n\n    function arr(uint256 _a, uint256 _b) internal pure returns (uint256[] r) {\n        r = new uint256[](2);\n        r[0] = _a;\n        r[1] = _b;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c) internal pure returns (uint256[] r) {\n        r = new uint256[](3);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d) internal pure returns (uint256[] r) {\n        r = new uint256[](4);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n    }\n\n    function arr(uint256 _a, uint256 _b, uint256 _c, uint256 _d, uint256 _e) internal pure returns (uint256[] r) {\n        r = new uint256[](5);\n        r[0] = _a;\n        r[1] = _b;\n        r[2] = _c;\n        r[3] = _d;\n        r[4] = _e;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLHelpers.decodeParamOp', 'start_line': 91, 'end_line': 93, 'offset_start': 2543, 'offset_end': 2654, 'content': 'function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }', 'contract_name': 'ACLHelpers', 'contract_code': '{\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLHelpers.decodeParamId', 'start_line': 95, 'end_line': 97, 'offset_start': 2661, 'offset_end': 2772, 'content': 'function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }', 'contract_name': 'ACLHelpers', 'contract_code': '{\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ACLHelpers.decodeParamsList', 'start_line': 99, 'end_line': 103, 'offset_start': 2779, 'offset_end': 2970, 'content': 'function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }', 'contract_name': 'ACLHelpers', 'contract_code': '{\n    function decodeParamOp(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 30));\n    }\n\n    function decodeParamId(uint256 _x) internal pure returns (uint8 b) {\n        return uint8(_x >> (8 * 31));\n    }\n\n    function decodeParamsList(uint256 _x) internal pure returns (uint32 a, uint32 b, uint32 c) {\n        a = uint32(_x);\n        b = uint32(_x >> (8 * 4));\n        c = uint32(_x >> (8 * 8));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 131, 'end_line': 149, 'offset_start': 4025, 'offset_end': 5364, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n\n        return signer;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`).\n     * This address can then be used for verification purposes.\n     * Receives the `v`, `r` and `s` signature fields separately.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n\n        return signer;\n    }\n\n    /**\n     * @dev Overload of `recover` that receives the `r` and `vs` short-signature fields separately.\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 155, 'end_line': 163, 'offset_start': 5565, 'offset_end': 5893, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`).\n     * This address can then be used for verification purposes.\n     * Receives the `v`, `r` and `s` signature fields separately.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address)\n    {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n  2 + 1, and for v in (282): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n\n        return signer;\n    }\n\n    /**\n     * @dev Overload of `recover` that receives the `r` and `vs` short-signature fields separately.\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return recover(hash, v, r, s);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'TimeHelpers.getBlockNumber', 'start_line': 183, 'end_line': 185, 'offset_start': 6244, 'offset_end': 6337, 'content': 'function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }', 'contract_name': 'TimeHelpers', 'contract_code': '{\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'TimeHelpers.getBlockNumber64', 'start_line': 192, 'end_line': 194, 'offset_start': 6543, 'offset_end': 6652, 'content': 'function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }', 'contract_name': 'TimeHelpers', 'contract_code': '{\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'TimeHelpers.getTimestamp', 'start_line': 201, 'end_line': 203, 'offset_start': 6823, 'offset_end': 6966, 'content': 'function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }', 'contract_name': 'TimeHelpers', 'contract_code': '{\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'TimeHelpers.getTimestamp64', 'start_line': 210, 'end_line': 212, 'offset_start': 7158, 'offset_end': 7263, 'content': 'function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }', 'contract_name': 'TimeHelpers', 'contract_code': '{\n    using Uint256Helpers for uint256;\n\n    /**\n    * @dev Returns the current block number.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n    * @dev Returns the current block number, converted to uint64.\n    *      Using a function rather than `block.number` allows us to easily mock the block number in\n    *      tests.\n    */\n    function getBlockNumber64() internal view returns (uint64) {\n        return getBlockNumber().toUint64();\n    }\n\n    /**\n    * @dev Returns the current timestamp.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp() internal view returns (uint256) {\n        return block.timestamp; // solium-disable-line security/no-block-members\n    }\n\n    /**\n    * @dev Returns the current timestamp, converted to uint64.\n    *      Using a function rather than `block.timestamp` allows us to easily mock it in\n    *      tests.\n    */\n    function getTimestamp64() internal view returns (uint64) {\n        return getTimestamp().toUint64();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEVMScriptExecutor.execScript', 'start_line': 223, 'end_line': 223, 'offset_start': 7373, 'offset_end': 7465, 'content': 'function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);', 'contract_name': 'IEVMScriptExecutor', 'contract_code': '{\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n    function executorType() external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEVMScriptExecutor.executorType', 'start_line': 224, 'end_line': 224, 'offset_start': 7471, 'offset_end': 7526, 'content': 'function executorType() external pure returns (bytes32);', 'contract_name': 'IEVMScriptExecutor', 'contract_code': '{\n    function execScript(bytes script, bytes input, address[] blacklist) external returns (bytes);\n    function executorType() external pure returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.accountingOracle', 'start_line': 265, 'end_line': 265, 'offset_start': 9180, 'offset_end': 9238, 'content': 'function accountingOracle() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.depositSecurityModule', 'start_line': 266, 'end_line': 266, 'offset_start': 9244, 'offset_end': 9307, 'content': 'function depositSecurityModule() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.elRewardsVault', 'start_line': 267, 'end_line': 267, 'offset_start': 9313, 'offset_end': 9369, 'content': 'function elRewardsVault() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.legacyOracle', 'start_line': 268, 'end_line': 268, 'offset_start': 9375, 'offset_end': 9429, 'content': 'function legacyOracle() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.lido', 'start_line': 269, 'end_line': 269, 'offset_start': 9435, 'offset_end': 9481, 'content': 'function lido() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.oracleReportSanityChecker', 'start_line': 270, 'end_line': 270, 'offset_start': 9487, 'offset_end': 9554, 'content': 'function oracleReportSanityChecker() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.burner', 'start_line': 271, 'end_line': 271, 'offset_start': 9560, 'offset_end': 9608, 'content': 'function burner() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.stakingRouter', 'start_line': 272, 'end_line': 272, 'offset_start': 9614, 'offset_end': 9669, 'content': 'function stakingRouter() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.treasury', 'start_line': 273, 'end_line': 273, 'offset_start': 9675, 'offset_end': 9725, 'content': 'function treasury() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.validatorsExitBusOracle', 'start_line': 274, 'end_line': 274, 'offset_start': 9731, 'offset_end': 9796, 'content': 'function validatorsExitBusOracle() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.withdrawalQueue', 'start_line': 275, 'end_line': 275, 'offset_start': 9802, 'offset_end': 9859, 'content': 'function withdrawalQueue() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.withdrawalVault', 'start_line': 276, 'end_line': 276, 'offset_start': 9865, 'offset_end': 9922, 'content': 'function withdrawalVault() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.postTokenRebaseReceiver', 'start_line': 277, 'end_line': 277, 'offset_start': 9928, 'offset_end': 9993, 'content': 'function postTokenRebaseReceiver() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.oracleDaemonConfig', 'start_line': 278, 'end_line': 278, 'offset_start': 9999, 'offset_end': 10059, 'content': 'function oracleDaemonConfig() external view returns(address);', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.coreComponents', 'start_line': 279, 'end_line': 286, 'offset_start': 10065, 'offset_end': 10316, 'content': 'function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoLocator.oracleReportComponentsForLido', 'start_line': 287, 'end_line': 295, 'offset_start': 10322, 'offset_end': 10630, 'content': 'function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );', 'contract_name': 'ILidoLocator', 'contract_code': '{\n    function accountingOracle() external view returns(address);\n    function depositSecurityModule() external view returns(address);\n    function elRewardsVault() external view returns(address);\n    function legacyOracle() external view returns(address);\n    function lido() external view returns(address);\n    function oracleReportSanityChecker() external view returns(address);\n    function burner() external view returns(address);\n    function stakingRouter() external view returns(address);\n    function treasury() external view returns(address);\n    function validatorsExitBusOracle() external view returns(address);\n    function withdrawalQueue() external view returns(address);\n    function withdrawalVault() external view returns(address);\n    function postTokenRebaseReceiver() external view returns(address);\n    function oracleDaemonConfig() external view returns(address);\n    function coreComponents() external view returns(\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address stakingRouter,\n        address treasury,\n        address withdrawalQueue,\n        address withdrawalVault\n    );\n    function oracleReportComponentsForLido() external view returns(\n        address accountingOracle,\n        address elRewardsVault,\n        address oracleReportSanityChecker,\n        address burner,\n        address withdrawalQueue,\n        address withdrawalVault,\n        address postTokenRebaseReceiver\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._whenNotStopped', 'start_line': 316, 'end_line': 318, 'offset_start': 11099, 'offset_end': 11225, 'content': 'function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256("lido.Pausable.activeFlag")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._whenStopped', 'start_line': 320, 'end_line': 322, 'offset_start': 11232, 'offset_end': 11355, 'content': 'function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256("lido.Pausable.activeFlag")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable.isStopped', 'start_line': 324, 'end_line': 326, 'offset_start': 11362, 'offset_end': 11471, 'content': 'function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256("lido.Pausable.activeFlag")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._stop', 'start_line': 328, 'end_line': 333, 'offset_start': 11478, 'offset_end': 11614, 'content': 'function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256("lido.Pausable.activeFlag")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Pausable._resume', 'start_line': 335, 'end_line': 340, 'offset_start': 11621, 'offset_end': 11755, 'content': 'function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }', 'contract_name': 'Pausable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event Stopped();\n    event Resumed();\n\n    // keccak256("lido.Pausable.activeFlag")\n    bytes32 internal constant ACTIVE_FLAG_POSITION =\n        0x644132c4ddd5bb6f0655d5fe2870dcec7870e6be4758890f366b83441f9fdece;\n\n    function _whenNotStopped() internal view {\n        require(ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_STOPPED");\n    }\n\n    function _whenStopped() internal view {\n        require(!ACTIVE_FLAG_POSITION.getStorageBool(), "CONTRACT_IS_ACTIVE");\n    }\n\n    function isStopped() public view returns (bool) {\n        return !ACTIVE_FLAG_POSITION.getStorageBool();\n    }\n\n    function _stop() internal {\n        _whenNotStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(false);\n        emit Stopped();\n    }\n\n    function _resume() internal {\n        _whenStopped();\n\n        ACTIVE_FLAG_POSITION.setStorageBool(true);\n        emit Resumed();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.max', 'start_line': 354, 'end_line': 356, 'offset_start': 12157, 'offset_end': 12260, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.min', 'start_line': 359, 'end_line': 361, 'offset_start': 12317, 'offset_end': 12420, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.max', 'start_line': 364, 'end_line': 366, 'offset_start': 12476, 'offset_end': 12576, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.min', 'start_line': 369, 'end_line': 371, 'offset_start': 12633, 'offset_end': 12733, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.ceilDiv', 'start_line': 377, 'end_line': 380, 'offset_start': 12921, 'offset_end': 13114, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Math256.absDiff', 'start_line': 383, 'end_line': 385, 'offset_start': 13178, 'offset_end': 13293, 'content': 'function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }', 'contract_name': 'Math256', 'contract_code': '{\n    /// @dev Returns the largest of two numbers.\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the largest of two numbers.\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /// @dev Returns the smallest of two numbers.\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /// @dev Returns the ceiling of the division of two numbers.\n    ///\n    /// This differs from standard division with `/` in that it rounds up instead\n    /// of rounding down.\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /// @dev Returns absolute difference of two numbers.\n    function absDiff(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a - b : b - a;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mul', 'start_line': 407, 'end_line': 419, 'offset_start': 13983, 'offset_end': 14430, 'content': "function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }", 'contract_name': 'SafeMath', 'contract_code': '{\n    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 424, 'end_line': 430, 'offset_start': 14549, 'offset_end': 14861, 'content': "function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\n\n        return c;\n    }", 'contract_name': 'SafeMath', 'contract_code': '{\n    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 435, 'end_line': 440, 'offset_start': 14983, 'offset_end': 15154, 'content': 'function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.add', 'start_line': 445, 'end_line': 450, 'offset_start': 15226, 'offset_end': 15395, 'content': 'function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mod', 'start_line': 456, 'end_line': 459, 'offset_start': 15538, 'offset_end': 15674, 'content': 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    string private constant ERROR_ADD_OVERFLOW = "MATH_ADD_OVERFLOW";\n    string private constant ERROR_SUB_UNDERFLOW = "MATH_SUB_UNDERFLOW";\n    string private constant ERROR_MUL_OVERFLOW = "MATH_MUL_OVERFLOW";\n    string private constant ERROR_DIV_ZERO = "MATH_DIV_ZERO";\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n        // benefit is lost if \'b\' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (_a == 0) {\n            return 0;\n        }\n\n        uint256 c = _a * _b;\n        require(c / _a == _b, ERROR_MUL_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b > 0, ERROR_DIV_ZERO); // Solidity only automatically asserts when dividing by 0\n        uint256 c = _a / _b;\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn\'t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        require(_b <= _a, ERROR_SUB_UNDERFLOW);\n        uint256 c = _a - _b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        uint256 c = _a + _b;\n        require(c >= _a, ERROR_ADD_OVERFLOW);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, ERROR_DIV_ZERO);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AragonApp.canPerform', 'start_line': 503, 'end_line': 519, 'offset_start': 17319, 'offset_end': 17814, 'content': 'function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }', 'contract_name': 'AragonApp', 'contract_code': '{\n    string private constant ERROR_AUTH_FAILED = "APP_AUTH_FAILED";\n\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] _params) {\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    /**\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\n    * @param _sender Sender of the call\n    * @param _role Role on this app\n    * @param _params Permission params for the role\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\n    *         Always returns false if the app hasn\'t been initialized yet.\n    */\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }\n\n    /**\n    * @dev Get the recovery vault for the app\n    * @return Recovery vault address for the app\n    */\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AragonApp.getRecoveryVault', 'start_line': 525, 'end_line': 528, 'offset_start': 17931, 'offset_end': 18159, 'content': 'function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }', 'contract_name': 'AragonApp', 'contract_code': '{\n    string private constant ERROR_AUTH_FAILED = "APP_AUTH_FAILED";\n\n    modifier auth(bytes32 _role) {\n        require(canPerform(msg.sender, _role, new uint256[](0)), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    modifier authP(bytes32 _role, uint256[] _params) {\n        require(canPerform(msg.sender, _role, _params), ERROR_AUTH_FAILED);\n        _;\n    }\n\n    /**\n    * @dev Check whether an action can be performed by a sender for a particular role on this app\n    * @param _sender Sender of the call\n    * @param _role Role on this app\n    * @param _params Permission params for the role\n    * @return Boolean indicating whether the sender has the permissions to perform the action.\n    *         Always returns false if the app hasn\'t been initialized yet.\n    */\n    function canPerform(address _sender, bytes32 _role, uint256[] _params) public view returns (bool) {\n        if (!hasInitialized()) {\n            return false;\n        }\n\n        IKernel linkedKernel = kernel();\n        if (address(linkedKernel) == address(0)) {\n            return false;\n        }\n\n        return linkedKernel.hasPermission(\n            _sender,\n            address(this),\n            _role,\n            ConversionHelpers.dangerouslyCastUintArrayToBytes(_params)\n        );\n    }\n\n    /**\n    * @dev Get the recovery vault for the app\n    * @return Recovery vault address for the app\n    */\n    function getRecoveryVault() public view returns (address) {\n        // Funds recovery via a vault is only available when used with a kernel\n        return kernel().getRecoveryVault(); // if kernel is not set, it will revert\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.totalSupply', 'start_line': 541, 'end_line': 541, 'offset_start': 18441, 'offset_end': 18493, 'content': 'function totalSupply() public view returns (uint256);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.balanceOf', 'start_line': 543, 'end_line': 543, 'offset_start': 18500, 'offset_end': 18562, 'content': 'function balanceOf(address _who) public view returns (uint256);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.allowance', 'start_line': 545, 'end_line': 546, 'offset_start': 18569, 'offset_end': 18659, 'content': 'function allowance(address _owner, address _spender)\n        public view returns (uint256);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transfer', 'start_line': 548, 'end_line': 548, 'offset_start': 18666, 'offset_end': 18734, 'content': 'function transfer(address _to, uint256 _value) public returns (bool);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.approve', 'start_line': 550, 'end_line': 551, 'offset_start': 18741, 'offset_end': 18821, 'content': 'function approve(address _spender, uint256 _value)\n        public returns (bool);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC20.transferFrom', 'start_line': 553, 'end_line': 554, 'offset_start': 18828, 'offset_end': 18923, 'content': 'function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);', 'contract_name': 'ERC20', 'contract_code': '{\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender)\n        public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value)\n        public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value)\n        public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC2612.permit', 'start_line': 604, 'end_line': 606, 'offset_start': 20590, 'offset_end': 20724, 'content': 'function permit(\n        address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s\n    ) external;', 'contract_name': 'IERC2612', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     */\n    function permit(\n        address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC2612.nonces', 'start_line': 615, 'end_line': 615, 'offset_start': 21030, 'offset_end': 21092, 'content': 'function nonces(address owner) external view returns (uint256);', 'contract_name': 'IERC2612', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     */\n    function permit(\n        address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC2612.DOMAIN_SEPARATOR', 'start_line': 621, 'end_line': 621, 'offset_start': 21285, 'offset_end': 21344, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32);', 'contract_name': 'IERC2612', 'contract_code': "{\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     */\n    function permit(\n        address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit.permit', 'start_line': 667, 'end_line': 680, 'offset_start': 22764, 'offset_end': 23368, 'content': 'function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit.nonces', 'start_line': 689, 'end_line': 691, 'offset_start': 23674, 'offset_end': 23782, 'content': 'function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit.DOMAIN_SEPARATOR', 'start_line': 697, 'end_line': 699, 'offset_start': 23975, 'offset_end': 24121, 'content': 'function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit.eip712Domain', 'start_line': 711, 'end_line': 718, 'offset_start': 24491, 'offset_end': 24744, 'content': 'function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit._useNonce', 'start_line': 723, 'end_line': 726, 'offset_start': 24838, 'offset_end': 25007, 'content': 'function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit._initializeEIP712StETH', 'start_line': 731, 'end_line': 738, 'offset_start': 25093, 'offset_end': 25419, 'content': 'function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETHPermit.getEIP712StETH', 'start_line': 743, 'end_line': 745, 'offset_start': 25488, 'offset_end': 25608, 'content': 'function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }', 'contract_name': 'StETHPermit', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /**\n     * @dev Service event for initialization\n     */\n    event EIP712StETHInitialized(address eip712StETH);\n\n    /**\n     * @dev Nonces for ERC-2612 (Permit)\n     */\n    mapping(address => uint256) internal noncesByAddress;\n\n    /**\n     * @dev Storage position used for the EIP712 message utils contract\n     *\n     * keccak256("lido.StETHPermit.eip712StETH")\n     */\n    bytes32 internal constant EIP712_STETH_POSITION =\n        0x42b2d95e1ce15ce63bf9a8d9f6312cf44b23415c977ffa3b884333422af8941c;\n\n    /**\n     * @dev Typehash constant for ERC-2612 (Permit)\n     *\n     * keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)")\n     */\n    bytes32 internal constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``\'s tokens,\n     * given ``owner``\'s signed approval.\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``\'s current nonce (see {nonces}).\n     */\n    function permit(\n        address _owner, address _spender, uint256 _value, uint256 _deadline, uint8 _v, bytes32 _r, bytes32 _s\n    ) external {\n        require(block.timestamp <= _deadline, "DEADLINE_EXPIRED");\n\n        bytes32 structHash = keccak256(\n            abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, _useNonce(_owner), _deadline)\n        );\n\n        bytes32 hash = IEIP712StETH(getEIP712StETH()).hashTypedDataV4(address(this), structHash);\n\n        require(SignatureUtils.isValidSignature(_owner, hash, _v, _r, _s), "INVALID_SIGNATURE");\n        _approve(_owner, _spender, _value);\n    }\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``\'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256) {\n        return noncesByAddress[owner];\n    }\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return IEIP712StETH(getEIP712StETH()).domainSeparatorV4(address(this));\n    }\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     *\n     * NB: compairing to the full-fledged ERC-5267 version:\n     * - `salt` and `extensions` are unused\n     * - `flags` is hex"0f" or 01111b\n     *\n     * @dev using shortened returns to reduce a bytecode size\n     */\n    function eip712Domain() external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    ) {\n        return IEIP712StETH(getEIP712StETH()).eip712Domain(address(this));\n    }\n\n    /**\n     * @dev "Consume a nonce": return the current value and increment.\n     */\n    function _useNonce(address _owner) internal returns (uint256 current) {\n        current = noncesByAddress[_owner];\n        noncesByAddress[_owner] = current.add(1);\n    }\n\n    /**\n     * @dev Initialize EIP712 message utils contract for stETH\n     */\n    function _initializeEIP712StETH(address _eip712StETH) internal {\n        require(_eip712StETH != address(0), "ZERO_EIP712STETH");\n        require(getEIP712StETH() == address(0), "EIP712STETH_ALREADY_SET");\n\n        EIP712_STETH_POSITION.setStorageAddress(_eip712StETH);\n\n        emit EIP712StETHInitialized(_eip712StETH);\n    }\n\n    /**\n     * @dev Get EIP712 message utils contract\n     */\n    function getEIP712StETH() public view returns (address) {\n        return EIP712_STETH_POSITION.getStorageAddress();\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IBurner.commitSharesToBurn', 'start_line': 761, 'end_line': 761, 'offset_start': 26038, 'offset_end': 26102, 'content': 'function commitSharesToBurn(uint256 _stETHSharesToBurn) external;', 'contract_name': 'IBurner', 'contract_code': '{\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IBurner.requestBurnShares', 'start_line': 766, 'end_line': 766, 'offset_start': 26152, 'offset_end': 26225, 'content': 'function requestBurnShares(address _from, uint256 _sharesAmount) external;', 'contract_name': 'IBurner', 'contract_code': '{\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IBurner.getSharesRequestedToBurn', 'start_line': 771, 'end_line': 771, 'offset_start': 26330, 'offset_end': 26433, 'content': 'function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);', 'contract_name': 'IBurner', 'contract_code': '{\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IBurner.getCoverSharesBurnt', 'start_line': 776, 'end_line': 776, 'offset_start': 26508, 'offset_end': 26570, 'content': 'function getCoverSharesBurnt() external view returns (uint256);', 'contract_name': 'IBurner', 'contract_code': '{\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IBurner.getNonCoverSharesBurnt', 'start_line': 781, 'end_line': 781, 'offset_start': 26649, 'offset_end': 26714, 'content': 'function getNonCoverSharesBurnt() external view returns (uint256);', 'contract_name': 'IBurner', 'contract_code': '{\n    /**\n     * Commit cover/non-cover burning requests and logs cover/non-cover shares amount just burnt.\n     *\n     * NB: The real burn enactment to be invoked after the call (via internal Lido._burnShares())\n     */\n    function commitSharesToBurn(uint256 _stETHSharesToBurn) external;\n\n    /**\n     * Request burn shares\n     */\n    function requestBurnShares(address _from, uint256 _sharesAmount) external;\n\n    /**\n      * Returns the current amount of shares locked on the contract to be burnt.\n      */\n    function getSharesRequestedToBurn() external view returns (uint256 coverShares, uint256 nonCoverShares);\n\n    /**\n      * Returns the total cover shares ever burnt.\n      */\n    function getCoverSharesBurnt() external view returns (uint256);\n\n    /**\n      * Returns the total non-cover shares ever burnt.\n      */\n    function getNonCoverSharesBurnt() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Uint256Helpers.toUint64', 'start_line': 792, 'end_line': 795, 'offset_start': 26907, 'offset_end': 27055, 'content': 'function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }', 'contract_name': 'Uint256Helpers', 'contract_code': '{\n    uint256 private constant MAX_UINT64 = uint64(-1);\n\n    string private constant ERROR_NUMBER_TOO_BIG = "UINT64_NUMBER_TOO_BIG";\n\n    function toUint64(uint256 a) internal pure returns (uint64) {\n        require(a <= MAX_UINT64, ERROR_NUMBER_TOO_BIG);\n        return uint64(a);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IACL.initialize', 'start_line': 806, 'end_line': 806, 'offset_start': 27151, 'offset_end': 27207, 'content': 'function initialize(address permissionsCreator) external;', 'contract_name': 'IACL', 'contract_code': '{\n    function initialize(address permissionsCreator) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IACL.hasPermission', 'start_line': 810, 'end_line': 810, 'offset_start': 27311, 'offset_end': 27413, 'content': 'function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);', 'contract_name': 'IACL', 'contract_code': '{\n    function initialize(address permissionsCreator) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable.getInitializationBlock', 'start_line': 845, 'end_line': 847, 'offset_start': 28298, 'offset_end': 28434, 'content': 'function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    // keccak256("aragonOS.initializable.initializationBlock")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";\n    string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable.hasInitialized', 'start_line': 852, 'end_line': 855, 'offset_start': 28545, 'offset_end': 28752, 'content': 'function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    // keccak256("aragonOS.initializable.initializationBlock")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";\n    string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable.initialized', 'start_line': 860, 'end_line': 862, 'offset_start': 28864, 'offset_end': 28986, 'content': 'function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    // keccak256("aragonOS.initializable.initializationBlock")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";\n    string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable.initializedAt', 'start_line': 868, 'end_line': 870, 'offset_start': 29168, 'offset_end': 29308, 'content': 'function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    // keccak256("aragonOS.initializable.initializationBlock")\n    bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;\n\n    string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";\n    string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";\n\n    modifier onlyInit {\n        require(getInitializationBlock() == 0, ERROR_ALREADY_INITIALIZED);\n        _;\n    }\n\n    modifier isInitialized {\n        require(hasInitialized(), ERROR_NOT_INITIALIZED);\n        _;\n    }\n\n    /**\n    * @return Block number in which the contract was initialized\n    */\n    function getInitializationBlock() public view returns (uint256) {\n        return INITIALIZATION_BLOCK_POSITION.getStorageUint256();\n    }\n\n    /**\n    * @return Whether the contract has been initialized by the time of the current block\n    */\n    function hasInitialized() public view returns (bool) {\n        uint256 initializationBlock = getInitializationBlock();\n        return initializationBlock != 0 && getBlockNumber() >= initializationBlock;\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization has finished.\n    */\n    function initialized() internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());\n    }\n\n    /**\n    * @dev Function to be called by top level contract after initialization to enable the contract\n    *      at a future block number rather than immediately.\n    */\n    function initializedAt(uint256 _blockNumber) internal onlyInit {\n        INITIALIZATION_BLOCK_POSITION.setStorageUint256(_blockNumber);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.name', 'start_line': 994, 'end_line': 996, 'offset_start': 34246, 'offset_end': 34341, 'content': 'function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.symbol', 'start_line': 1002, 'end_line': 1004, 'offset_start': 34450, 'offset_end': 34529, 'content': 'function symbol() external pure returns (string) {\n        return "stETH";\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.decimals', 'start_line': 1009, 'end_line': 1011, 'offset_start': 34641, 'offset_end': 34716, 'content': 'function decimals() external pure returns (uint8) {\n        return 18;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.totalSupply', 'start_line': 1019, 'end_line': 1021, 'offset_start': 34943, 'offset_end': 35043, 'content': 'function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.getTotalPooledEther', 'start_line': 1028, 'end_line': 1030, 'offset_start': 35237, 'offset_end': 35345, 'content': 'function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.balanceOf', 'start_line': 1038, 'end_line': 1040, 'offset_start': 35586, 'offset_end': 35719, 'content': 'function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.transfer', 'start_line': 1057, 'end_line': 1060, 'offset_start': 36258, 'offset_end': 36416, 'content': 'function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.allowance', 'start_line': 1068, 'end_line': 1070, 'offset_start': 36681, 'offset_end': 36817, 'content': 'function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.approve', 'start_line': 1084, 'end_line': 1087, 'offset_start': 37205, 'offset_end': 37357, 'content': 'function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.transferFrom', 'start_line': 1109, 'end_line': 1113, 'offset_start': 38148, 'offset_end': 38379, 'content': 'function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.increaseAllowance', 'start_line': 1127, 'end_line': 1130, 'offset_start': 38922, 'offset_end': 39130, 'content': 'function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.decreaseAllowance', 'start_line': 1145, 'end_line': 1150, 'offset_start': 39761, 'offset_end': 40111, 'content': 'function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.getTotalShares', 'start_line': 1158, 'end_line': 1160, 'offset_start': 40367, 'offset_end': 40465, 'content': 'function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.sharesOf', 'start_line': 1165, 'end_line': 1167, 'offset_start': 40545, 'offset_end': 40655, 'content': 'function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.getSharesByPooledEth', 'start_line': 1172, 'end_line': 1176, 'offset_start': 40774, 'offset_end': 40964, 'content': 'function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.getPooledEthByShares', 'start_line': 1181, 'end_line': 1185, 'offset_start': 41072, 'offset_end': 41268, 'content': 'function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.transferShares', 'start_line': 1202, 'end_line': 1207, 'offset_start': 41795, 'offset_end': 42138, 'content': 'function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH.transferSharesFrom', 'start_line': 1225, 'end_line': 1233, 'offset_start': 42795, 'offset_end': 43227, 'content': 'function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._getTotalPooledEther', 'start_line': 1240, 'end_line': 1240, 'offset_start': 43483, 'offset_end': 43546, 'content': 'function _getTotalPooledEther() internal view returns (uint256);', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._transfer', 'start_line': 1247, 'end_line': 1251, 'offset_start': 43711, 'offset_end': 44009, 'content': 'function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._approve', 'start_line': 1265, 'end_line': 1271, 'offset_start': 44364, 'offset_end': 44677, 'content': 'function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._spendAllowance', 'start_line': 1281, 'end_line': 1287, 'offset_start': 44959, 'offset_end': 45319, 'content': 'function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._getTotalShares', 'start_line': 1292, 'end_line': 1294, 'offset_start': 45398, 'offset_end': 45521, 'content': 'function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._sharesOf', 'start_line': 1299, 'end_line': 1301, 'offset_start': 45601, 'offset_end': 45709, 'content': 'function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._transferShares', 'start_line': 1313, 'end_line': 1324, 'offset_start': 46080, 'offset_end': 46684, 'content': 'function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._mintShares', 'start_line': 1337, 'end_line': 1351, 'offset_start': 47106, 'offset_end': 48008, 'content': 'function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._burnShares', 'start_line': 1363, 'end_line': 1387, 'offset_start': 48391, 'offset_end': 49722, 'content': 'function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._emitTransferEvents', 'start_line': 1392, 'end_line': 1395, 'offset_start': 49802, 'offset_end': 50021, 'content': 'function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._emitTransferAfterMintingShares', 'start_line': 1400, 'end_line': 1402, 'offset_start': 50151, 'offset_end': 50341, 'content': 'function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StETH._mintInitialShares', 'start_line': 1407, 'end_line': 1410, 'offset_start': 50413, 'offset_end': 50615, 'content': 'function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }', 'contract_name': 'StETH', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n\n    address constant internal INITIAL_TOKEN_HOLDER = 0xdead;\n    uint256 constant internal INFINITE_ALLOWANCE = ~uint256(0);\n\n    /**\n     * @dev StETH balances are dynamic and are calculated based on the accounts\' shares\n     * and the total amount of Ether controlled by the protocol. Account shares aren\'t\n     * normalized, so the contract also stores the sum of all shares to calculate\n     * each account\'s token balance which equals to:\n     *\n     *   shares[account] * _getTotalPooledEther() / _getTotalShares()\n    */\n    mapping (address => uint256) private shares;\n\n    /**\n     * @dev Allowances are nominated in tokens, not token shares.\n     */\n    mapping (address => mapping (address => uint256)) private allowances;\n\n    /**\n     * @dev Storage position used for holding the total amount of shares in existence.\n     *\n     * The Lido protocol is built on top of Aragon and uses the Unstructured Storage pattern\n     * for value types:\n     *\n     * https://blog.openzeppelin.com/upgradeability-using-unstructured-storage\n     * https://blog.8bitzen.com/posts/20-02-2020-understanding-how-solidity-upgradeable-unstructured-proxies-work\n     *\n     * For reference types, conventional storage variables are used since it\'s non-trivial\n     * and error-prone to implement reference-type unstructured storage using Solidity v0.4;\n     * see https://github.com/lidofinance/lido-dao/issues/181#issuecomment-736098834\n     *\n     * keccak256("lido.StETH.totalShares")\n     */\n    bytes32 internal constant TOTAL_SHARES_POSITION =\n        0xe3b4b636e601189b5f4c6742edf2538ac12bb61ed03e6da26949d69838fa447e;\n\n    /**\n      * @notice An executed shares transfer from `sender` to `recipient`.\n      *\n      * @dev emitted in pair with an ERC20-defined `Transfer` event.\n      */\n    event TransferShares(\n        address indexed from,\n        address indexed to,\n        uint256 sharesValue\n    );\n\n    /**\n     * @notice An executed `burnShares` request\n     *\n     * @dev Reports simultaneously burnt shares amount\n     * and corresponding stETH amount.\n     * The stETH amount is calculated twice: before and after the burning incurred rebase.\n     *\n     * @param account holder of the burnt shares\n     * @param preRebaseTokenAmount amount of stETH the burnt shares corresponded to before the burn\n     * @param postRebaseTokenAmount amount of stETH the burnt shares corresponded to after the burn\n     * @param sharesAmount amount of burnt shares\n     */\n    event SharesBurnt(\n        address indexed account,\n        uint256 preRebaseTokenAmount,\n        uint256 postRebaseTokenAmount,\n        uint256 sharesAmount\n    );\n\n    /**\n     * @return the name of the token.\n     */\n    function name() external pure returns (string) {\n        return "Liquid staked Ether 2.0";\n    }\n\n    /**\n     * @return the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() external pure returns (string) {\n        return "stETH";\n    }\n\n    /**\n     * @return the number of decimals for getting user representation of a token amount.\n     */\n    function decimals() external pure returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @return the amount of tokens in existence.\n     *\n     * @dev Always equals to `_getTotalPooledEther()` since token amount\n     * is pegged to the total amount of Ether controlled by the protocol.\n     */\n    function totalSupply() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the entire amount of Ether controlled by the protocol.\n     *\n     * @dev The sum of all ETH balances in the protocol, equals to the total supply of stETH.\n     */\n    function getTotalPooledEther() external view returns (uint256) {\n        return _getTotalPooledEther();\n    }\n\n    /**\n     * @return the amount of tokens owned by the `_account`.\n     *\n     * @dev Balances are dynamic and equal the `_account`\'s share in the amount of the\n     * total Ether controlled by the protocol. See `sharesOf`.\n     */\n    function balanceOf(address _account) external view returns (uint256) {\n        return getPooledEthByShares(_sharesOf(_account));\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from the caller\'s account to the `_recipient` account.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transfer(address _recipient, uint256 _amount) external returns (bool) {\n        _transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @return the remaining number of tokens that `_spender` is allowed to spend\n     * on behalf of `_owner` through `transferFrom`. This is zero by default.\n     *\n     * @dev This value changes when `approve` or `transferFrom` is called.\n     */\n    function allowance(address _owner, address _spender) external view returns (uint256) {\n        return allowances[_owner][_spender];\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the caller\'s tokens.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function approve(address _spender, uint256 _amount) external returns (bool) {\n        _approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient` using the\n     * allowance mechanism. `_amount` is then deducted from the caller\'s\n     * allowance.\n     *\n     * @return a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have a balance of at least `_amount`.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `_amount`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_amount` argument is the amount of tokens, not shares.\n     */\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool) {\n        _spendAllowance(_sender, msg.sender, _amount);\n        _transfer(_sender, _recipient, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the caller by `_addedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the the zero address.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool) {\n        _approve(msg.sender, _spender, allowances[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the caller by `_subtractedValue`.\n     *\n     * This is an alternative to `approve` that can be used as a mitigation for\n     * problems described in:\n     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b709eae01d1da91902d06ace340df6b324e6f049/contracts/token/ERC20/IERC20.sol#L57\n     * Emits an `Approval` event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least `_subtractedValue`.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool) {\n        uint256 currentAllowance = allowances[msg.sender][_spender];\n        require(currentAllowance >= _subtractedValue, "ALLOWANCE_BELOW_ZERO");\n        _approve(msg.sender, _spender, currentAllowance.sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     *\n     * @dev The sum of all accounts\' shares can be an arbitrary number, therefore\n     * it is necessary to store it in order to calculate each account\'s relative share.\n     */\n    function getTotalShares() external view returns (uint256) {\n        return _getTotalShares();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function sharesOf(address _account) external view returns (uint256) {\n        return _sharesOf(_account);\n    }\n\n    /**\n     * @return the amount of shares that corresponds to `_ethAmount` protocol-controlled Ether.\n     */\n    function getSharesByPooledEth(uint256 _ethAmount) public view returns (uint256) {\n        return _ethAmount\n            .mul(_getTotalShares())\n            .div(_getTotalPooledEther());\n    }\n\n    /**\n     * @return the amount of Ether that corresponds to `_sharesAmount` token shares.\n     */\n    function getPooledEthByShares(uint256 _sharesAmount) public view returns (uint256) {\n        return _sharesAmount\n            .mul(_getTotalPooledEther())\n            .div(_getTotalShares());\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the caller\'s account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the caller must have at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferShares(address _recipient, uint256 _sharesAmount) external returns (uint256) {\n        _transferShares(msg.sender, _recipient, _sharesAmount);\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _emitTransferEvents(msg.sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` token shares from the `_sender` account to the `_recipient` account.\n     *\n     * @return amount of transferred tokens.\n     * Emits a `TransferShares` event.\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `_sender` and `_recipient` cannot be the zero addresses.\n     * - `_sender` must have at least `_sharesAmount` shares.\n     * - the caller must have allowance for `_sender`\'s tokens of at least `getPooledEthByShares(_sharesAmount)`.\n     * - the contract must not be paused.\n     *\n     * @dev The `_sharesAmount` argument is the amount of shares, not tokens.\n     */\n    function transferSharesFrom(\n        address _sender, address _recipient, uint256 _sharesAmount\n    ) external returns (uint256) {\n        uint256 tokensAmount = getPooledEthByShares(_sharesAmount);\n        _spendAllowance(_sender, msg.sender, tokensAmount);\n        _transferShares(_sender, _recipient, _sharesAmount);\n        _emitTransferEvents(_sender, _recipient, tokensAmount, _sharesAmount);\n        return tokensAmount;\n    }\n\n    /**\n     * @return the total amount (in wei) of Ether controlled by the protocol.\n     * @dev This is used for calculating tokens from shares and vice versa.\n     * @dev This function is required to be implemented in a derived contract.\n     */\n    function _getTotalPooledEther() internal view returns (uint256);\n\n    /**\n     * @notice Moves `_amount` tokens from `_sender` to `_recipient`.\n     * Emits a `Transfer` event.\n     * Emits a `TransferShares` event.\n     */\n    function _transfer(address _sender, address _recipient, uint256 _amount) internal {\n        uint256 _sharesToTransfer = getSharesByPooledEth(_amount);\n        _transferShares(_sender, _recipient, _sharesToTransfer);\n        _emitTransferEvents(_sender, _recipient, _amount, _sharesToTransfer);\n    }\n\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the `_owner` s tokens.\n     *\n     * Emits an `Approval` event.\n     *\n     * NB: the method can be invoked even if the protocol paused.\n     *\n     * Requirements:\n     *\n     * - `_owner` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     */\n    function _approve(address _owner, address _spender, uint256 _amount) internal {\n        require(_owner != address(0), "APPROVE_FROM_ZERO_ADDR");\n        require(_spender != address(0), "APPROVE_TO_ZERO_ADDR");\n\n        allowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address _owner, address _spender, uint256 _amount) internal {\n        uint256 currentAllowance = allowances[_owner][_spender];\n        if (currentAllowance != INFINITE_ALLOWANCE) {\n            require(currentAllowance >= _amount, "ALLOWANCE_EXCEEDED");\n            _approve(_owner, _spender, currentAllowance - _amount);\n        }\n    }\n\n    /**\n     * @return the total amount of shares in existence.\n     */\n    function _getTotalShares() internal view returns (uint256) {\n        return TOTAL_SHARES_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @return the amount of shares owned by `_account`.\n     */\n    function _sharesOf(address _account) internal view returns (uint256) {\n        return shares[_account];\n    }\n\n    /**\n     * @notice Moves `_sharesAmount` shares from `_sender` to `_recipient`.\n     *\n     * Requirements:\n     *\n     * - `_sender` cannot be the zero address.\n     * - `_recipient` cannot be the zero address or the `stETH` token contract itself\n     * - `_sender` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _transferShares(address _sender, address _recipient, uint256 _sharesAmount) internal {\n        require(_sender != address(0), "TRANSFER_FROM_ZERO_ADDR");\n        require(_recipient != address(0), "TRANSFER_TO_ZERO_ADDR");\n        require(_recipient != address(this), "TRANSFER_TO_STETH_CONTRACT");\n        _whenNotStopped();\n\n        uint256 currentSenderShares = shares[_sender];\n        require(_sharesAmount <= currentSenderShares, "BALANCE_EXCEEDED");\n\n        shares[_sender] = currentSenderShares.sub(_sharesAmount);\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n    }\n\n    /**\n     * @notice Creates `_sharesAmount` shares and assigns them to `_recipient`, increasing the total amount of shares.\n     * @dev This doesn\'t increase the token total supply.\n     *\n     * NB: The method doesn\'t check protocol pause relying on the external enforcement.\n     *\n     * Requirements:\n     *\n     * - `_recipient` cannot be the zero address.\n     * - the contract must not be paused.\n     */\n    function _mintShares(address _recipient, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_recipient != address(0), "MINT_TO_ZERO_ADDR");\n\n        newTotalShares = _getTotalShares().add(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_recipient] = shares[_recipient].add(_sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event from the zero address here since shares mint\n        // works by taking the amount of tokens corresponding to the minted shares from all other\n        // token holders, proportionally to their share. The total supply of the token doesn\'t change\n        // as the result. This is equivalent to performing a send from each other token holder\'s\n        // address to `address`, but we cannot reflect this as it would require sending an unbounded\n        // number of events.\n    }\n\n    /**\n     * @notice Destroys `_sharesAmount` shares from `_account`\'s holdings, decreasing the total amount of shares.\n     * @dev This doesn\'t decrease the token total supply.\n     *\n     * Requirements:\n     *\n     * - `_account` cannot be the zero address.\n     * - `_account` must hold at least `_sharesAmount` shares.\n     * - the contract must not be paused.\n     */\n    function _burnShares(address _account, uint256 _sharesAmount) internal returns (uint256 newTotalShares) {\n        require(_account != address(0), "BURN_FROM_ZERO_ADDR");\n\n        uint256 accountShares = shares[_account];\n        require(_sharesAmount <= accountShares, "BALANCE_EXCEEDED");\n\n        uint256 preRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        newTotalShares = _getTotalShares().sub(_sharesAmount);\n        TOTAL_SHARES_POSITION.setStorageUint256(newTotalShares);\n\n        shares[_account] = accountShares.sub(_sharesAmount);\n\n        uint256 postRebaseTokenAmount = getPooledEthByShares(_sharesAmount);\n\n        emit SharesBurnt(_account, preRebaseTokenAmount, postRebaseTokenAmount, _sharesAmount);\n\n        // Notice: we\'re not emitting a Transfer event to the zero address here since shares burn\n        // works by redistributing the amount of tokens corresponding to the burned shares between\n        // all other token holders. The total supply of the token doesn\'t change as the result.\n        // This is equivalent to performing a send from `address` to each other token holder address,\n        // but we cannot reflect this as it would require sending an unbounded number of events.\n\n        // We\'re emitting `SharesBurnt` event to provide an explicit rebase log record nonetheless.\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events\n     */\n    function _emitTransferEvents(address _from, address _to, uint _tokenAmount, uint256 _sharesAmount) internal {\n        emit Transfer(_from, _to, _tokenAmount);\n        emit TransferShares(_from, _to, _sharesAmount);\n    }\n\n    /**\n     * @dev Emits {Transfer} and {TransferShares} events where `from` is 0 address. Indicates mint events.\n     */\n    function _emitTransferAfterMintingShares(address _to, uint256 _sharesAmount) internal {\n        _emitTransferEvents(address(0), _to, getPooledEthByShares(_sharesAmount), _sharesAmount);\n    }\n\n    /**\n     * @dev Mints shares to INITIAL_TOKEN_HOLDER\n     */\n    function _mintInitialShares(uint256 _sharesAmount) internal {\n        _mintShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n        _emitTransferAfterMintingShares(INITIAL_TOKEN_HOLDER, _sharesAmount);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEIP712StETH.domainSeparatorV4', 'start_line': 1430, 'end_line': 1430, 'offset_start': 51116, 'offset_end': 51190, 'content': 'function domainSeparatorV4(address _stETH) external view returns (bytes32);', 'contract_name': 'IEIP712StETH', 'contract_code': '{\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function domainSeparatorV4(address _stETH) external view returns (bytes32);\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function hashTypedDataV4(address _stETH, bytes32 _structHash) external view returns (bytes32);\n\n    /**\n     * @dev returns the fields and values that describe the domain separator\n     * used by stETH for EIP-712 signature.\n     */\n    function eip712Domain(address _stETH) external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEIP712StETH.hashTypedDataV4', 'start_line': 1447, 'end_line': 1447, 'offset_start': 51815, 'offset_end': 51908, 'content': 'function hashTypedDataV4(address _stETH, bytes32 _structHash) external view returns (bytes32);', 'contract_name': 'IEIP712StETH', 'contract_code': '{\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function domainSeparatorV4(address _stETH) external view returns (bytes32);\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function hashTypedDataV4(address _stETH, bytes32 _structHash) external view returns (bytes32);\n\n    /**\n     * @dev returns the fields and values that describe the domain separator\n     * used by stETH for EIP-712 signature.\n     */\n    function eip712Domain(address _stETH) external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEIP712StETH.eip712Domain', 'start_line': 1453, 'end_line': 1458, 'offset_start': 52052, 'offset_end': 52237, 'content': 'function eip712Domain(address _stETH) external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    );', 'contract_name': 'IEIP712StETH', 'contract_code': '{\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function domainSeparatorV4(address _stETH) external view returns (bytes32);\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256("Mail(address to,string contents)"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function hashTypedDataV4(address _stETH, bytes32 _structHash) external view returns (bytes32);\n\n    /**\n     * @dev returns the fields and values that describe the domain separator\n     * used by stETH for EIP-712 signature.\n     */\n    function eip712Domain(address _stETH) external view returns (\n        string memory name,\n        string memory version,\n        uint256 chainId,\n        address verifyingContract\n    );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.invokeAndCheckSuccess', 'start_line': 1477, 'end_line': 1516, 'offset_start': 53042, 'offset_end': 54383, 'content': "function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don't mark as success\n                default { }\n            }\n        }\n        return ret;\n    }", 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.staticInvoke', 'start_line': 1518, 'end_line': 1542, 'offset_start': 54390, 'offset_end': 55163, 'content': 'function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransfer', 'start_line': 1548, 'end_line': 1555, 'offset_start': 55342, 'offset_end': 55645, 'content': 'function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeTransferFrom', 'start_line': 1561, 'end_line': 1569, 'offset_start': 55828, 'offset_end': 56188, 'content': 'function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.safeApprove', 'start_line': 1575, 'end_line': 1582, 'offset_start': 56366, 'offset_end': 56682, 'content': 'function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.staticBalanceOf', 'start_line': 1588, 'end_line': 1598, 'offset_start': 56820, 'offset_end': 57222, 'content': 'function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.staticAllowance', 'start_line': 1604, 'end_line': 1615, 'offset_start': 57360, 'offset_end': 57798, 'content': 'function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeERC20.staticTotalSupply', 'start_line': 1621, 'end_line': 1628, 'offset_start': 57938, 'offset_end': 58290, 'content': 'function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }', 'contract_name': 'SafeERC20', 'contract_code': '{\n    // Before 0.5, solidity has a mismatch between `address.transfer()` and `token.transfer()`:\n    // https://github.com/ethereum/solidity/issues/3544\n    bytes4 private constant TRANSFER_SELECTOR = 0xa9059cbb;\n\n    string private constant ERROR_TOKEN_BALANCE_REVERTED = "SAFE_ERC_20_BALANCE_REVERTED";\n    string private constant ERROR_TOKEN_ALLOWANCE_REVERTED = "SAFE_ERC_20_ALLOWANCE_REVERTED";\n\n    function invokeAndCheckSuccess(address _addr, bytes memory _calldata)\n        private\n        returns (bool)\n    {\n        bool ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            let success := call(\n                gas,                  // forward all gas\n                _addr,                // address\n                0,                    // no value\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                // Check number of bytes returned from last function call\n                switch returndatasize\n\n                // No bytes returned: assume success\n                case 0 {\n                    ret := 1\n                }\n\n                // 32 bytes returned: check if non-zero\n                case 0x20 {\n                    // Only return success if returned data was true\n                    // Already have output in ptr\n                    ret := eq(mload(ptr), 1)\n                }\n\n                // Not sure what was returned: don\'t mark as success\n                default { }\n            }\n        }\n        return ret;\n    }\n\n    function staticInvoke(address _addr, bytes memory _calldata)\n        private\n        view\n        returns (bool, uint256)\n    {\n        bool success;\n        uint256 ret;\n        assembly {\n            let ptr := mload(0x40)    // free memory pointer\n\n            success := staticcall(\n                gas,                  // forward all gas\n                _addr,                // address\n                add(_calldata, 0x20), // calldata start\n                mload(_calldata),     // calldata length\n                ptr,                  // write output over free memory\n                0x20                  // uint256 return\n            )\n\n            if gt(success, 0) {\n                ret := mload(ptr)\n            }\n        }\n        return (success, ret);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transfer() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransfer(ERC20 _token, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferCallData = abi.encodeWithSelector(\n            TRANSFER_SELECTOR,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.transferFrom() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeTransferFrom(ERC20 _token, address _from, address _to, uint256 _amount) internal returns (bool) {\n        bytes memory transferFromCallData = abi.encodeWithSelector(\n            _token.transferFrom.selector,\n            _from,\n            _to,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, transferFromCallData);\n    }\n\n    /**\n    * @dev Same as a standards-compliant ERC20.approve() that never reverts (returns false).\n    *      Note that this makes an external call to the token.\n    */\n    function safeApprove(ERC20 _token, address _spender, uint256 _amount) internal returns (bool) {\n        bytes memory approveCallData = abi.encodeWithSelector(\n            _token.approve.selector,\n            _spender,\n            _amount\n        );\n        return invokeAndCheckSuccess(_token, approveCallData);\n    }\n\n    /**\n    * @dev Static call into ERC20.balanceOf().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticBalanceOf(ERC20 _token, address _owner) internal view returns (uint256) {\n        bytes memory balanceOfCallData = abi.encodeWithSelector(\n            _token.balanceOf.selector,\n            _owner\n        );\n\n        (bool success, uint256 tokenBalance) = staticInvoke(_token, balanceOfCallData);\n        require(success, ERROR_TOKEN_BALANCE_REVERTED);\n\n        return tokenBalance;\n    }\n\n    /**\n    * @dev Static call into ERC20.allowance().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticAllowance(ERC20 _token, address _owner, address _spender) internal view returns (uint256) {\n        bytes memory allowanceCallData = abi.encodeWithSelector(\n            _token.allowance.selector,\n            _owner,\n            _spender\n        );\n\n        (bool success, uint256 allowance) = staticInvoke(_token, allowanceCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return allowance;\n    }\n\n    /**\n    * @dev Static call into ERC20.totalSupply().\n    * Reverts if the call fails for some reason (should never fail).\n    */\n    function staticTotalSupply(ERC20 _token) internal view returns (uint256) {\n        bytes memory totalSupplyCallData = abi.encodeWithSelector(_token.totalSupply.selector);\n\n        (bool success, uint256 totalSupply) = staticInvoke(_token, totalSupplyCallData);\n        require(success, ERROR_TOKEN_ALLOWANCE_REVERTED);\n\n        return totalSupply;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Petrifiable.isPetrified', 'start_line': 1644, 'end_line': 1646, 'offset_start': 58581, 'offset_end': 58697, 'content': 'function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }', 'contract_name': 'Petrifiable', 'contract_code': "{\n    // Use block UINT256_MAX (which should be never) as the initializable date\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n\n    function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }\n\n    /**\n    * @dev Function to be called by top level contract to prevent being initialized.\n    *      Useful for freezing base contracts when they're used behind proxies.\n    */\n    function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Petrifiable.petrify', 'start_line': 1652, 'end_line': 1654, 'offset_start': 58884, 'offset_end': 58967, 'content': 'function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }', 'contract_name': 'Petrifiable', 'contract_code': "{\n    // Use block UINT256_MAX (which should be never) as the initializable date\n    uint256 internal constant PETRIFIED_BLOCK = uint256(-1);\n\n    function isPetrified() public view returns (bool) {\n        return getInitializationBlock() == PETRIFIED_BLOCK;\n    }\n\n    /**\n    * @dev Function to be called by top level contract to prevent being initialized.\n    *      Useful for freezing base contracts when they're used behind proxies.\n    */\n    function petrify() internal onlyInit {\n        initializedAt(PETRIFIED_BLOCK);\n    }\n}", 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'EVMScriptRunner.getEVMScriptExecutor', 'start_line': 1728, 'end_line': 1730, 'offset_start': 60979, 'offset_end': 61157, 'content': 'function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }', 'contract_name': 'EVMScriptRunner', 'contract_code': '{\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = "EVMRUN_EXECUTOR_UNAVAILABLE";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = "EVMRUN_PROTECTED_STATE_MODIFIED";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = "EVMRUN_EXECUTOR_INVALID_RETURN";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don\'t write output (we\'ll handle this ourselves)\n                0                   // don\'t write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with "EVMRUN_EXECUTOR_INVALID_RETURN"\n                    // See remix: doing a `revert("EVMRUN_EXECUTOR_INVALID_RETURN")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'EVMScriptRunner.getEVMScriptRegistry', 'start_line': 1732, 'end_line': 1735, 'offset_start': 61164, 'offset_end': 61394, 'content': 'function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }', 'contract_name': 'EVMScriptRunner', 'contract_code': '{\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = "EVMRUN_EXECUTOR_UNAVAILABLE";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = "EVMRUN_PROTECTED_STATE_MODIFIED";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = "EVMRUN_EXECUTOR_INVALID_RETURN";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don\'t write output (we\'ll handle this ourselves)\n                0                   // don\'t write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with "EVMRUN_EXECUTOR_INVALID_RETURN"\n                    // See remix: doing a `revert("EVMRUN_EXECUTOR_INVALID_RETURN")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'EVMScriptRunner.runScript', 'start_line': 1737, 'end_line': 1803, 'offset_start': 61401, 'offset_end': 64612, 'content': 'function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don\'t write output (we\'ll handle this ourselves)\n                0                   // don\'t write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with "EVMRUN_EXECUTOR_INVALID_RETURN"\n                    // See remix: doing a `revert("EVMRUN_EXECUTOR_INVALID_RETURN")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }', 'contract_name': 'EVMScriptRunner', 'contract_code': '{\n    string private constant ERROR_EXECUTOR_UNAVAILABLE = "EVMRUN_EXECUTOR_UNAVAILABLE";\n    string private constant ERROR_PROTECTED_STATE_MODIFIED = "EVMRUN_PROTECTED_STATE_MODIFIED";\n\n    /* This is manually crafted in assembly\n    string private constant ERROR_EXECUTOR_INVALID_RETURN = "EVMRUN_EXECUTOR_INVALID_RETURN";\n    */\n\n    event ScriptResult(address indexed executor, bytes script, bytes input, bytes returnData);\n\n    function getEVMScriptExecutor(bytes _script) public view returns (IEVMScriptExecutor) {\n        return IEVMScriptExecutor(getEVMScriptRegistry().getScriptExecutor(_script));\n    }\n\n    function getEVMScriptRegistry() public view returns (IEVMScriptRegistry) {\n        address registryAddr = kernel().getApp(KERNEL_APP_ADDR_NAMESPACE, EVMSCRIPT_REGISTRY_APP_ID);\n        return IEVMScriptRegistry(registryAddr);\n    }\n\n    function runScript(bytes _script, bytes _input, address[] _blacklist)\n        internal\n        isInitialized\n        protectState\n        returns (bytes)\n    {\n        IEVMScriptExecutor executor = getEVMScriptExecutor(_script);\n        require(address(executor) != address(0), ERROR_EXECUTOR_UNAVAILABLE);\n\n        bytes4 sig = executor.execScript.selector;\n        bytes memory data = abi.encodeWithSelector(sig, _script, _input, _blacklist);\n\n        bytes memory output;\n        assembly {\n            let success := delegatecall(\n                gas,                // forward all gas\n                executor,           // address\n                add(data, 0x20),    // calldata start\n                mload(data),        // calldata length\n                0,                  // don\'t write output (we\'ll handle this ourselves)\n                0                   // don\'t write output\n            )\n\n            output := mload(0x40) // free mem ptr get\n\n            switch success\n            case 0 {\n                // If the call errored, forward its full error data\n                returndatacopy(output, 0, returndatasize)\n                revert(output, returndatasize)\n            }\n            default {\n                switch gt(returndatasize, 0x3f)\n                case 0 {\n                    // Need at least 0x40 bytes returned for properly ABI-encoded bytes values,\n                    // revert with "EVMRUN_EXECUTOR_INVALID_RETURN"\n                    // See remix: doing a `revert("EVMRUN_EXECUTOR_INVALID_RETURN")` always results in\n                    // this memory layout\n                    mstore(output, 0x08c379a000000000000000000000000000000000000000000000000000000000)         // error identifier\n                    mstore(add(output, 0x04), 0x0000000000000000000000000000000000000000000000000000000000000020) // starting offset\n                    mstore(add(output, 0x24), 0x000000000000000000000000000000000000000000000000000000000000001e) // reason length\n                    mstore(add(output, 0x44), 0x45564d52554e5f4558454355544f525f494e56414c49445f52455455524e0000) // reason\n\n                    revert(output, 100) // 100 = 4 + 3 * 32 (error identifier + 3 words for the ABI encoded error)\n                }\n                default {\n                    // Copy result\n                    //\n                    // Needs to perform an ABI decode for the expected `bytes` return type of\n                    // `executor.execScript()` as solidity will automatically ABI encode the returned bytes as:\n                    //    [ position of the first dynamic length return value = 0x20 (32 bytes) ]\n                    //    [ output length (32 bytes) ]\n                    //    [ output content (N bytes) ]\n                    //\n                    // Perform the ABI decode by ignoring the first 32 bytes of the return data\n                    let copysize := sub(returndatasize, 0x20)\n                    returndatacopy(output, 0x20, copysize)\n\n                    mstore(0x40, add(output, copysize)) // free mem ptr set\n                }\n            }\n        }\n\n        emit ScriptResult(address(executor), _script, _input, output);\n\n        return output;\n    }\n\n    modifier protectState {\n        address preKernel = address(kernel());\n        bytes32 preAppId = appId();\n        _; // exec\n        require(address(kernel()) == preKernel, ERROR_PROTECTED_STATE_MODIFIED);\n        require(appId() == preAppId, ERROR_PROTECTED_STATE_MODIFIED);\n    }\n}', 'modifiers': [None, None], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'VaultRecoverable.transferToVault', 'start_line': 1839, 'end_line': 1855, 'offset_start': 65740, 'offset_end': 66362, 'content': 'function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }', 'contract_name': 'VaultRecoverable', 'contract_code': '{\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = "RECOVER_DISALLOWED";\n    string private constant ERROR_VAULT_NOT_CONTRACT = "RECOVER_VAULT_NOT_CONTRACT";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = "RECOVER_TOKEN_TRANSFER_FAILED";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'VaultRecoverable.allowRecoverability', 'start_line': 1862, 'end_line': 1864, 'offset_start': 66563, 'offset_end': 66661, 'content': 'function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }', 'contract_name': 'VaultRecoverable', 'contract_code': '{\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = "RECOVER_DISALLOWED";\n    string private constant ERROR_VAULT_NOT_CONTRACT = "RECOVER_VAULT_NOT_CONTRACT";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = "RECOVER_TOKEN_TRANSFER_FAILED";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'VaultRecoverable.getRecoveryVault', 'start_line': 1867, 'end_line': 1867, 'offset_start': 66747, 'offset_end': 66804, 'content': 'function getRecoveryVault() public view returns (address);', 'contract_name': 'VaultRecoverable', 'contract_code': '{\n    using SafeERC20 for ERC20;\n\n    string private constant ERROR_DISALLOWED = "RECOVER_DISALLOWED";\n    string private constant ERROR_VAULT_NOT_CONTRACT = "RECOVER_VAULT_NOT_CONTRACT";\n    string private constant ERROR_TOKEN_TRANSFER_FAILED = "RECOVER_TOKEN_TRANSFER_FAILED";\n\n    /**\n     * @notice Send funds to recovery Vault. This contract should never receive funds,\n     *         but in case it does, this function allows one to recover them.\n     * @param _token Token balance to be sent to recovery vault.\n     */\n    function transferToVault(address _token) external {\n        require(allowRecoverability(_token), ERROR_DISALLOWED);\n        address vault = getRecoveryVault();\n        require(isContract(vault), ERROR_VAULT_NOT_CONTRACT);\n\n        uint256 balance;\n        if (_token == ETH) {\n            balance = address(this).balance;\n            vault.transfer(balance);\n        } else {\n            ERC20 token = ERC20(_token);\n            balance = token.staticBalanceOf(this);\n            require(token.safeTransfer(vault, balance), ERROR_TOKEN_TRANSFER_FAILED);\n        }\n\n        emit RecoverToVault(vault, _token, balance);\n    }\n\n    /**\n    * @dev By default deriving from AragonApp makes it recoverable\n    * @param token Token address that would be recovered\n    * @return bool whether the app allows the recovery\n    */\n    function allowRecoverability(address token) public view returns (bool) {\n        return true;\n    }\n\n    // Cast non-implemented interface to be public so we can use it internally\n    function getRecoveryVault() public view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEVMScriptRegistry.addScriptExecutor', 'start_line': 1888, 'end_line': 1888, 'offset_start': 67245, 'offset_end': 67327, 'content': 'function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);', 'contract_name': 'IEVMScriptRegistry', 'contract_code': '{\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEVMScriptRegistry.disableScriptExecutor', 'start_line': 1889, 'end_line': 1889, 'offset_start': 67333, 'offset_end': 67392, 'content': 'function disableScriptExecutor(uint256 executorId) external;', 'contract_name': 'IEVMScriptRegistry', 'contract_code': '{\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IEVMScriptRegistry.getScriptExecutor', 'start_line': 1893, 'end_line': 1893, 'offset_start': 67496, 'offset_end': 67577, 'content': 'function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);', 'contract_name': 'IEVMScriptRegistry', 'contract_code': '{\n    function addScriptExecutor(IEVMScriptExecutor executor) external returns (uint id);\n    function disableScriptExecutor(uint256 executorId) external;\n\n    // TODO: this should be external\n    // See https://github.com/ethereum/solidity/issues/4832\n    function getScriptExecutor(bytes script) public view returns (IEVMScriptExecutor);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IKernel.acl', 'start_line': 1913, 'end_line': 1913, 'offset_start': 67959, 'offset_end': 68000, 'content': 'function acl() public view returns (IACL);', 'contract_name': 'IKernel', 'contract_code': '{\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IKernel.hasPermission', 'start_line': 1914, 'end_line': 1914, 'offset_start': 68006, 'offset_end': 68108, 'content': 'function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);', 'contract_name': 'IKernel', 'contract_code': '{\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IKernel.setApp', 'start_line': 1916, 'end_line': 1916, 'offset_start': 68115, 'offset_end': 68184, 'content': 'function setApp(bytes32 namespace, bytes32 appId, address app) public;', 'contract_name': 'IKernel', 'contract_code': '{\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IKernel.getApp', 'start_line': 1917, 'end_line': 1917, 'offset_start': 68190, 'offset_end': 68269, 'content': 'function getApp(bytes32 namespace, bytes32 appId) public view returns (address);', 'contract_name': 'IKernel', 'contract_code': '{\n    function acl() public view returns (IACL);\n    function hasPermission(address who, address where, bytes32 what, bytes how) public view returns (bool);\n\n    function setApp(bytes32 namespace, bytes32 appId, address app) public;\n    function getApp(bytes32 namespace, bytes32 appId) public view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUnstructuredStorage.getStorageStakeLimitStruct', 'start_line': 1985, 'end_line': 1992, 'offset_start': 70961, 'offset_end': 71508, 'content': 'function getStorageStakeLimitStruct(bytes32 _position) internal view returns (StakeLimitState.Data memory stakeLimit) {\n        uint256 slotValue = _position.getStorageUint256();\n\n        stakeLimit.prevStakeBlockNumber = uint32(slotValue >> PREV_STAKE_BLOCK_NUMBER_OFFSET);\n        stakeLimit.prevStakeLimit = uint96(slotValue >> PREV_STAKE_LIMIT_OFFSET);\n        stakeLimit.maxStakeLimitGrowthBlocks = uint32(slotValue >> MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET);\n        stakeLimit.maxStakeLimit = uint96(slotValue >> MAX_STAKE_LIMIT_OFFSET);\n    }', 'contract_name': 'StakeLimitUnstructuredStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /// @dev Storage offset for `maxStakeLimit` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_OFFSET = 160;\n    /// @dev Storage offset for `maxStakeLimitGrowthBlocks` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET = 128;\n    /// @dev Storage offset for `prevStakeLimit` (bits)\n    uint256 internal constant PREV_STAKE_LIMIT_OFFSET = 32;\n    /// @dev Storage offset for `prevStakeBlockNumber` (bits)\n    uint256 internal constant PREV_STAKE_BLOCK_NUMBER_OFFSET = 0;\n\n    /**\n    * @dev Read stake limit state from the unstructured storage position\n    * @param _position storage offset\n    */\n    function getStorageStakeLimitStruct(bytes32 _position) internal view returns (StakeLimitState.Data memory stakeLimit) {\n        uint256 slotValue = _position.getStorageUint256();\n\n        stakeLimit.prevStakeBlockNumber = uint32(slotValue >> PREV_STAKE_BLOCK_NUMBER_OFFSET);\n        stakeLimit.prevStakeLimit = uint96(slotValue >> PREV_STAKE_LIMIT_OFFSET);\n        stakeLimit.maxStakeLimitGrowthBlocks = uint32(slotValue >> MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET);\n        stakeLimit.maxStakeLimit = uint96(slotValue >> MAX_STAKE_LIMIT_OFFSET);\n    }\n\n     /**\n    * @dev Write stake limit state to the unstructured storage position\n    * @param _position storage offset\n    * @param _data stake limit state structure instance\n    */\n    function setStorageStakeLimitStruct(bytes32 _position, StakeLimitState.Data memory _data) internal {\n        _position.setStorageUint256(\n            uint256(_data.prevStakeBlockNumber) << PREV_STAKE_BLOCK_NUMBER_OFFSET\n                | uint256(_data.prevStakeLimit) << PREV_STAKE_LIMIT_OFFSET\n                | uint256(_data.maxStakeLimitGrowthBlocks) << MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET\n                | uint256(_data.maxStakeLimit) << MAX_STAKE_LIMIT_OFFSET\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUnstructuredStorage.setStorageStakeLimitStruct', 'start_line': 1999, 'end_line': 2006, 'offset_start': 71697, 'offset_end': 72179, 'content': 'function setStorageStakeLimitStruct(bytes32 _position, StakeLimitState.Data memory _data) internal {\n        _position.setStorageUint256(\n            uint256(_data.prevStakeBlockNumber) << PREV_STAKE_BLOCK_NUMBER_OFFSET\n                | uint256(_data.prevStakeLimit) << PREV_STAKE_LIMIT_OFFSET\n                | uint256(_data.maxStakeLimitGrowthBlocks) << MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET\n                | uint256(_data.maxStakeLimit) << MAX_STAKE_LIMIT_OFFSET\n        );\n    }', 'contract_name': 'StakeLimitUnstructuredStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /// @dev Storage offset for `maxStakeLimit` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_OFFSET = 160;\n    /// @dev Storage offset for `maxStakeLimitGrowthBlocks` (bits)\n    uint256 internal constant MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET = 128;\n    /// @dev Storage offset for `prevStakeLimit` (bits)\n    uint256 internal constant PREV_STAKE_LIMIT_OFFSET = 32;\n    /// @dev Storage offset for `prevStakeBlockNumber` (bits)\n    uint256 internal constant PREV_STAKE_BLOCK_NUMBER_OFFSET = 0;\n\n    /**\n    * @dev Read stake limit state from the unstructured storage position\n    * @param _position storage offset\n    */\n    function getStorageStakeLimitStruct(bytes32 _position) internal view returns (StakeLimitState.Data memory stakeLimit) {\n        uint256 slotValue = _position.getStorageUint256();\n\n        stakeLimit.prevStakeBlockNumber = uint32(slotValue >> PREV_STAKE_BLOCK_NUMBER_OFFSET);\n        stakeLimit.prevStakeLimit = uint96(slotValue >> PREV_STAKE_LIMIT_OFFSET);\n        stakeLimit.maxStakeLimitGrowthBlocks = uint32(slotValue >> MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET);\n        stakeLimit.maxStakeLimit = uint96(slotValue >> MAX_STAKE_LIMIT_OFFSET);\n    }\n\n     /**\n    * @dev Write stake limit state to the unstructured storage position\n    * @param _position storage offset\n    * @param _data stake limit state structure instance\n    */\n    function setStorageStakeLimitStruct(bytes32 _position, StakeLimitState.Data memory _data) internal {\n        _position.setStorageUint256(\n            uint256(_data.prevStakeBlockNumber) << PREV_STAKE_BLOCK_NUMBER_OFFSET\n                | uint256(_data.prevStakeLimit) << PREV_STAKE_LIMIT_OFFSET\n                | uint256(_data.maxStakeLimitGrowthBlocks) << MAX_STAKE_LIMIT_GROWTH_BLOCKS_OFFSET\n                | uint256(_data.maxStakeLimit) << MAX_STAKE_LIMIT_OFFSET\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.calculateCurrentStakeLimit', 'start_line': 2017, 'end_line': 2030, 'offset_start': 72504, 'offset_end': 73081, 'content': 'function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.isStakingPaused', 'start_line': 2035, 'end_line': 2037, 'offset_start': 73146, 'offset_end': 73288, 'content': 'function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.isStakingLimitSet', 'start_line': 2042, 'end_line': 2044, 'offset_start': 73387, 'offset_end': 73524, 'content': 'function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.setStakingLimit', 'start_line': 2053, 'end_line': 2088, 'offset_start': 73880, 'offset_end': 75330, 'content': 'function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.removeStakingLimit', 'start_line': 2095, 'end_line': 2101, 'offset_start': 75546, 'offset_end': 75737, 'content': 'function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.updatePrevStakeLimit', 'start_line': 2109, 'end_line': 2120, 'offset_start': 76034, 'offset_end': 76448, 'content': 'function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils.setStakeLimitPauseState', 'start_line': 2128, 'end_line': 2135, 'offset_start': 76700, 'offset_end': 76962, 'content': 'function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'StakeLimitUtils._constGasMin', 'start_line': 2143, 'end_line': 2149, 'offset_start': 77190, 'offset_end': 77476, 'content': 'function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }', 'contract_name': 'StakeLimitUtils', 'contract_code': '{\n    /**\n    * @notice Calculate stake limit for the current block.\n    * @dev using `_constGasMin` to make gas consumption independent of the current block number\n    */\n    function calculateCurrentStakeLimit(StakeLimitState.Data memory _data) internal view returns(uint256 limit) {\n        uint256 stakeLimitIncPerBlock;\n        if (_data.maxStakeLimitGrowthBlocks != 0) {\n            stakeLimitIncPerBlock = _data.maxStakeLimit / _data.maxStakeLimitGrowthBlocks;\n        }\n\n        uint256 blocksPassed = block.number - _data.prevStakeBlockNumber;\n        uint256 projectedLimit = _data.prevStakeLimit + blocksPassed * stakeLimitIncPerBlock;\n\n        limit = _constGasMin(\n            projectedLimit,\n            _data.maxStakeLimit\n        );\n    }\n\n    /**\n    * @notice check if staking is on pause\n    */\n    function isStakingPaused(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.prevStakeBlockNumber == 0;\n    }\n\n    /**\n    * @notice check if staking limit is set (otherwise staking is unlimited)\n    */\n    function isStakingLimitSet(StakeLimitState.Data memory _data) internal pure returns(bool) {\n        return _data.maxStakeLimit != 0;\n    }\n\n    /**\n    * @notice update stake limit repr with the desired limits\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _maxStakeLimit stake limit max value\n    * @param _stakeLimitIncreasePerBlock stake limit increase (restoration) per block\n    */\n    function setStakingLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _maxStakeLimit,\n        uint256 _stakeLimitIncreasePerBlock\n    ) internal view returns (StakeLimitState.Data memory) {\n        require(_maxStakeLimit != 0, "ZERO_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit <= uint96(-1), "TOO_LARGE_MAX_STAKE_LIMIT");\n        require(_maxStakeLimit >= _stakeLimitIncreasePerBlock, "TOO_LARGE_LIMIT_INCREASE");\n        require(\n            (_stakeLimitIncreasePerBlock == 0)\n            || (_maxStakeLimit / _stakeLimitIncreasePerBlock <= uint32(-1)),\n            "TOO_SMALL_LIMIT_INCREASE"\n        );\n\n        // reset prev stake limit to the new max stake limit if\n        if (\n            // staking was paused or\n            _data.prevStakeBlockNumber == 0 ||\n            // staking was unlimited or\n            _data.maxStakeLimit == 0 ||\n            // new maximum limit value is lower than the value obtained on the previous stake submit\n            _maxStakeLimit < _data.prevStakeLimit\n        ) {\n            _data.prevStakeLimit = uint96(_maxStakeLimit);\n        }\n        _data.maxStakeLimitGrowthBlocks =\n            _stakeLimitIncreasePerBlock != 0 ? uint32(_maxStakeLimit / _stakeLimitIncreasePerBlock) : 0;\n\n        _data.maxStakeLimit = uint96(_maxStakeLimit);\n\n        if (_data.prevStakeBlockNumber != 0) {\n            _data.prevStakeBlockNumber = uint32(block.number);\n        }\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr to remove the limit\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    */\n    function removeStakingLimit(\n        StakeLimitState.Data memory _data\n    ) internal pure returns (StakeLimitState.Data memory) {\n        _data.maxStakeLimit = 0;\n\n        return _data;\n    }\n\n    /**\n    * @notice update stake limit repr after submitting user\'s eth\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _newPrevStakeLimit new value for the `prevStakeLimit` field\n    */\n    function updatePrevStakeLimit(\n        StakeLimitState.Data memory _data,\n        uint256 _newPrevStakeLimit\n    ) internal view returns (StakeLimitState.Data memory) {\n        assert(_newPrevStakeLimit <= uint96(-1));\n        assert(_data.prevStakeBlockNumber != 0);\n\n        _data.prevStakeLimit = uint96(_newPrevStakeLimit);\n        _data.prevStakeBlockNumber = uint32(block.number);\n\n        return _data;\n    }\n\n    /**\n    * @notice set stake limit pause state (on or off)\n    * @dev input `_data` param is mutated and the func returns effectively the same pointer\n    * @param _data stake limit state struct\n    * @param _isPaused pause state flag\n    */\n    function setStakeLimitPauseState(\n        StakeLimitState.Data memory _data,\n        bool _isPaused\n    ) internal view returns (StakeLimitState.Data memory) {\n        _data.prevStakeBlockNumber = uint32(_isPaused ? 0 : block.number);\n\n        return _data;\n    }\n\n    /**\n     * @notice find a minimum of two numbers with a constant gas consumption\n     * @dev doesn\'t use branching logic inside\n     * @param _lhs left hand side value\n     * @param _rhs right hand side value\n     */\n    function _constGasMin(uint256 _lhs, uint256 _rhs) internal pure returns (uint256 min) {\n        uint256 lhsIsLess;\n        assembly {\n            lhsIsLess := lt(_lhs, _rhs) // lhsIsLess = (_lhs < _rhs) ? 1 : 0\n        }\n        min = (_lhs * lhsIsLess) + (_rhs * (1 - lhsIsLess));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.getStorageBool', 'start_line': 2160, 'end_line': 2162, 'offset_start': 77585, 'offset_end': 77712, 'content': 'function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.getStorageAddress', 'start_line': 2164, 'end_line': 2166, 'offset_start': 77719, 'offset_end': 77852, 'content': 'function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.getStorageBytes32', 'start_line': 2168, 'end_line': 2170, 'offset_start': 77859, 'offset_end': 77992, 'content': 'function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.getStorageUint256', 'start_line': 2172, 'end_line': 2174, 'offset_start': 77999, 'offset_end': 78132, 'content': 'function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.setStorageBool', 'start_line': 2176, 'end_line': 2178, 'offset_start': 78139, 'offset_end': 78251, 'content': 'function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.setStorageAddress', 'start_line': 2180, 'end_line': 2182, 'offset_start': 78258, 'offset_end': 78376, 'content': 'function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.setStorageBytes32', 'start_line': 2184, 'end_line': 2186, 'offset_start': 78383, 'offset_end': 78501, 'content': 'function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'UnstructuredStorage.setStorageUint256', 'start_line': 2188, 'end_line': 2190, 'offset_start': 78508, 'offset_end': 78626, 'content': 'function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }', 'contract_name': 'UnstructuredStorage', 'contract_code': '{\n    function getStorageBool(bytes32 position) internal view returns (bool data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageAddress(bytes32 position) internal view returns (address data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageBytes32(bytes32 position) internal view returns (bytes32 data) {\n        assembly { data := sload(position) }\n    }\n\n    function getStorageUint256(bytes32 position) internal view returns (uint256 data) {\n        assembly { data := sload(position) }\n    }\n\n    function setStorageBool(bytes32 position, bool data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageAddress(bytes32 position, address data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageBytes32(bytes32 position, bytes32 data) internal {\n        assembly { sstore(position, data) }\n    }\n\n    function setStorageUint256(bytes32 position, uint256 data) internal {\n        assembly { sstore(position, data) }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Autopetrified.tor', 'start_line': 2203, 'end_line': 2207, 'offset_start': 78774, 'offset_end': 78989, 'content': 'constructor() public {\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n        // This renders them uninitializable (and unusable without a proxy).\n        petrify();\n    }', 'contract_name': 'Autopetrified', 'contract_code': '{\n    constructor() public {\n        // Immediately petrify base (non-proxy) instances of inherited contracts on deploy.\n        // This renders them uninitializable (and unusable without a proxy).\n        petrify();\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IsContract.isContract', 'start_line': 2225, 'end_line': 2233, 'offset_start': 79419, 'offset_end': 79662, 'content': 'function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }', 'contract_name': 'IsContract', 'contract_code': '{\n    /*\n    * NOTE: this should NEVER be used for authentication\n    * (see pitfalls: https://github.com/fergarrui/ethereum-security/tree/master/contracts/extcodesize).\n    *\n    * This is only intended to be used as a sanity check that an address is actually a contract,\n    * RATHER THAN an address not being a contract.\n    */\n    function isContract(address _target) internal view returns (bool) {\n        if (_target == address(0)) {\n            return false;\n        }\n\n        uint256 size;\n        assembly { size := extcodesize(_target) }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Versioned.tor', 'start_line': 2264, 'end_line': 2267, 'offset_start': 80805, 'offset_end': 80991, 'content': "constructor() public {\n        // lock version in the implementation's storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }", 'contract_name': 'Versioned', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event ContractVersionSet(uint256 version);\n\n    /// @dev Storage slot: uint256 version\n    /// Version of the initialized contract storage.\n    /// The version stored in CONTRACT_VERSION_POSITION equals to:\n    /// - 0 right after the deployment, before an initializer is invoked (and only at that moment);\n    /// - N after calling initialize(), where N is the initially deployed contract version;\n    /// - N after upgrading contract by calling finalizeUpgrade_vN().\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6; // keccak256("lido.Versioned.contractVersion");\n\n    uint256 internal constant PETRIFIED_VERSION_MARK = uint256(-1);\n\n    constructor() public {\n        // lock version in the implementation\'s storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }\n\n    /// @notice Returns the current contract version.\n    function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), "UNEXPECTED_CONTRACT_VERSION");\n    }\n\n    function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Versioned.getContractVersion', 'start_line': 2270, 'end_line': 2272, 'offset_start': 81052, 'offset_end': 81180, 'content': 'function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }', 'contract_name': 'Versioned', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event ContractVersionSet(uint256 version);\n\n    /// @dev Storage slot: uint256 version\n    /// Version of the initialized contract storage.\n    /// The version stored in CONTRACT_VERSION_POSITION equals to:\n    /// - 0 right after the deployment, before an initializer is invoked (and only at that moment);\n    /// - N after calling initialize(), where N is the initially deployed contract version;\n    /// - N after upgrading contract by calling finalizeUpgrade_vN().\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6; // keccak256("lido.Versioned.contractVersion");\n\n    uint256 internal constant PETRIFIED_VERSION_MARK = uint256(-1);\n\n    constructor() public {\n        // lock version in the implementation\'s storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }\n\n    /// @notice Returns the current contract version.\n    function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), "UNEXPECTED_CONTRACT_VERSION");\n    }\n\n    function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Versioned._checkContractVersion', 'start_line': 2274, 'end_line': 2276, 'offset_start': 81187, 'offset_end': 81336, 'content': 'function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), "UNEXPECTED_CONTRACT_VERSION");\n    }', 'contract_name': 'Versioned', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event ContractVersionSet(uint256 version);\n\n    /// @dev Storage slot: uint256 version\n    /// Version of the initialized contract storage.\n    /// The version stored in CONTRACT_VERSION_POSITION equals to:\n    /// - 0 right after the deployment, before an initializer is invoked (and only at that moment);\n    /// - N after calling initialize(), where N is the initially deployed contract version;\n    /// - N after upgrading contract by calling finalizeUpgrade_vN().\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6; // keccak256("lido.Versioned.contractVersion");\n\n    uint256 internal constant PETRIFIED_VERSION_MARK = uint256(-1);\n\n    constructor() public {\n        // lock version in the implementation\'s storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }\n\n    /// @notice Returns the current contract version.\n    function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), "UNEXPECTED_CONTRACT_VERSION");\n    }\n\n    function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Versioned._setContractVersion', 'start_line': 2278, 'end_line': 2281, 'offset_start': 81343, 'offset_end': 81508, 'content': 'function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }', 'contract_name': 'Versioned', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    event ContractVersionSet(uint256 version);\n\n    /// @dev Storage slot: uint256 version\n    /// Version of the initialized contract storage.\n    /// The version stored in CONTRACT_VERSION_POSITION equals to:\n    /// - 0 right after the deployment, before an initializer is invoked (and only at that moment);\n    /// - N after calling initialize(), where N is the initially deployed contract version;\n    /// - N after upgrading contract by calling finalizeUpgrade_vN().\n    bytes32 internal constant CONTRACT_VERSION_POSITION =\n        0x4dd0f6662ba1d6b081f08b350f5e9a6a7b15cf586926ba66f753594928fa64a6; // keccak256("lido.Versioned.contractVersion");\n\n    uint256 internal constant PETRIFIED_VERSION_MARK = uint256(-1);\n\n    constructor() public {\n        // lock version in the implementation\'s storage to prevent initialization\n        CONTRACT_VERSION_POSITION.setStorageUint256(PETRIFIED_VERSION_MARK);\n    }\n\n    /// @notice Returns the current contract version.\n    function getContractVersion() public view returns (uint256) {\n        return CONTRACT_VERSION_POSITION.getStorageUint256();\n    }\n\n    function _checkContractVersion(uint256 version) internal view {\n        require(version == getContractVersion(), "UNEXPECTED_CONTRACT_VERSION");\n    }\n\n    function _setContractVersion(uint256 version) internal {\n        CONTRACT_VERSION_POSITION.setStorageUint256(version);\n        emit ContractVersionSet(version);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IPostTokenRebaseReceiver.handlePostTokenRebase', 'start_line': 2304, 'end_line': 2312, 'offset_start': 82032, 'offset_end': 82310, 'content': 'function handlePostTokenRebase(\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        uint256 _preTotalShares,\n        uint256 _preTotalEther,\n        uint256 _postTotalShares,\n        uint256 _postTotalEther,\n        uint256 _sharesMintedAsFees\n    ) external;', 'contract_name': 'IPostTokenRebaseReceiver', 'contract_code': '{\n    function handlePostTokenRebase(\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        uint256 _preTotalShares,\n        uint256 _preTotalEther,\n        uint256 _postTotalShares,\n        uint256 _postTotalEther,\n        uint256 _sharesMintedAsFees\n    ) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IOracleReportSanityChecker.checkAccountingOracleReport', 'start_line': 2316, 'end_line': 2325, 'offset_start': 82358, 'offset_end': 82697, 'content': 'function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;', 'contract_name': 'IOracleReportSanityChecker', 'contract_code': '{\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IOracleReportSanityChecker.smoothenTokenRebase', 'start_line': 2327, 'end_line': 2342, 'offset_start': 82704, 'offset_end': 83239, 'content': 'function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );', 'contract_name': 'IOracleReportSanityChecker', 'contract_code': '{\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IOracleReportSanityChecker.checkWithdrawalQueueOracleReport', 'start_line': 2344, 'end_line': 2347, 'offset_start': 83246, 'offset_end': 83384, 'content': 'function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;', 'contract_name': 'IOracleReportSanityChecker', 'contract_code': '{\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IOracleReportSanityChecker.checkSimulatedShareRate', 'start_line': 2349, 'end_line': 2355, 'offset_start': 83391, 'offset_end': 83646, 'content': 'function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;', 'contract_name': 'IOracleReportSanityChecker', 'contract_code': '{\n    function checkAccountingOracleReport(\n        uint256 _timeElapsed,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _preCLValidators,\n        uint256 _postCLValidators\n    ) external view;\n\n    function smoothenTokenRebase(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _preCLBalance,\n        uint256 _postCLBalance,\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        uint256 _etherToLockForWithdrawals,\n        uint256 _newSharesToBurnForWithdrawals\n    ) external view returns (\n        uint256 withdrawals,\n        uint256 elRewards,\n        uint256 simulatedSharesToBurn,\n        uint256 sharesToBurn\n    );\n\n    function checkWithdrawalQueueOracleReport(\n        uint256 _lastFinalizableRequestId,\n        uint256 _reportTimestamp\n    ) external view;\n\n    function checkSimulatedShareRate(\n        uint256 _postTotalPooledEther,\n        uint256 _postTotalShares,\n        uint256 _etherLockedOnWithdrawalQueue,\n        uint256 _sharesBurntDueToWithdrawals,\n        uint256 _simulatedShareRate\n    ) external view;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ILidoExecutionLayerRewardsVault.withdrawRewards', 'start_line': 2359, 'end_line': 2359, 'offset_start': 83699, 'offset_end': 83777, 'content': 'function withdrawRewards(uint256 _maxAmount) external returns (uint256 amount);', 'contract_name': 'ILidoExecutionLayerRewardsVault', 'contract_code': '{\n    function withdrawRewards(uint256 _maxAmount) external returns (uint256 amount);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalVault.withdrawWithdrawals', 'start_line': 2363, 'end_line': 2363, 'offset_start': 83815, 'offset_end': 83869, 'content': 'function withdrawWithdrawals(uint256 _amount) external;', 'contract_name': 'IWithdrawalVault', 'contract_code': '{\n    function withdrawWithdrawals(uint256 _amount) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.deposit', 'start_line': 2367, 'end_line': 2371, 'offset_start': 83905, 'offset_end': 84042, 'content': 'function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.getStakingRewardsDistribution', 'start_line': 2373, 'end_line': 2382, 'offset_start': 84049, 'offset_end': 84347, 'content': 'function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.getWithdrawalCredentials', 'start_line': 2384, 'end_line': 2384, 'offset_start': 84354, 'offset_end': 84421, 'content': 'function getWithdrawalCredentials() external view returns (bytes32);', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.reportRewardsMinted', 'start_line': 2386, 'end_line': 2386, 'offset_start': 84428, 'offset_end': 84518, 'content': 'function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.getTotalFeeE4Precision', 'start_line': 2388, 'end_line': 2388, 'offset_start': 84525, 'offset_end': 84598, 'content': 'function getTotalFeeE4Precision() external view returns (uint16 totalFee);', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.getStakingFeeAggregateDistributionE4Precision', 'start_line': 2390, 'end_line': 2392, 'offset_start': 84605, 'offset_end': 84737, 'content': 'function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.getStakingModuleMaxDepositsCount', 'start_line': 2394, 'end_line': 2397, 'offset_start': 84744, 'offset_end': 84894, 'content': 'function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IStakingRouter.TOTAL_BASIS_POINTS', 'start_line': 2399, 'end_line': 2399, 'offset_start': 84901, 'offset_end': 84962, 'content': 'function TOTAL_BASIS_POINTS() external view returns (uint256);', 'contract_name': 'IStakingRouter', 'contract_code': '{\n    function deposit(\n        uint256 _depositsCount,\n        uint256 _stakingModuleId,\n        bytes _depositCalldata\n    ) external payable;\n\n    function getStakingRewardsDistribution()\n        external\n        view\n        returns (\n            address[] memory recipients,\n            uint256[] memory stakingModuleIds,\n            uint96[] memory stakingModuleFees,\n            uint96 totalFee,\n            uint256 precisionPoints\n        );\n\n    function getWithdrawalCredentials() external view returns (bytes32);\n\n    function reportRewardsMinted(uint256[] _stakingModuleIds, uint256[] _totalShares) external;\n\n    function getTotalFeeE4Precision() external view returns (uint16 totalFee);\n\n    function getStakingFeeAggregateDistributionE4Precision() external view returns (\n        uint16 modulesFee, uint16 treasuryFee\n    );\n\n    function getStakingModuleMaxDepositsCount(uint256 _stakingModuleId, uint256 _maxDepositsValue)\n        external\n        view\n        returns (uint256);\n\n    function TOTAL_BASIS_POINTS() external view returns (uint256);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalQueue.prefinalize', 'start_line': 2403, 'end_line': 2406, 'offset_start': 85000, 'offset_end': 85151, 'content': 'function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);', 'contract_name': 'IWithdrawalQueue', 'contract_code': '{\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalQueue.finalize', 'start_line': 2408, 'end_line': 2408, 'offset_start': 85158, 'offset_end': 85242, 'content': 'function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;', 'contract_name': 'IWithdrawalQueue', 'contract_code': '{\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalQueue.isPaused', 'start_line': 2410, 'end_line': 2410, 'offset_start': 85249, 'offset_end': 85297, 'content': 'function isPaused() external view returns (bool);', 'contract_name': 'IWithdrawalQueue', 'contract_code': '{\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalQueue.unfinalizedStETH', 'start_line': 2412, 'end_line': 2412, 'offset_start': 85304, 'offset_end': 85363, 'content': 'function unfinalizedStETH() external view returns (uint256);', 'contract_name': 'IWithdrawalQueue', 'contract_code': '{\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IWithdrawalQueue.isBunkerModeActive', 'start_line': 2414, 'end_line': 2414, 'offset_start': 85370, 'offset_end': 85428, 'content': 'function isBunkerModeActive() external view returns (bool);', 'contract_name': 'IWithdrawalQueue', 'contract_code': '{\n    function prefinalize(uint256[] _batches, uint256 _maxShareRate)\n        external\n        view\n        returns (uint256 ethToLock, uint256 sharesToBurn);\n\n    function finalize(uint256 _lastIdToFinalize, uint256 _maxShareRate) external payable;\n\n    function isPaused() external view returns (bool);\n\n    function unfinalizedStETH() external view returns (uint256);\n\n    function isBunkerModeActive() external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.initialize', 'start_line': 2549, 'end_line': 2557, 'offset_start': 92048, 'offset_end': 92280, 'content': 'function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._initialize_v2', 'start_line': 2562, 'end_line': 2577, 'offset_start': 92347, 'offset_end': 92897, 'content': "function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }", 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.finalizeUpgrade_v2', 'start_line': 2587, 'end_line': 2597, 'offset_start': 93277, 'offset_end': 93735, 'content': 'function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.pauseStaking', 'start_line': 2607, 'end_line': 2611, 'offset_start': 94011, 'offset_end': 94111, 'content': 'function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.resumeStaking', 'start_line': 2622, 'end_line': 2627, 'offset_start': 94509, 'offset_end': 94667, 'content': 'function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.setStakingLimit', 'start_line': 2651, 'end_line': 2659, 'offset_start': 95583, 'offset_end': 95993, 'content': 'function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.removeStakingLimit', 'start_line': 2666, 'end_line': 2672, 'offset_start': 96110, 'offset_end': 96363, 'content': 'function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.isStakingPaused', 'start_line': 2677, 'end_line': 2679, 'offset_start': 96449, 'offset_end': 96597, 'content': 'function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getCurrentStakeLimit', 'start_line': 2688, 'end_line': 2690, 'offset_start': 96831, 'offset_end': 96992, 'content': 'function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getStakeLimitFullInfo', 'start_line': 2703, 'end_line': 2727, 'offset_start': 97701, 'offset_end': 98626, 'content': 'function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.', 'start_line': 2737, 'end_line': 2741, 'offset_start': 99078, 'offset_end': 99275, 'content': 'function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.submit', 'start_line': 2748, 'end_line': 2750, 'offset_start': 99516, 'offset_end': 99627, 'content': 'function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.receiveELRewards', 'start_line': 2757, 'end_line': 2763, 'offset_start': 99897, 'offset_end': 100167, 'content': 'function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.receiveWithdrawals', 'start_line': 2770, 'end_line': 2774, 'offset_start': 100422, 'offset_end': 100588, 'content': 'function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.stop', 'start_line': 2779, 'end_line': 2784, 'offset_start': 100655, 'offset_end': 100756, 'content': 'function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.resume', 'start_line': 2790, 'end_line': 2795, 'offset_start': 100913, 'offset_end': 101020, 'content': 'function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.handleOracleReport', 'start_line': 2855, 'end_line': 2885, 'offset_start': 104042, 'offset_end': 105027, 'content': 'function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.unsafeChangeDepositedValidators', 'start_line': 2896, 'end_line': 2902, 'offset_start': 105390, 'offset_end': 105685, 'content': 'function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.transferToVault', 'start_line': 2907, 'end_line': 2909, 'offset_start': 105783, 'offset_end': 105878, 'content': 'function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getBufferedEther', 'start_line': 2917, 'end_line': 2919, 'offset_start': 106209, 'offset_end': 106311, 'content': 'function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getTotalELRewardsCollected', 'start_line': 2927, 'end_line': 2929, 'offset_start': 106668, 'offset_end': 106814, 'content': 'function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getLidoLocator', 'start_line': 2935, 'end_line': 2937, 'offset_start': 106925, 'offset_end': 107064, 'content': 'function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getBeaconStat', 'start_line': 2947, 'end_line': 2951, 'offset_start': 107596, 'offset_end': 107945, 'content': 'function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.canDeposit', 'start_line': 2957, 'end_line': 2959, 'offset_start': 108114, 'offset_end': 108242, 'content': 'function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getDepositableEther', 'start_line': 2965, 'end_line': 2969, 'offset_start': 108383, 'offset_end': 108668, 'content': 'function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.deposit', 'start_line': 2977, 'end_line': 3006, 'offset_start': 108957, 'offset_end': 110620, 'content': 'function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getWithdrawalCredentials', 'start_line': 3014, 'end_line': 3016, 'offset_start': 110833, 'offset_end': 110967, 'content': 'function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getOracle', 'start_line': 3022, 'end_line': 3024, 'offset_start': 111097, 'offset_end': 111204, 'content': 'function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getTreasury', 'start_line': 3030, 'end_line': 3032, 'offset_start': 111322, 'offset_end': 111411, 'content': 'function getTreasury() external view returns (address) {\n        return _treasury();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getFee', 'start_line': 3041, 'end_line': 3043, 'offset_start': 111834, 'offset_end': 111960, 'content': 'function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido.getFeeDistribution', 'start_line': 3057, 'end_line': 3074, 'offset_start': 112867, 'offset_end': 113707, 'content': 'function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._processClStateUpdate', 'start_line': 3086, 'end_line': 3110, 'offset_start': 114147, 'offset_end': 115310, 'content': 'function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._collectRewardsAndProcessWithdrawals', 'start_line': 3115, 'end_line': 3148, 'offset_start': 115427, 'offset_end': 116962, 'content': 'function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._calculateWithdrawals', 'start_line': 3154, 'end_line': 3173, 'offset_start': 117112, 'offset_end': 117962, 'content': 'function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._processRewards', 'start_line': 3178, 'end_line': 3198, 'offset_start': 118047, 'offset_end': 119067, 'content': 'function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._submit', 'start_line': 3205, 'end_line': 3230, 'offset_start': 119266, 'offset_end': 120382, 'content': 'function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._getStakingRewardsDistribution', 'start_line': 3249, 'end_line': 3265, 'offset_start': 120868, 'offset_end': 121447, 'content': 'function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._distributeFee', 'start_line': 3273, 'end_line': 3336, 'offset_start': 121871, 'offset_end': 124981, 'content': "function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }", 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._transferModuleRewards', 'start_line': 3338, 'end_line': 3355, 'offset_start': 124988, 'offset_end': 125791, 'content': 'function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._transferTreasuryRewards', 'start_line': 3357, 'end_line': 3361, 'offset_start': 125798, 'offset_end': 126044, 'content': 'function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._getBufferedEther', 'start_line': 3366, 'end_line': 3368, 'offset_start': 126148, 'offset_end': 126275, 'content': 'function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._setBufferedEther', 'start_line': 3370, 'end_line': 3372, 'offset_start': 126282, 'offset_end': 126421, 'content': 'function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._getTransientBalance', 'start_line': 3377, 'end_line': 3383, 'offset_start': 126690, 'offset_end': 127111, 'content': 'function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._getTotalPooledEther', 'start_line': 3389, 'end_line': 3393, 'offset_start': 127238, 'offset_end': 127443, 'content': 'function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._pauseStaking', 'start_line': 3395, 'end_line': 3401, 'offset_start': 127450, 'offset_end': 127685, 'content': 'function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._resumeStaking', 'start_line': 3403, 'end_line': 3409, 'offset_start': 127692, 'offset_end': 127930, 'content': 'function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._getCurrentStakeLimit', 'start_line': 3411, 'end_line': 3420, 'offset_start': 127937, 'offset_end': 128288, 'content': 'function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._auth', 'start_line': 3426, 'end_line': 3428, 'offset_start': 128411, 'offset_end': 128546, 'content': 'function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._handleOracleReport', 'start_line': 3463, 'end_line': 3582, 'offset_start': 130070, 'offset_end': 134930, 'content': 'function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._checkAccountingOracleReport', 'start_line': 3588, 'end_line': 3603, 'offset_start': 135084, 'offset_end': 135762, 'content': 'function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._completeTokenRebase', 'start_line': 3609, 'end_line': 3638, 'offset_start': 135896, 'offset_end': 137041, 'content': 'function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._loadOracleReportContracts', 'start_line': 3643, 'end_line': 3653, 'offset_start': 137137, 'offset_end': 137549, 'content': 'function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._stakingRouter', 'start_line': 3655, 'end_line': 3657, 'offset_start': 137556, 'offset_end': 137692, 'content': 'function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._withdrawalQueue', 'start_line': 3659, 'end_line': 3661, 'offset_start': 137699, 'offset_end': 137843, 'content': 'function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._treasury', 'start_line': 3663, 'end_line': 3665, 'offset_start': 137850, 'offset_end': 137953, 'content': 'function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }', 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'Lido._bootstrapInitialHolder', 'start_line': 3678, 'end_line': 3690, 'offset_start': 138349, 'offset_end': 138900, 'content': "function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract's balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }", 'contract_name': 'Lido', 'contract_code': '{\n    using SafeMath for uint256;\n    using UnstructuredStorage for bytes32;\n    using StakeLimitUnstructuredStorage for bytes32;\n    using StakeLimitUtils for StakeLimitState.Data;\n\n    /// ACL\n    bytes32 public constant PAUSE_ROLE =\n        0x139c2898040ef16910dc9f44dc697df79363da767d8bc92f2e310312b816e46d; // keccak256("PAUSE_ROLE");\n    bytes32 public constant RESUME_ROLE =\n        0x2fc10cc8ae19568712f7a176fb4978616a610650813c9d05326c34abb62749c7; // keccak256("RESUME_ROLE");\n    bytes32 public constant STAKING_PAUSE_ROLE =\n        0x84ea57490227bc2be925c684e2a367071d69890b629590198f4125a018eb1de8; // keccak256("STAKING_PAUSE_ROLE")\n    bytes32 public constant STAKING_CONTROL_ROLE =\n        0xa42eee1333c0758ba72be38e728b6dadb32ea767de5b4ddbaea1dae85b1b051f; // keccak256("STAKING_CONTROL_ROLE")\n    bytes32 public constant UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE =\n        0xe6dc5d79630c61871e99d341ad72c5a052bed2fc8c79e5a4480a7cd31117576c; // keccak256("UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE")\n\n    uint256 private constant DEPOSIT_SIZE = 32 ether;\n\n    /// @dev storage slot position for the Lido protocol contracts locator\n    bytes32 internal constant LIDO_LOCATOR_POSITION =\n        0x9ef78dff90f100ea94042bd00ccb978430524befc391d3e510b5f55ff3166df7; // keccak256("lido.Lido.lidoLocator")\n    /// @dev storage slot position of the staking rate limit structure\n    bytes32 internal constant STAKING_STATE_POSITION =\n        0xa3678de4a579be090bed1177e0a24f77cc29d181ac22fd7688aca344d8938015; // keccak256("lido.Lido.stakeLimit");\n    /// @dev amount of Ether (on the current Ethereum side) buffered on this smart contract balance\n    bytes32 internal constant BUFFERED_ETHER_POSITION =\n        0xed310af23f61f96daefbcd140b306c0bdbf8c178398299741687b90e794772b0; // keccak256("lido.Lido.bufferedEther");\n    /// @dev number of deposited validators (incrementing counter of deposit operations).\n    bytes32 internal constant DEPOSITED_VALIDATORS_POSITION =\n        0xe6e35175eb53fc006520a2a9c3e9711a7c00de6ff2c32dd31df8c5a24cac1b5c; // keccak256("lido.Lido.depositedValidators");\n    /// @dev total amount of ether on Consensus Layer (sum of all the balances of Lido validators)\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_BALANCE_POSITION =\n        0xa66d35f054e68143c18f32c990ed5cb972bb68a68f500cd2dd3a16bbf3686483; // keccak256("lido.Lido.beaconBalance");\n    /// @dev number of Lido\'s validators available in the Consensus Layer state\n    // "beacon" in the `keccak256()` parameter is staying here for compatibility reason\n    bytes32 internal constant CL_VALIDATORS_POSITION =\n        0x9f70001d82b6ef54e9d3725b46581c3eb9ee3aa02b941b6aa54d678a9ca35b10; // keccak256("lido.Lido.beaconValidators");\n    /// @dev Just a counter of total amount of execution layer rewards received by Lido contract. Not used in the logic.\n    bytes32 internal constant TOTAL_EL_REWARDS_COLLECTED_POSITION =\n        0xafe016039542d12eec0183bb0b1ffc2ca45b027126a494672fba4154ee77facb; // keccak256("lido.Lido.totalELRewardsCollected");\n\n    // Staking was paused (don\'t accept user\'s ether submits)\n    event StakingPaused();\n    // Staking was resumed (accept user\'s ether submits)\n    event StakingResumed();\n    // Staking limit was set (rate limits user\'s submits)\n    event StakingLimitSet(uint256 maxStakeLimit, uint256 stakeLimitIncreasePerBlock);\n    // Staking limit was removed\n    event StakingLimitRemoved();\n\n    // Emits when validators number delivered by the oracle\n    event CLValidatorsUpdated(\n        uint256 indexed reportTimestamp,\n        uint256 preCLValidators,\n        uint256 postCLValidators\n    );\n\n    // Emits when var at `DEPOSITED_VALIDATORS_POSITION` changed\n    event DepositedValidatorsChanged(\n        uint256 depositedValidators\n    );\n\n    // Emits when oracle accounting report processed\n    event ETHDistributed(\n        uint256 indexed reportTimestamp,\n        uint256 preCLBalance,\n        uint256 postCLBalance,\n        uint256 withdrawalsWithdrawn,\n        uint256 executionLayerRewardsWithdrawn,\n        uint256 postBufferedEther\n    );\n\n    // Emits when token rebased (total supply and/or total shares were changed)\n    event TokenRebased(\n        uint256 indexed reportTimestamp,\n        uint256 timeElapsed,\n        uint256 preTotalShares,\n        uint256 preTotalEther,\n        uint256 postTotalShares,\n        uint256 postTotalEther,\n        uint256 sharesMintedAsFees\n    );\n\n    // Lido locator set\n    event LidoLocatorSet(address lidoLocator);\n\n    // The amount of ETH withdrawn from LidoExecutionLayerRewardsVault to Lido\n    event ELRewardsReceived(uint256 amount);\n\n    // The amount of ETH withdrawn from WithdrawalVault to Lido\n    event WithdrawalsReceived(uint256 amount);\n\n    // Records a deposit made by a user\n    event Submitted(address indexed sender, uint256 amount, address referral);\n\n    // The `amount` of ether was sent to the deposit_contract.deposit function\n    event Unbuffered(uint256 amount);\n\n    /**\n    * @dev As AragonApp, Lido contract must be initialized with following variables:\n    *      NB: by default, staking and the whole Lido pool are in paused state\n    *\n    * The contract\'s balance must be non-zero to allow initial holder bootstrap.\n    *\n    * @param _lidoLocator lido locator contract\n    * @param _eip712StETH eip712 helper contract for StETH\n    */\n    function initialize(address _lidoLocator, address _eip712StETH)\n        public\n        payable\n        onlyInit\n    {\n        _bootstrapInitialHolder();\n        _initialize_v2(_lidoLocator, _eip712StETH);\n        initialized();\n    }\n\n    /**\n     * initializer for the Lido version "2"\n     */\n    function _initialize_v2(address _lidoLocator, address _eip712StETH) internal {\n        _setContractVersion(2);\n\n        LIDO_LOCATOR_POSITION.setStorageAddress(_lidoLocator);\n        _initializeEIP712StETH(_eip712StETH);\n\n        // set infinite allowance for burner from withdrawal queue\n        // to burn finalized requests\' shares\n        _approve(\n            ILidoLocator(_lidoLocator).withdrawalQueue(),\n            ILidoLocator(_lidoLocator).burner(),\n            INFINITE_ALLOWANCE\n        );\n\n        emit LidoLocatorSet(_lidoLocator);\n    }\n\n    /**\n     * @notice A function to finalize upgrade to v2 (from v1). Can be called only once\n     * @dev Value "1" in CONTRACT_VERSION_POSITION is skipped due to change in numbering\n     *\n     * The initial protocol token holder must exist.\n     *\n     * For more details see https://github.com/lidofinance/lido-improvement-proposals/blob/develop/LIPS/lip-10.md\n     */\n    function finalizeUpgrade_v2(address _lidoLocator, address _eip712StETH) external {\n        _checkContractVersion(0);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        require(_lidoLocator != address(0), "LIDO_LOCATOR_ZERO_ADDRESS");\n        require(_eip712StETH != address(0), "EIP712_STETH_ZERO_ADDRESS");\n\n        require(_sharesOf(INITIAL_TOKEN_HOLDER) != 0, "INITIAL_HOLDER_EXISTS");\n\n        _initialize_v2(_lidoLocator, _eip712StETH);\n    }\n\n    /**\n     * @notice Stops accepting new Ether to the protocol\n     *\n     * @dev While accepting new Ether is stopped, calls to the `submit` function,\n     * as well as to the default payable function, will revert.\n     *\n     * Emits `StakingPaused` event.\n     */\n    function pauseStaking() external {\n        _auth(STAKING_PAUSE_ROLE);\n\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resumes accepting new Ether to the protocol (if `pauseStaking` was called previously)\n     * NB: Staking could be rate-limited by imposing a limit on the stake amount\n     * at each moment in time, see `setStakingLimit()` and `removeStakingLimit()`\n     *\n     * @dev Preserves staking limit if it was set previously\n     *\n     * Emits `StakingResumed` event\n     */\n    function resumeStaking() external {\n        _auth(STAKING_CONTROL_ROLE);\n        require(hasInitialized(), "NOT_INITIALIZED");\n\n        _resumeStaking();\n    }\n\n    /**\n     * @notice Sets the staking rate limit\n     *\n     *  Stake limit\n     * .....  .....   ........ ...            ....     ... Stake limit = max\n     *       .       .        .   .   .      .    . . .\n     *      .       .              . .  . . .      . .\n     *             .                .  . . .\n     * > Time\n     *      ^      ^          ^   ^^^  ^ ^ ^     ^^^ ^     Stake events\n     *\n     * @dev Reverts if:\n     * - `_maxStakeLimit` == 0\n     * - `_maxStakeLimit` >= 2^96\n     * - `_maxStakeLimit` < `_stakeLimitIncreasePerBlock`\n     * - `_maxStakeLimit` / `_stakeLimitIncreasePerBlock` >= 2^32 (only if `_stakeLimitIncreasePerBlock` != 0)\n     *\n     * Emits `StakingLimitSet` event\n     *\n     * @param _maxStakeLimit max stake limit value\n     * @param _stakeLimitIncreasePerBlock stake limit increase per single block\n     */\n    function setStakingLimit(uint256 _maxStakeLimit, uint256 _stakeLimitIncreasePerBlock) external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakingLimit(_maxStakeLimit, _stakeLimitIncreasePerBlock)\n        );\n\n        emit StakingLimitSet(_maxStakeLimit, _stakeLimitIncreasePerBlock);\n    }\n\n    /**\n     * @notice Removes the staking rate limit\n     *\n     * Emits `StakingLimitRemoved` event\n     */\n    function removeStakingLimit() external {\n        _auth(STAKING_CONTROL_ROLE);\n\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(STAKING_STATE_POSITION.getStorageStakeLimitStruct().removeStakingLimit());\n\n        emit StakingLimitRemoved();\n    }\n\n    /**\n     * @notice Check staking state: whether it\'s paused or not\n     */\n    function isStakingPaused() external view returns (bool) {\n        return STAKING_STATE_POSITION.getStorageStakeLimitStruct().isStakingPaused();\n    }\n\n\n    /**\n     * @notice Returns how much Ether can be staked in the current block\n     * @dev Special return values:\n     * - 2^256 - 1 if staking is unlimited;\n     * - 0 if staking is paused or if limit is exhausted.\n     */\n    function getCurrentStakeLimit() external view returns (uint256) {\n        return _getCurrentStakeLimit(STAKING_STATE_POSITION.getStorageStakeLimitStruct());\n    }\n\n    /**\n     * @notice Returns full info about current stake limit params and state\n     * @dev Might be used for the advanced integration requests.\n     * @return isStakingPaused staking pause state (equivalent to return of isStakingPaused())\n     * @return isStakingLimitSet whether the stake limit is set\n     * @return currentStakeLimit current stake limit (equivalent to return of getCurrentStakeLimit())\n     * @return maxStakeLimit max stake limit\n     * @return maxStakeLimitGrowthBlocks blocks needed to restore max stake limit from the fully exhausted state\n     * @return prevStakeLimit previously reached stake limit\n     * @return prevStakeBlockNumber previously seen block number\n     */\n    function getStakeLimitFullInfo()\n        external\n        view\n        returns (\n            bool isStakingPaused,\n            bool isStakingLimitSet,\n            uint256 currentStakeLimit,\n            uint256 maxStakeLimit,\n            uint256 maxStakeLimitGrowthBlocks,\n            uint256 prevStakeLimit,\n            uint256 prevStakeBlockNumber\n        )\n    {\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n\n        isStakingPaused = stakeLimitData.isStakingPaused();\n        isStakingLimitSet = stakeLimitData.isStakingLimitSet();\n\n        currentStakeLimit = _getCurrentStakeLimit(stakeLimitData);\n\n        maxStakeLimit = stakeLimitData.maxStakeLimit;\n        maxStakeLimitGrowthBlocks = stakeLimitData.maxStakeLimitGrowthBlocks;\n        prevStakeLimit = stakeLimitData.prevStakeLimit;\n        prevStakeBlockNumber = stakeLimitData.prevStakeBlockNumber;\n    }\n\n    /**\n    * @notice Send funds to the pool\n    * @dev Users are able to submit their funds by transacting to the fallback function.\n    * Unlike vanilla Ethereum Deposit contract, accepting only 32-Ether transactions, Lido\n    * accepts payments of any size. Submitted Ethers are stored in Buffer until someone calls\n    * deposit() and pushes them to the Ethereum Deposit contract.\n    */\n    // solhint-disable-next-line no-complex-fallback\n    function() external payable {\n        // protection against accidental submissions by calling non-existent function\n        require(msg.data.length == 0, "NON_EMPTY_DATA");\n        _submit(0);\n    }\n\n    /**\n     * @notice Send funds to the pool with optional _referral parameter\n     * @dev This function is alternative way to submit funds. Supports optional referral address.\n     * @return Amount of StETH shares generated\n     */\n    function submit(address _referral) external payable returns (uint256) {\n        return _submit(_referral);\n    }\n\n    /**\n     * @notice A payable function for execution layer rewards. Can be called only by `ExecutionLayerRewardsVault`\n     * @dev We need a dedicated function because funds received by the default payable function\n     * are treated as a user deposit\n     */\n    function receiveELRewards() external payable {\n        require(msg.sender == getLidoLocator().elRewardsVault());\n\n        TOTAL_EL_REWARDS_COLLECTED_POSITION.setStorageUint256(getTotalELRewardsCollected().add(msg.value));\n\n        emit ELRewardsReceived(msg.value);\n    }\n\n    /**\n    * @notice A payable function for withdrawals acquisition. Can be called only by `WithdrawalVault`\n    * @dev We need a dedicated function because funds received by the default payable function\n    * are treated as a user deposit\n    */\n    function receiveWithdrawals() external payable {\n        require(msg.sender == getLidoLocator().withdrawalVault());\n\n        emit WithdrawalsReceived(msg.value);\n    }\n\n    /**\n     * @notice Stop pool routine operations\n     */\n    function stop() external {\n        _auth(PAUSE_ROLE);\n\n        _stop();\n        _pauseStaking();\n    }\n\n    /**\n     * @notice Resume pool routine operations\n     * @dev Staking is resumed after this call using the previously set limits (if any)\n     */\n    function resume() external {\n        _auth(RESUME_ROLE);\n\n        _resume();\n        _resumeStaking();\n    }\n\n    /**\n     * The structure is used to aggregate the `handleOracleReport` provided data.\n     * @dev Using the in-memory structure addresses `stack too deep` issues.\n     */\n    struct OracleReportedData {\n        // Oracle timings\n        uint256 reportTimestamp;\n        uint256 timeElapsed;\n        // CL values\n        uint256 clValidators;\n        uint256 postCLBalance;\n        // EL values\n        uint256 withdrawalVaultBalance;\n        uint256 elRewardsVaultBalance;\n        uint256 sharesRequestedToBurn;\n        // Decision about withdrawals processing\n        uint256[] withdrawalFinalizationBatches;\n        uint256 simulatedShareRate;\n    }\n\n    /**\n     * The structure is used to preload the contract using `getLidoLocator()` via single call\n     */\n    struct OracleReportContracts {\n        address accountingOracle;\n        address elRewardsVault;\n        address oracleReportSanityChecker;\n        address burner;\n        address withdrawalQueue;\n        address withdrawalVault;\n        address postTokenRebaseReceiver;\n    }\n\n    /**\n    * @notice Updates accounting stats, collects EL rewards and distributes collected rewards\n    *         if beacon balance increased, performs withdrawal requests finalization\n    * @dev periodically called by the AccountingOracle contract\n    *\n    * @param _reportTimestamp the moment of the oracle report calculation\n    * @param _timeElapsed seconds elapsed since the previous report calculation\n    * @param _clValidators number of Lido validators on Consensus Layer\n    * @param _clBalance sum of all Lido validators\' balances on Consensus Layer\n    * @param _withdrawalVaultBalance withdrawal vault balance on Execution Layer at `_reportTimestamp`\n    * @param _elRewardsVaultBalance elRewards vault balance on Execution Layer at `_reportTimestamp`\n    * @param _sharesRequestedToBurn shares requested to burn through Burner at `_reportTimestamp`\n    * @param _withdrawalFinalizationBatches the ascendingly-sorted array of withdrawal request IDs obtained by calling\n    * WithdrawalQueue.calculateFinalizationBatches. Empty array means that no withdrawal requests should be finalized\n    * @param _simulatedShareRate share rate that was simulated by oracle when the report data created (1e27 precision)\n    *\n    * NB: `_simulatedShareRate` should be calculated off-chain by calling the method with `eth_call` JSON-RPC API\n    * while passing empty `_withdrawalFinalizationBatches` and `_simulatedShareRate` == 0, plugging the returned values\n    * to the following formula: `_simulatedShareRate = (postTotalPooledEther * 1e27) / postTotalShares`\n    *\n    * @return postRebaseAmounts[0]: `postTotalPooledEther` amount of ether in the protocol after report\n    * @return postRebaseAmounts[1]: `postTotalShares` amount of shares in the protocol after report\n    * @return postRebaseAmounts[2]: `withdrawals` withdrawn from the withdrawals vault\n    * @return postRebaseAmounts[3]: `elRewards` withdrawn from the execution layer rewards vault\n    */\n    function handleOracleReport(\n        // Oracle timings\n        uint256 _reportTimestamp,\n        uint256 _timeElapsed,\n        // CL values\n        uint256 _clValidators,\n        uint256 _clBalance,\n        // EL values\n        uint256 _withdrawalVaultBalance,\n        uint256 _elRewardsVaultBalance,\n        uint256 _sharesRequestedToBurn,\n        // Decision about withdrawals processing\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate\n    ) external returns (uint256[4] postRebaseAmounts) {\n        _whenNotStopped();\n\n        return _handleOracleReport(\n            OracleReportedData(\n                _reportTimestamp,\n                _timeElapsed,\n                _clValidators,\n                _clBalance,\n                _withdrawalVaultBalance,\n                _elRewardsVaultBalance,\n                _sharesRequestedToBurn,\n                _withdrawalFinalizationBatches,\n                _simulatedShareRate\n            )\n        );\n    }\n\n    /**\n     * @notice Unsafely change deposited validators\n     *\n     * The method unsafely changes deposited validator counter.\n     * Can be required when onboarding external validators to Lido\n     * (i.e., had deposited before and rotated their type-0x00 withdrawal credentials to Lido)\n     *\n     * @param _newDepositedValidators new value\n     */\n    function unsafeChangeDepositedValidators(uint256 _newDepositedValidators) external {\n        _auth(UNSAFE_CHANGE_DEPOSITED_VALIDATORS_ROLE);\n\n        DEPOSITED_VALIDATORS_POSITION.setStorageUint256(_newDepositedValidators);\n\n        emit DepositedValidatorsChanged(_newDepositedValidators);\n    }\n\n    /**\n     * @notice Overrides default AragonApp behaviour to disallow recovery.\n     */\n    function transferToVault(address /* _token */) external {\n        revert("NOT_SUPPORTED");\n    }\n\n    /**\n    * @notice Get the amount of Ether temporary buffered on this contract balance\n    * @dev Buffered balance is kept on the contract from the moment the funds are received from user\n    * until the moment they are actually sent to the official Deposit contract.\n    * @return amount of buffered funds in wei\n    */\n    function getBufferedEther() external view returns (uint256) {\n        return _getBufferedEther();\n    }\n\n    /**\n     * @notice Get total amount of execution layer rewards collected to Lido contract\n     * @dev Ether got through LidoExecutionLayerRewardsVault is kept on this contract\'s balance the same way\n     * as other buffered Ether is kept (until it gets deposited)\n     * @return amount of funds received as execution layer rewards in wei\n     */\n    function getTotalELRewardsCollected() public view returns (uint256) {\n        return TOTAL_EL_REWARDS_COLLECTED_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @notice Gets authorized oracle address\n     * @return address of oracle contract\n     */\n    function getLidoLocator() public view returns (ILidoLocator) {\n        return ILidoLocator(LIDO_LOCATOR_POSITION.getStorageAddress());\n    }\n\n    /**\n    * @notice Returns the key values related to Consensus Layer side of the contract. It historically contains beacon\n    * @return depositedValidators - number of deposited validators from Lido contract side\n    * @return beaconValidators - number of Lido validators visible on Consensus Layer, reported by oracle\n    * @return beaconBalance - total amount of ether on the Consensus Layer side (sum of all the balances of Lido validators)\n    *\n    * @dev `beacon` in naming still here for historical reasons\n    */\n    function getBeaconStat() external view returns (uint256 depositedValidators, uint256 beaconValidators, uint256 beaconBalance) {\n        depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        beaconValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        beaconBalance = CL_BALANCE_POSITION.getStorageUint256();\n    }\n\n    /**\n     * @dev Check that Lido allows depositing buffered ether to the consensus layer\n     * Depends on the bunker state and protocol\'s pause state\n     */\n    function canDeposit() public view returns (bool) {\n        return !_withdrawalQueue().isBunkerModeActive() && !isStopped();\n    }\n\n    /**\n     * @dev Returns depositable ether amount.\n     * Takes into account unfinalized stETH required by WithdrawalQueue\n     */\n    function getDepositableEther() public view returns (uint256) {\n        uint256 bufferedEther = _getBufferedEther();\n        uint256 withdrawalReserve = _withdrawalQueue().unfinalizedStETH();\n        return bufferedEther > withdrawalReserve ? bufferedEther - withdrawalReserve : 0;\n    }\n\n    /**\n     * @dev Invokes a deposit call to the Staking Router contract and updates buffered counters\n     * @param _maxDepositsCount max deposits count\n     * @param _stakingModuleId id of the staking module to be deposited\n     * @param _depositCalldata module calldata\n     */\n    function deposit(uint256 _maxDepositsCount, uint256 _stakingModuleId, bytes _depositCalldata) external {\n        ILidoLocator locator = getLidoLocator();\n\n        require(msg.sender == locator.depositSecurityModule(), "APP_AUTH_DSM_FAILED");\n        require(canDeposit(), "CAN_NOT_DEPOSIT");\n\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 depositsCount = Math256.min(\n            _maxDepositsCount,\n            stakingRouter.getStakingModuleMaxDepositsCount(_stakingModuleId, getDepositableEther())\n        );\n\n        uint256 depositsValue;\n        if (depositsCount > 0) {\n            depositsValue = depositsCount.mul(DEPOSIT_SIZE);\n            /// @dev firstly update the local state of the contract to prevent a reentrancy attack,\n            ///     even if the StakingRouter is a trusted contract.\n            BUFFERED_ETHER_POSITION.setStorageUint256(_getBufferedEther().sub(depositsValue));\n            emit Unbuffered(depositsValue);\n\n            uint256 newDepositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256().add(depositsCount);\n            DEPOSITED_VALIDATORS_POSITION.setStorageUint256(newDepositedValidators);\n            emit DepositedValidatorsChanged(newDepositedValidators);\n        }\n\n        /// @dev transfer ether to StakingRouter and make a deposit at the same time. All the ether\n        ///     sent to StakingRouter is counted as deposited. If StakingRouter can\'t deposit all\n        ///     passed ether it MUST revert the whole transaction (never happens in normal circumstances)\n        stakingRouter.deposit.value(depositsValue)(depositsCount, _stakingModuleId, _depositCalldata);\n    }\n\n    /// DEPRECATED PUBLIC METHODS\n\n    /**\n     * @notice Returns current withdrawal credentials of deposited validators\n     * @dev DEPRECATED: use StakingRouter.getWithdrawalCredentials() instead\n     */\n    function getWithdrawalCredentials() external view returns (bytes32) {\n        return _stakingRouter().getWithdrawalCredentials();\n    }\n\n    /**\n     * @notice Returns legacy oracle\n     * @dev DEPRECATED: the `AccountingOracle` superseded the old one\n     */\n    function getOracle() external view returns (address) {\n        return getLidoLocator().legacyOracle();\n    }\n\n    /**\n     * @notice Returns the treasury address\n     * @dev DEPRECATED: use LidoLocator.treasury()\n     */\n    function getTreasury() external view returns (address) {\n        return _treasury();\n    }\n\n    /**\n     * @notice Returns current staking rewards fee rate\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return totalFee total rewards fee in 1e4 precision (10000 is 100%). The value might be\n     * inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFee() external view returns (uint16 totalFee) {\n        totalFee = _stakingRouter().getTotalFeeE4Precision();\n    }\n\n    /**\n     * @notice Returns current fee distribution, values relative to the total fee (getFee())\n     * @dev DEPRECATED: Now fees information is stored in StakingRouter and\n     * with higher precision. Use StakingRouter.getStakingFeeAggregateDistribution() instead.\n     * @return treasuryFeeBasisPoints return treasury fee in TOTAL_BASIS_POINTS (10000 is 100% fee) precision\n     * @return insuranceFeeBasisPoints always returns 0 because the capability to send fees to\n     * insurance from Lido contract is removed.\n     * @return operatorsFeeBasisPoints return total fee for all operators of all staking modules in\n     * TOTAL_BASIS_POINTS (10000 is 100% fee) precision.\n     * Previously returned total fee of all node operators of NodeOperatorsRegistry (Curated staking module now)\n     * The value might be inaccurate because the actual value is truncated here to 1e4 precision.\n     */\n    function getFeeDistribution()\n        external view\n        returns (\n            uint16 treasuryFeeBasisPoints,\n            uint16 insuranceFeeBasisPoints,\n            uint16 operatorsFeeBasisPoints\n        )\n    {\n        IStakingRouter stakingRouter = _stakingRouter();\n        uint256 totalBasisPoints = stakingRouter.TOTAL_BASIS_POINTS();\n        uint256 totalFee = stakingRouter.getTotalFeeE4Precision();\n        (uint256 treasuryFeeBasisPointsAbs, uint256 operatorsFeeBasisPointsAbs) = stakingRouter\n            .getStakingFeeAggregateDistributionE4Precision();\n\n        insuranceFeeBasisPoints = 0;  // explicitly set to zero\n        treasuryFeeBasisPoints = uint16((treasuryFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n        operatorsFeeBasisPoints = uint16((operatorsFeeBasisPointsAbs * totalBasisPoints) / totalFee);\n    }\n\n    /*\n     * @dev updates Consensus Layer state snapshot according to the current report\n     *\n     * NB: conventions and assumptions\n     *\n     * `depositedValidators` are total amount of the **ever** deposited Lido validators\n     * `_postClValidators` are total amount of the **ever** appeared on the CL side Lido validators\n     *\n     * i.e., exited Lido validators persist in the state, just with a different status\n     */\n    function _processClStateUpdate(\n        uint256 _reportTimestamp,\n        uint256 _preClValidators,\n        uint256 _postClValidators,\n        uint256 _postClBalance\n    ) internal returns (uint256 preCLBalance) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        require(_postClValidators <= depositedValidators, "REPORTED_MORE_DEPOSITED");\n        require(_postClValidators >= _preClValidators, "REPORTED_LESS_VALIDATORS");\n\n        if (_postClValidators > _preClValidators) {\n            CL_VALIDATORS_POSITION.setStorageUint256(_postClValidators);\n        }\n\n        uint256 appearedValidators = _postClValidators - _preClValidators;\n        preCLBalance = CL_BALANCE_POSITION.getStorageUint256();\n        // Take into account the balance of the newly appeared validators\n        preCLBalance = preCLBalance.add(appearedValidators.mul(DEPOSIT_SIZE));\n\n        // Save the current CL balance and validators to\n        // calculate rewards on the next push\n        CL_BALANCE_POSITION.setStorageUint256(_postClBalance);\n\n        emit CLValidatorsUpdated(_reportTimestamp, _preClValidators, _postClValidators);\n    }\n\n    /**\n     * @dev collect ETH from ELRewardsVault and WithdrawalVault, then send to WithdrawalQueue\n     */\n    function _collectRewardsAndProcessWithdrawals(\n        OracleReportContracts memory _contracts,\n        uint256 _withdrawalsToWithdraw,\n        uint256 _elRewardsToWithdraw,\n        uint256[] _withdrawalFinalizationBatches,\n        uint256 _simulatedShareRate,\n        uint256 _etherToLockOnWithdrawalQueue\n    ) internal {\n        // withdraw execution layer rewards and put them to the buffer\n        if (_elRewardsToWithdraw > 0) {\n            ILidoExecutionLayerRewardsVault(_contracts.elRewardsVault).withdrawRewards(_elRewardsToWithdraw);\n        }\n\n        // withdraw withdrawals and put them to the buffer\n        if (_withdrawalsToWithdraw > 0) {\n            IWithdrawalVault(_contracts.withdrawalVault).withdrawWithdrawals(_withdrawalsToWithdraw);\n        }\n\n        // finalize withdrawals (send ether, assign shares for burning)\n        if (_etherToLockOnWithdrawalQueue > 0) {\n            IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n            withdrawalQueue.finalize.value(_etherToLockOnWithdrawalQueue)(\n                _withdrawalFinalizationBatches[_withdrawalFinalizationBatches.length - 1],\n                _simulatedShareRate\n            );\n        }\n\n        uint256 postBufferedEther = _getBufferedEther()\n            .add(_elRewardsToWithdraw) // Collected from ELVault\n            .add(_withdrawalsToWithdraw) // Collected from WithdrawalVault\n            .sub(_etherToLockOnWithdrawalQueue); // Sent to WithdrawalQueue\n\n        _setBufferedEther(postBufferedEther);\n    }\n\n    /**\n     * @dev return amount to lock on withdrawal queue and shares to burn\n     * depending on the finalization batch parameters\n     */\n    function _calculateWithdrawals(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData\n    ) internal view returns (\n        uint256 etherToLock, uint256 sharesToBurn\n    ) {\n        IWithdrawalQueue withdrawalQueue = IWithdrawalQueue(_contracts.withdrawalQueue);\n\n        if (!withdrawalQueue.isPaused()) {\n            IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkWithdrawalQueueOracleReport(\n                _reportedData.withdrawalFinalizationBatches[_reportedData.withdrawalFinalizationBatches.length - 1],\n                _reportedData.reportTimestamp\n            );\n\n            (etherToLock, sharesToBurn) = withdrawalQueue.prefinalize(\n                _reportedData.withdrawalFinalizationBatches,\n                _reportedData.simulatedShareRate\n            );\n        }\n    }\n\n    /**\n     * @dev calculate the amount of rewards and distribute it\n     */\n    function _processRewards(\n        OracleReportContext memory _reportContext,\n        uint256 _postCLBalance,\n        uint256 _withdrawnWithdrawals,\n        uint256 _withdrawnElRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        uint256 postCLTotalBalance = _postCLBalance.add(_withdrawnWithdrawals);\n        // Dont mint/distribute any protocol fee on the non-profitable Lido oracle report\n        // (when consensus layer balance delta is zero or negative).\n        // See LIP-12 for details:\n        // https://research.lido.fi/t/lip-12-on-chain-part-of-the-rewards-distribution-after-the-merge/1625\n        if (postCLTotalBalance > _reportContext.preCLBalance) {\n            uint256 consensusLayerRewards = postCLTotalBalance - _reportContext.preCLBalance;\n\n            sharesMintedAsFees = _distributeFee(\n                _reportContext.preTotalPooledEther,\n                _reportContext.preTotalShares,\n                consensusLayerRewards.add(_withdrawnElRewards)\n            );\n        }\n    }\n\n    /**\n     * @dev Process user deposit, mints liquid tokens and increase the pool buffer\n     * @param _referral address of referral.\n     * @return amount of StETH shares generated\n     */\n    function _submit(address _referral) internal returns (uint256) {\n        require(msg.value != 0, "ZERO_DEPOSIT");\n\n        StakeLimitState.Data memory stakeLimitData = STAKING_STATE_POSITION.getStorageStakeLimitStruct();\n        // There is an invariant that protocol pause also implies staking pause.\n        // Thus, no need to check protocol pause explicitly.\n        require(!stakeLimitData.isStakingPaused(), "STAKING_PAUSED");\n\n        if (stakeLimitData.isStakingLimitSet()) {\n            uint256 currentStakeLimit = stakeLimitData.calculateCurrentStakeLimit();\n\n            require(msg.value <= currentStakeLimit, "STAKE_LIMIT");\n\n            STAKING_STATE_POSITION.setStorageStakeLimitStruct(stakeLimitData.updatePrevStakeLimit(currentStakeLimit - msg.value));\n        }\n\n        uint256 sharesAmount = getSharesByPooledEth(msg.value);\n\n        _mintShares(msg.sender, sharesAmount);\n\n        _setBufferedEther(_getBufferedEther().add(msg.value));\n        emit Submitted(msg.sender, msg.value, _referral);\n\n        _emitTransferAfterMintingShares(msg.sender, sharesAmount);\n        return sharesAmount;\n    }\n\n    /**\n     * @dev Staking router rewards distribution.\n     *\n     * Corresponds to the return value of `IStakingRouter.newTotalPooledEtherForRewards()`\n     * Prevents `stack too deep` issue.\n     */\n    struct StakingRewardsDistribution {\n        address[] recipients;\n        uint256[] moduleIds;\n        uint96[] modulesFees;\n        uint96 totalFee;\n        uint256 precisionPoints;\n    }\n\n    /**\n     * @dev Get staking rewards distribution from staking router.\n     */\n    function _getStakingRewardsDistribution() internal view returns (\n        StakingRewardsDistribution memory ret,\n        IStakingRouter router\n    ) {\n        router = _stakingRouter();\n\n        (\n            ret.recipients,\n            ret.moduleIds,\n            ret.modulesFees,\n            ret.totalFee,\n            ret.precisionPoints\n        ) = router.getStakingRewardsDistribution();\n\n        require(ret.recipients.length == ret.modulesFees.length, "WRONG_RECIPIENTS_INPUT");\n        require(ret.moduleIds.length == ret.modulesFees.length, "WRONG_MODULE_IDS_INPUT");\n    }\n\n    /**\n     * @dev Distributes fee portion of the rewards by minting and distributing corresponding amount of liquid tokens.\n     * @param _preTotalPooledEther Total supply before report-induced changes applied\n     * @param _preTotalShares Total shares before report-induced changes applied\n     * @param _totalRewards Total rewards accrued both on the Execution Layer and the Consensus Layer sides in wei.\n     */\n    function _distributeFee(\n        uint256 _preTotalPooledEther,\n        uint256 _preTotalShares,\n        uint256 _totalRewards\n    ) internal returns (uint256 sharesMintedAsFees) {\n        // We need to take a defined percentage of the reported reward as a fee, and we do\n        // this by minting new token shares and assigning them to the fee recipients (see\n        // StETH docs for the explanation of the shares mechanics). The staking rewards fee\n        // is defined in basis points (1 basis point is equal to 0.01%, 10000 (TOTAL_BASIS_POINTS) is 100%).\n        //\n        // Since we are increasing totalPooledEther by _totalRewards (totalPooledEtherWithRewards),\n        // the combined cost of all holders\' shares has became _totalRewards StETH tokens more,\n        // effectively splitting the reward between each token holder proportionally to their token share.\n        //\n        // Now we want to mint new shares to the fee recipient, so that the total cost of the\n        // newly-minted shares exactly corresponds to the fee taken:\n        //\n        // totalPooledEtherWithRewards = _preTotalPooledEther + _totalRewards\n        // shares2mint * newShareCost = (_totalRewards * totalFee) / PRECISION_POINTS\n        // newShareCost = totalPooledEtherWithRewards / (_preTotalShares + shares2mint)\n        //\n        // which follows to:\n        //\n        //                        _totalRewards * totalFee * _preTotalShares\n        // shares2mint = --------------------------------------------------------------\n        //                 (totalPooledEtherWithRewards * PRECISION_POINTS) - (_totalRewards * totalFee)\n        //\n        // The effect is that the given percentage of the reward goes to the fee recipient, and\n        // the rest of the reward is distributed between token holders proportionally to their\n        // token shares.\n\n        (\n            StakingRewardsDistribution memory rewardsDistribution,\n            IStakingRouter router\n        ) = _getStakingRewardsDistribution();\n\n        if (rewardsDistribution.totalFee > 0) {\n            uint256 totalPooledEtherWithRewards = _preTotalPooledEther.add(_totalRewards);\n\n            sharesMintedAsFees =\n                _totalRewards.mul(rewardsDistribution.totalFee).mul(_preTotalShares).div(\n                    totalPooledEtherWithRewards.mul(\n                        rewardsDistribution.precisionPoints\n                    ).sub(_totalRewards.mul(rewardsDistribution.totalFee))\n                );\n\n            _mintShares(address(this), sharesMintedAsFees);\n\n            (uint256[] memory moduleRewards, uint256 totalModuleRewards) =\n                _transferModuleRewards(\n                    rewardsDistribution.recipients,\n                    rewardsDistribution.modulesFees,\n                    rewardsDistribution.totalFee,\n                    sharesMintedAsFees\n                );\n\n            _transferTreasuryRewards(sharesMintedAsFees.sub(totalModuleRewards));\n\n            router.reportRewardsMinted(\n                rewardsDistribution.moduleIds,\n                moduleRewards\n            );\n        }\n    }\n\n    function _transferModuleRewards(\n        address[] memory recipients,\n        uint96[] memory modulesFees,\n        uint256 totalFee,\n        uint256 totalRewards\n    ) internal returns (uint256[] memory moduleRewards, uint256 totalModuleRewards) {\n        moduleRewards = new uint256[](recipients.length);\n\n        for (uint256 i; i < recipients.length; ++i) {\n            if (modulesFees[i] > 0) {\n                uint256 iModuleRewards = totalRewards.mul(modulesFees[i]).div(totalFee);\n                moduleRewards[i] = iModuleRewards;\n                _transferShares(address(this), recipients[i], iModuleRewards);\n                _emitTransferAfterMintingShares(recipients[i], iModuleRewards);\n                totalModuleRewards = totalModuleRewards.add(iModuleRewards);\n            }\n        }\n    }\n\n    function _transferTreasuryRewards(uint256 treasuryReward) internal {\n        address treasury = _treasury();\n        _transferShares(address(this), treasury, treasuryReward);\n        _emitTransferAfterMintingShares(treasury, treasuryReward);\n    }\n\n    /**\n     * @dev Gets the amount of Ether temporary buffered on this contract balance\n     */\n    function _getBufferedEther() internal view returns (uint256) {\n        return BUFFERED_ETHER_POSITION.getStorageUint256();\n    }\n\n    function _setBufferedEther(uint256 _newBufferedEther) internal {\n        BUFFERED_ETHER_POSITION.setStorageUint256(_newBufferedEther);\n    }\n\n    /// @dev Calculates and returns the total base balance (multiple of 32) of validators in transient state,\n    ///     i.e. submitted to the official Deposit contract but not yet visible in the CL state.\n    /// @return transient balance in wei (1e-18 Ether)\n    function _getTransientBalance() internal view returns (uint256) {\n        uint256 depositedValidators = DEPOSITED_VALIDATORS_POSITION.getStorageUint256();\n        uint256 clValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        // clValidators can never be less than deposited ones.\n        assert(depositedValidators >= clValidators);\n        return (depositedValidators - clValidators).mul(DEPOSIT_SIZE);\n    }\n\n    /**\n     * @dev Gets the total amount of Ether controlled by the system\n     * @return total balance in wei\n     */\n    function _getTotalPooledEther() internal view returns (uint256) {\n        return _getBufferedEther()\n            .add(CL_BALANCE_POSITION.getStorageUint256())\n            .add(_getTransientBalance());\n    }\n\n    function _pauseStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(true)\n        );\n\n        emit StakingPaused();\n    }\n\n    function _resumeStaking() internal {\n        STAKING_STATE_POSITION.setStorageStakeLimitStruct(\n            STAKING_STATE_POSITION.getStorageStakeLimitStruct().setStakeLimitPauseState(false)\n        );\n\n        emit StakingResumed();\n    }\n\n    function _getCurrentStakeLimit(StakeLimitState.Data memory _stakeLimitData) internal view returns (uint256) {\n        if (_stakeLimitData.isStakingPaused()) {\n            return 0;\n        }\n        if (!_stakeLimitData.isStakingLimitSet()) {\n            return uint256(-1);\n        }\n\n        return _stakeLimitData.calculateCurrentStakeLimit();\n    }\n\n    /**\n     * @dev Size-efficient analog of the `auth(_role)` modifier\n     * @param _role Permission name\n     */\n    function _auth(bytes32 _role) internal view {\n        require(canPerform(msg.sender, _role, new uint256[](0)), "APP_AUTH_FAILED");\n    }\n\n    /**\n     * @dev Intermediate data structure for `_handleOracleReport`\n     * Helps to overcome `stack too deep` issue.\n     */\n    struct OracleReportContext {\n        uint256 preCLValidators;\n        uint256 preCLBalance;\n        uint256 preTotalPooledEther;\n        uint256 preTotalShares;\n        uint256 etherToLockOnWithdrawalQueue;\n        uint256 sharesToBurnFromWithdrawalQueue;\n        uint256 simulatedSharesToBurn;\n        uint256 sharesToBurn;\n        uint256 sharesMintedAsFees;\n    }\n\n    /**\n     * @dev Handle oracle report method operating with the data-packed structs\n     * Using structs helps to overcome \'stack too deep\' issue.\n     *\n     * The method updates the protocol\'s accounting state.\n     * Key steps:\n     * 1. Take a snapshot of the current (pre-) state\n     * 2. Pass the report data to sanity checker (reverts if malformed)\n     * 3. Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n     * 4. Pass the accounting values to sanity checker to smoothen positive token rebase\n     *    (i.e., postpone the extra rewards to be applied during the next rounds)\n     * 5. Invoke finalization of the withdrawal requests\n     * 6. Burn excess shares within the allowed limit (can postpone some shares to be burnt later)\n     * 7. Distribute protocol fee (treasury & node operators)\n     * 8. Complete token rebase by informing observers (emit an event and call the external receivers if any)\n     * 9. Sanity check for the provided simulated share rate\n     */\n    function _handleOracleReport(OracleReportedData memory _reportedData) internal returns (uint256[4]) {\n        OracleReportContracts memory contracts = _loadOracleReportContracts();\n\n        require(msg.sender == contracts.accountingOracle, "APP_AUTH_FAILED");\n        require(_reportedData.reportTimestamp <= block.timestamp, "INVALID_REPORT_TIMESTAMP");\n\n        OracleReportContext memory reportContext;\n\n        // Step 1.\n        // Take a snapshot of the current (pre-) state\n        reportContext.preTotalPooledEther = _getTotalPooledEther();\n        reportContext.preTotalShares = _getTotalShares();\n        reportContext.preCLValidators = CL_VALIDATORS_POSITION.getStorageUint256();\n        reportContext.preCLBalance = _processClStateUpdate(\n            _reportedData.reportTimestamp,\n            reportContext.preCLValidators,\n            _reportedData.clValidators,\n            _reportedData.postCLBalance\n        );\n\n        // Step 2.\n        // Pass the report data to sanity checker (reverts if malformed)\n        _checkAccountingOracleReport(contracts, _reportedData, reportContext);\n\n        // Step 3.\n        // Pre-calculate the ether to lock for withdrawal queue and shares to be burnt\n        // due to withdrawal requests to finalize\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            (\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurnFromWithdrawalQueue\n            ) = _calculateWithdrawals(contracts, _reportedData);\n\n            if (reportContext.sharesToBurnFromWithdrawalQueue > 0) {\n                IBurner(contracts.burner).requestBurnShares(\n                    contracts.withdrawalQueue,\n                    reportContext.sharesToBurnFromWithdrawalQueue\n                );\n            }\n        }\n\n        // Step 4.\n        // Pass the accounting values to sanity checker to smoothen positive token rebase\n\n        uint256 withdrawals;\n        uint256 elRewards;\n        (\n            withdrawals, elRewards, reportContext.simulatedSharesToBurn, reportContext.sharesToBurn\n        ) = IOracleReportSanityChecker(contracts.oracleReportSanityChecker).smoothenTokenRebase(\n            reportContext.preTotalPooledEther,\n            reportContext.preTotalShares,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            reportContext.etherToLockOnWithdrawalQueue,\n            reportContext.sharesToBurnFromWithdrawalQueue\n        );\n\n        // Step 5.\n        // Invoke finalization of the withdrawal requests (send ether to withdrawal queue, assign shares to be burnt)\n        _collectRewardsAndProcessWithdrawals(\n            contracts,\n            withdrawals,\n            elRewards,\n            _reportedData.withdrawalFinalizationBatches,\n            _reportedData.simulatedShareRate,\n            reportContext.etherToLockOnWithdrawalQueue\n        );\n\n        emit ETHDistributed(\n            _reportedData.reportTimestamp,\n            reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards,\n            _getBufferedEther()\n        );\n\n        // Step 6.\n        // Burn the previously requested shares\n        if (reportContext.sharesToBurn > 0) {\n            IBurner(contracts.burner).commitSharesToBurn(reportContext.sharesToBurn);\n            _burnShares(contracts.burner, reportContext.sharesToBurn);\n        }\n\n        // Step 7.\n        // Distribute protocol fee (treasury & node operators)\n        reportContext.sharesMintedAsFees = _processRewards(\n            reportContext,\n            _reportedData.postCLBalance,\n            withdrawals,\n            elRewards\n        );\n\n        // Step 8.\n        // Complete token rebase by informing observers (emit an event and call the external receivers if any)\n        (\n            uint256 postTotalShares,\n            uint256 postTotalPooledEther\n        ) = _completeTokenRebase(\n            _reportedData,\n            reportContext,\n            IPostTokenRebaseReceiver(contracts.postTokenRebaseReceiver)\n        );\n\n        // Step 9. Sanity check for the provided simulated share rate\n        if (_reportedData.withdrawalFinalizationBatches.length != 0) {\n            IOracleReportSanityChecker(contracts.oracleReportSanityChecker).checkSimulatedShareRate(\n                postTotalPooledEther,\n                postTotalShares,\n                reportContext.etherToLockOnWithdrawalQueue,\n                reportContext.sharesToBurn.sub(reportContext.simulatedSharesToBurn),\n                _reportedData.simulatedShareRate\n            );\n        }\n\n        return [postTotalPooledEther, postTotalShares, withdrawals, elRewards];\n    }\n\n    /**\n     * @dev Pass the provided oracle data to the sanity checker contract\n     * Works with structures to overcome `stack too deep`\n     */\n    function _checkAccountingOracleReport(\n        OracleReportContracts memory _contracts,\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext\n    ) internal view {\n        IOracleReportSanityChecker(_contracts.oracleReportSanityChecker).checkAccountingOracleReport(\n            _reportedData.timeElapsed,\n            _reportContext.preCLBalance,\n            _reportedData.postCLBalance,\n            _reportedData.withdrawalVaultBalance,\n            _reportedData.elRewardsVaultBalance,\n            _reportedData.sharesRequestedToBurn,\n            _reportContext.preCLValidators,\n            _reportedData.clValidators\n        );\n    }\n\n    /**\n     * @dev Notify observers about the completed token rebase.\n     * Emit events and call external receivers.\n     */\n    function _completeTokenRebase(\n        OracleReportedData memory _reportedData,\n        OracleReportContext memory _reportContext,\n        IPostTokenRebaseReceiver _postTokenRebaseReceiver\n    ) internal returns (uint256 postTotalShares, uint256 postTotalPooledEther) {\n        postTotalShares = _getTotalShares();\n        postTotalPooledEther = _getTotalPooledEther();\n\n        if (_postTokenRebaseReceiver != address(0)) {\n            _postTokenRebaseReceiver.handlePostTokenRebase(\n                _reportedData.reportTimestamp,\n                _reportedData.timeElapsed,\n                _reportContext.preTotalShares,\n                _reportContext.preTotalPooledEther,\n                postTotalShares,\n                postTotalPooledEther,\n                _reportContext.sharesMintedAsFees\n            );\n        }\n\n        emit TokenRebased(\n            _reportedData.reportTimestamp,\n            _reportedData.timeElapsed,\n            _reportContext.preTotalShares,\n            _reportContext.preTotalPooledEther,\n            postTotalShares,\n            postTotalPooledEther,\n            _reportContext.sharesMintedAsFees\n        );\n    }\n\n    /**\n     * @dev Load the contracts used for `handleOracleReport` internally.\n     */\n    function _loadOracleReportContracts() internal view returns (OracleReportContracts memory ret) {\n        (\n            ret.accountingOracle,\n            ret.elRewardsVault,\n            ret.oracleReportSanityChecker,\n            ret.burner,\n            ret.withdrawalQueue,\n            ret.withdrawalVault,\n            ret.postTokenRebaseReceiver\n        ) = getLidoLocator().oracleReportComponentsForLido();\n    }\n\n    function _stakingRouter() internal view returns (IStakingRouter) {\n        return IStakingRouter(getLidoLocator().stakingRouter());\n    }\n\n    function _withdrawalQueue() internal view returns (IWithdrawalQueue) {\n        return IWithdrawalQueue(getLidoLocator().withdrawalQueue());\n    }\n\n    function _treasury() internal view returns (address) {\n        return getLidoLocator().treasury();\n    }\n\n    /**\n     * @notice Mints shares on behalf of 0xdead address,\n     * the shares amount is equal to the contract\'s balance.     *\n     *\n     * Allows to get rid of zero checks for `totalShares` and `totalPooledEther`\n     * and overcome corner cases.\n     *\n     * NB: reverts if the current contract\'s balance is zero.\n     *\n     * @dev must be invoked before using the token\n     */\n    function _bootstrapInitialHolder() internal {\n        uint256 balance = address(this).balance;\n        assert(balance != 0);\n\n        if (_getTotalShares() == 0) {\n            // if protocol is empty bootstrap it with the contract\'s balance\n            // address(0xdead) is a holder for initial shares\n            _setBufferedEther(balance);\n            // emitting `Submitted` before Transfer events to preserver events order in tx\n            emit Submitted(INITIAL_TOKEN_HOLDER, balance, 0);\n            _mintInitialShares(balance);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IVaultRecoverable.transferToVault', 'start_line': 3703, 'end_line': 3703, 'offset_start': 139098, 'offset_end': 139146, 'content': 'function transferToVault(address token) external;', 'contract_name': 'IVaultRecoverable', 'contract_code': '{\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IVaultRecoverable.allowRecoverability', 'start_line': 3705, 'end_line': 3705, 'offset_start': 139153, 'offset_end': 139225, 'content': 'function allowRecoverability(address token) external view returns (bool);', 'contract_name': 'IVaultRecoverable', 'contract_code': '{\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IVaultRecoverable.getRecoveryVault', 'start_line': 3706, 'end_line': 3706, 'offset_start': 139231, 'offset_end': 139290, 'content': 'function getRecoveryVault() external view returns (address);', 'contract_name': 'IVaultRecoverable', 'contract_code': '{\n    event RecoverToVault(address indexed vault, address indexed token, uint256 amount);\n\n    function transferToVault(address token) external;\n\n    function allowRecoverability(address token) external view returns (bool);\n    function getRecoveryVault() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ConversionHelpers.dangerouslyCastUintArrayToBytes', 'start_line': 3715, 'end_line': 3724, 'offset_start': 139437, 'offset_end': 139975, 'content': "function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }", 'contract_name': 'ConversionHelpers', 'contract_code': '{\n    string private constant ERROR_IMPROPER_LENGTH = "CONVERSION_IMPROPER_LENGTH";\n\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn\'t need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }\n\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn\'t need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'ConversionHelpers.dangerouslyCastBytesToUintArray', 'start_line': 3726, 'end_line': 3737, 'offset_start': 139982, 'offset_end': 140593, 'content': "function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn't need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }", 'contract_name': 'ConversionHelpers', 'contract_code': '{\n    string private constant ERROR_IMPROPER_LENGTH = "CONVERSION_IMPROPER_LENGTH";\n\n    function dangerouslyCastUintArrayToBytes(uint256[] memory _input) internal pure returns (bytes memory output) {\n        // Force cast the uint256[] into a bytes array, by overwriting its length\n        // Note that the bytes array doesn\'t need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 byteLength = _input.length * 32;\n        assembly {\n            output := _input\n            mstore(output, byteLength)\n        }\n    }\n\n    function dangerouslyCastBytesToUintArray(bytes memory _input) internal pure returns (uint256[] memory output) {\n        // Force cast the bytes array into a uint256[], by overwriting its length\n        // Note that the uint256[] doesn\'t need to be initialized as we immediately overwrite it\n        // with the input and a new length. The input becomes invalid from this point forward.\n        uint256 intsLength = _input.length / 32;\n        require(_input.length == intsLength * 32, ERROR_IMPROPER_LENGTH);\n\n        assembly {\n            output := _input\n            mstore(output, intsLength)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SignatureUtils.isValidSignature', 'start_line': 3768, 'end_line': 3796, 'offset_start': 141656, 'offset_end': 142983, 'content': 'function isValidSignature(\n        address signer,\n        bytes32 msgHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool) {\n        if (_hasCode(signer)) {\n            bytes memory sig = abi.encodePacked(r, s, v);\n            // Solidity <0.5 generates a regular CALL instruction even if the function being called\n            // is marked as `view`, and the only way to perform a STATICCALL is to use assembly\n            bytes memory data = abi.encodeWithSelector(ERC1271_IS_VALID_SIGNATURE_SELECTOR, msgHash, sig);\n            bytes32 retval;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // allocate memory for storing the return value\n                let outDataOffset := mload(0x40)\n                mstore(0x40, add(outDataOffset, 32))\n                // issue a static call and load the result if the call succeeded\n                let success := staticcall(gas(), signer, add(data, 32), mload(data), outDataOffset, 32)\n                if and(eq(success, 1), eq(returndatasize(), 32)) {\n                    retval := mload(outDataOffset)\n                }\n            }\n            return retval == bytes32(ERC1271_IS_VALID_SIGNATURE_SELECTOR);\n        } else {\n            return ECDSA.recover(msgHash, v, r, s) == signer;\n        }\n    }', 'contract_name': 'SignatureUtils', 'contract_code': '{\n    /**\n     * @dev The selector of the ERC1271\'s `isValidSignature(bytes32 hash, bytes signature)` function,\n     * serving at the same time as the magic value that the function should return upon success.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-1271.\n     *\n     * bytes4(keccak256("isValidSignature(bytes32,bytes)")\n     */\n    bytes4 internal constant ERC1271_IS_VALID_SIGNATURE_SELECTOR = 0x1626ba7e;\n\n    /**\n     * @dev Checks signature validity.\n     *\n     * If the signer address doesn\'t contain any code, assumes that the address is externally owned\n     * and the signature is a ECDSA signature generated using its private key. Otherwise, issues a\n     * static call to the signer address to check the signature validity using the ERC-1271 standard.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 msgHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool) {\n        if (_hasCode(signer)) {\n            bytes memory sig = abi.encodePacked(r, s, v);\n            // Solidity <0.5 generates a regular CALL instruction even if the function being called\n            // is marked as `view`, and the only way to perform a STATICCALL is to use assembly\n            bytes memory data = abi.encodeWithSelector(ERC1271_IS_VALID_SIGNATURE_SELECTOR, msgHash, sig);\n            bytes32 retval;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // allocate memory for storing the return value\n                let outDataOffset := mload(0x40)\n                mstore(0x40, add(outDataOffset, 32))\n                // issue a static call and load the result if the call succeeded\n                let success := staticcall(gas(), signer, add(data, 32), mload(data), outDataOffset, 32)\n                if and(eq(success, 1), eq(returndatasize(), 32)) {\n                    retval := mload(outDataOffset)\n                }\n            }\n            return retval == bytes32(ERC1271_IS_VALID_SIGNATURE_SELECTOR);\n        } else {\n            return ECDSA.recover(msgHash, v, r, s) == signer;\n        }\n    }\n\n    function _hasCode(address addr) internal view returns (bool) {\n        uint256 size;\n        /// @solidity memory-safe-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'SignatureUtils._hasCode', 'start_line': 3798, 'end_line': 3803, 'offset_start': 142990, 'offset_end': 143194, 'content': 'function _hasCode(address addr) internal view returns (bool) {\n        uint256 size;\n        /// @solidity memory-safe-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }', 'contract_name': 'SignatureUtils', 'contract_code': '{\n    /**\n     * @dev The selector of the ERC1271\'s `isValidSignature(bytes32 hash, bytes signature)` function,\n     * serving at the same time as the magic value that the function should return upon success.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-1271.\n     *\n     * bytes4(keccak256("isValidSignature(bytes32,bytes)")\n     */\n    bytes4 internal constant ERC1271_IS_VALID_SIGNATURE_SELECTOR = 0x1626ba7e;\n\n    /**\n     * @dev Checks signature validity.\n     *\n     * If the signer address doesn\'t contain any code, assumes that the address is externally owned\n     * and the signature is a ECDSA signature generated using its private key. Otherwise, issues a\n     * static call to the signer address to check the signature validity using the ERC-1271 standard.\n     */\n    function isValidSignature(\n        address signer,\n        bytes32 msgHash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view returns (bool) {\n        if (_hasCode(signer)) {\n            bytes memory sig = abi.encodePacked(r, s, v);\n            // Solidity <0.5 generates a regular CALL instruction even if the function being called\n            // is marked as `view`, and the only way to perform a STATICCALL is to use assembly\n            bytes memory data = abi.encodeWithSelector(ERC1271_IS_VALID_SIGNATURE_SELECTOR, msgHash, sig);\n            bytes32 retval;\n            /// @solidity memory-safe-assembly\n            assembly {\n                // allocate memory for storing the return value\n                let outDataOffset := mload(0x40)\n                mstore(0x40, add(outDataOffset, 32))\n                // issue a static call and load the result if the call succeeded\n                let success := staticcall(gas(), signer, add(data, 32), mload(data), outDataOffset, 32)\n                if and(eq(success, 1), eq(returndatasize(), 32)) {\n                    retval := mload(outDataOffset)\n                }\n            }\n            return retval == bytes32(ERC1271_IS_VALID_SIGNATURE_SELECTOR);\n        } else {\n            return ECDSA.recover(msgHash, v, r, s) == signer;\n        }\n    }\n\n    function _hasCode(address addr) internal view returns (bool) {\n        uint256 size;\n        /// @solidity memory-safe-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 3813, 'end_line': 3813, 'offset_start': 143335, 'offset_end': 143389, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 3815, 'end_line': 3815, 'offset_start': 143394, 'offset_end': 143457, 'content': 'function balanceOf(address who) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 3817, 'end_line': 3818, 'offset_start': 143462, 'offset_end': 143548, 'content': 'function allowance(address owner, address spender)\n    external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 3820, 'end_line': 3820, 'offset_start': 143553, 'offset_end': 143621, 'content': 'function transfer(address to, uint256 value) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 3822, 'end_line': 3823, 'offset_start': 143626, 'offset_end': 143702, 'content': 'function approve(address spender, uint256 value)\n    external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 3825, 'end_line': 3826, 'offset_start': 143707, 'offset_end': 143797, 'content': 'function transferFrom(address from, address to, uint256 value)\n    external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n  function totalSupply() external view returns (uint256);\n\n  function balanceOf(address who) external view returns (uint256);\n\n  function allowance(address owner, address spender)\n    external view returns (uint256);\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function approve(address spender, uint256 value)\n    external returns (bool);\n\n  function transferFrom(address from, address to, uint256 value)\n    external returns (bool);\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 value\n  );\n\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AppStorage.kernel', 'start_line': 3861, 'end_line': 3863, 'offset_start': 144665, 'offset_end': 144780, 'content': 'function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }', 'contract_name': 'AppStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256("aragonOS.appStorage.kernel");\n    bytes32 internal constant APP_ID_POSITION = keccak256("aragonOS.appStorage.appId");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AppStorage.appId', 'start_line': 3865, 'end_line': 3867, 'offset_start': 144787, 'offset_end': 144892, 'content': 'function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }', 'contract_name': 'AppStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256("aragonOS.appStorage.kernel");\n    bytes32 internal constant APP_ID_POSITION = keccak256("aragonOS.appStorage.appId");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AppStorage.setKernel', 'start_line': 3869, 'end_line': 3871, 'offset_start': 144899, 'offset_end': 145011, 'content': 'function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }', 'contract_name': 'AppStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256("aragonOS.appStorage.kernel");\n    bytes32 internal constant APP_ID_POSITION = keccak256("aragonOS.appStorage.appId");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
{'type': 'FunctionDefinition', 'name': 'AppStorage.setAppId', 'start_line': 3873, 'end_line': 3875, 'offset_start': 145018, 'offset_end': 145118, 'content': 'function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }', 'contract_name': 'AppStorage', 'contract_code': '{\n    using UnstructuredStorage for bytes32;\n\n    /* Hardcoded constants to save gas\n    bytes32 internal constant KERNEL_POSITION = keccak256("aragonOS.appStorage.kernel");\n    bytes32 internal constant APP_ID_POSITION = keccak256("aragonOS.appStorage.appId");\n    */\n    bytes32 internal constant KERNEL_POSITION = 0x4172f0f7d2289153072b0a6ca36959e0cbe2efc3afe50fc81636caa96338137b;\n    bytes32 internal constant APP_ID_POSITION = 0xd625496217aa6a3453eecb9c3489dc5a53e6c67b444329ea2b2cbc9ff547639b;\n\n    function kernel() public view returns (IKernel) {\n        return IKernel(KERNEL_POSITION.getStorageAddress());\n    }\n\n    function appId() public view returns (bytes32) {\n        return APP_ID_POSITION.getStorageBytes32();\n    }\n\n    function setKernel(IKernel _kernel) internal {\n        KERNEL_POSITION.setStorageAddress(address(_kernel));\n    }\n\n    function setAppId(bytes32 _appId) internal {\n        APP_ID_POSITION.setStorageBytes32(_appId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0xae7ab96520de3a18e5e111b5eaab095312d7fe84/0xae7ab96520de3a18e5e111b5eaab095312d7fe84.sol'}
