{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 16, 'end_line': 16, 'offset_start': 403, 'offset_end': 456, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 21, 'end_line': 21, 'offset_start': 528, 'offset_end': 583, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 26, 'end_line': 26, 'offset_start': 685, 'offset_end': 757, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgSender', 'start_line': 45, 'end_line': 47, 'offset_start': 1402, 'offset_end': 1497, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Context._msgData', 'start_line': 49, 'end_line': 51, 'offset_start': 1504, 'offset_end': 1602, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'Context', 'contract_code': '{\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.tor', 'start_line': 76, 'end_line': 83, 'offset_start': 2427, 'offset_end': 2755, 'content': 'constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.supportsInterface', 'start_line': 88, 'end_line': 93, 'offset_start': 2823, 'offset_end': 3122, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.balanceOf', 'start_line': 98, 'end_line': 102, 'offset_start': 3182, 'offset_end': 3402, 'content': 'function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.ownerOf', 'start_line': 107, 'end_line': 113, 'offset_start': 3460, 'offset_end': 3726, 'content': 'function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.name', 'start_line': 118, 'end_line': 120, 'offset_start': 3793, 'offset_end': 3890, 'content': 'function name() public view virtual override returns (string memory) {\n        return _name;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.symbol', 'start_line': 125, 'end_line': 127, 'offset_start': 3955, 'offset_end': 4056, 'content': 'function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.tokenURI', 'start_line': 132, 'end_line': 137, 'offset_start': 4123, 'offset_end': 4459, 'content': 'function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos._baseURI', 'start_line': 144, 'end_line': 146, 'offset_start': 4702, 'offset_end': 4798, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.setBaseURI', 'start_line': 148, 'end_line': 150, 'offset_start': 4805, 'offset_end': 4902, 'content': 'function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.approve', 'start_line': 155, 'end_line': 157, 'offset_start': 4960, 'offset_end': 5095, 'content': 'function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.getApproved', 'start_line': 162, 'end_line': 164, 'offset_start': 5157, 'offset_end': 5307, 'content': 'function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.setApprovalForAll', 'start_line': 169, 'end_line': 171, 'offset_start': 5375, 'offset_end': 5524, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.isApprovedForAll', 'start_line': 176, 'end_line': 178, 'offset_start': 5591, 'offset_end': 5722, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.transferFrom', 'start_line': 183, 'end_line': 189, 'offset_start': 5785, 'offset_end': 5969, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.safeTransferFrom', 'start_line': 194, 'end_line': 200, 'offset_start': 6036, 'offset_end': 6224, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.safeTransferFrom', 'start_line': 205, 'end_line': 212, 'offset_start': 6291, 'offset_end': 6516, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.exists', 'start_line': 217, 'end_line': 219, 'offset_start': 6585, 'offset_end': 6698, 'content': 'function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.claim', 'start_line': 221, 'end_line': 226, 'offset_start': 6705, 'offset_end': 6969, 'content': 'function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.initializeToOwners', 'start_line': 228, 'end_line': 232, 'offset_start': 6976, 'offset_end': 7178, 'content': 'function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.initializeBulkSimple', 'start_line': 234, 'end_line': 236, 'offset_start': 7185, 'offset_end': 7349, 'content': 'function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.initializeBulk', 'start_line': 238, 'end_line': 240, 'offset_start': 7356, 'offset_end': 7524, 'content': 'function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'GoonzSchoolPhotos.initializeBulkTo', 'start_line': 242, 'end_line': 254, 'offset_start': 7535, 'offset_end': 8293, 'content': 'function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }', 'contract_name': 'GoonzSchoolPhotos', 'contract_code': '{\n    using Strings for uint256;\n\n    string private _name;\n    string private _symbol;\n    IERC721 immutable public ogGoonzNFT;\n    IERC721 immutable public portalGoonzNFT;\n    address public portalGoonz;\n    string public baseURI;\n\n    // EIP2309 Events\n    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed fromAddress, address indexed toAddress);\n\n    constructor(string memory name_, string memory symbol_, address _ogGoonz, address _portalGoonz, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        ogGoonzNFT = IERC721(_ogGoonz);\n        portalGoonzNFT = IERC721(_portalGoonz);\n        portalGoonz = _portalGoonz;\n        baseURI = baseURI_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) external view virtual override returns (uint256) {\n        uint256 balance = ogGoonzNFT.balanceOf(owner);\n        balance += portalGoonzNFT.balanceOf(owner);\n        return balance;\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address owner) {\n        address owner = ogGoonzNFT.ownerOf(tokenId);\n        if (owner == portalGoonz) {\n            return portalGoonzNFT.ownerOf(tokenId);\n        }\n        return owner;\n    }\n    \n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(exists(tokenId), "ERC721Metadata: URI query for nonexistent token");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return baseURI;\n    }\n\n    function setBaseURI(string memory newuri) external onlyRealOwner {\n        baseURI = newuri;\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return false;\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        revert("Companion tokens can not be transferred");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        revert("Companion tokens can not be manually transferred");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     */\n    function exists(uint256 tokenId) public view returns (bool) {\n        return ownerOf(tokenId) != address(0);\n    }\n\n    function claim(uint256[] calldata tokenIds) external {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(exists(tokenIds[i]), "Token doesn\'t exist");\n            emit Transfer(address(0), ownerOf(tokenIds[i]), tokenIds[i]);\n        }\n    }\n\n    function initializeToOwners(uint256 start_, uint256 end_) external onlyRealOwner {\n        for (uint256 i = start_; i <= end_; i++) {\n            emit Transfer(address(0), ownerOf(i), i);\n        }\n    }\n\n    function initializeBulkSimple(uint256 start_, uint256 end_) external onlyRealOwner {\n        emit ConsecutiveTransfer(start_, end_, address(0), address(this));\n    }\n\n    function initializeBulk(uint256 start_, uint256 end_, uint256 batchSize) external onlyRealOwner {\n        initializeBulkTo(start_, end_, batchSize, address(this));\n    }\n    \n    function initializeBulkTo(uint256 start_, uint256 end_, uint256 batchSize, address to_) public onlyRealOwner  {\n        require(end_ > start_, "ending token id must be larger than the starting token id");\n        require(end_ - start_ + 1 >= batchSize, "the range of tokens must be bigger than the desired batch size");\n        uint256 numOfBatches = (end_ - start_ + 1) / batchSize;\n        uint256 lastBatchSize = (end_ - start_ + 1) % batchSize;\n        for (uint256 i = 0; i < numOfBatches; i++) {\n            emit ConsecutiveTransfer(start_ + batchSize * i, start_ + batchSize * (i+1) - 1, address(0), to_);\n        }\n\n        if (lastBatchSize > 0) {\n            emit ConsecutiveTransfer(end_ - lastBatchSize + 1, end_, address(0), to_);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 286, 'end_line': 286, 'offset_start': 9237, 'offset_end': 9310, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 295, 'end_line': 295, 'offset_start': 9453, 'offset_end': 9524, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 311, 'end_line': 315, 'offset_start': 10226, 'offset_end': 10333, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 331, 'end_line': 335, 'offset_start': 10849, 'offset_end': 10952, 'content': 'function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 350, 'end_line': 350, 'offset_start': 11416, 'offset_end': 11470, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 359, 'end_line': 359, 'offset_start': 11621, 'offset_end': 11699, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 371, 'end_line': 371, 'offset_start': 12020, 'offset_end': 12089, 'content': 'function setApprovalForAll(address operator, bool _approved) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 378, 'end_line': 378, 'offset_start': 12239, 'offset_end': 12326, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 393, 'end_line': 398, 'offset_start': 12894, 'offset_end': 13030, 'content': 'function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;', 'contract_name': 'IERC721', 'contract_code': "{\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}", 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 415, 'end_line': 435, 'offset_start': 13363, 'offset_end': 14065, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\'s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return "0";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\'s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return "0";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return "0x00";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 440, 'end_line': 451, 'offset_start': 14171, 'offset_end': 14499, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return "0x00";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\'s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return "0";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return "0x00";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 456, 'end_line': 466, 'offset_start': 14623, 'offset_end': 15063, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant _HEX_SYMBOLS = "0123456789abcdef";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI\'s implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return "0";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return "0x00";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, "Strings: hex length insufficient");\n        return string(buffer);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 492, 'end_line': 492, 'offset_start': 15842, 'offset_end': 15917, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165.supportsInterface', 'start_line': 520, 'end_line': 522, 'offset_start': 16751, 'offset_end': 16905, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165', 'contract_code': '{\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'MultisigOwnable.tor', 'start_line': 541, 'end_line': 543, 'offset_start': 17476, 'offset_end': 17528, 'content': 'constructor() {\n        realOwner = msg.sender;\n    }', 'contract_name': 'MultisigOwnable', 'contract_code': '{\n    address public realOwner;\n\n    constructor() {\n        realOwner = msg.sender;\n    }\n\n    modifier onlyRealOwner() {\n        require(realOwner == msg.sender, "MultisigOwnable: caller is not the real owner");\n        _;\n    }\n\n    function transferRealOwnership(address newRealOwner) public onlyRealOwner {\n        realOwner = newRealOwner;\n    }\n\n    function transferLowerOwnership(address newOwner) public onlyRealOwner {\n        _transferOwnership(newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'MultisigOwnable.transferRealOwnership', 'start_line': 550, 'end_line': 552, 'offset_start': 17675, 'offset_end': 17789, 'content': 'function transferRealOwnership(address newRealOwner) public onlyRealOwner {\n        realOwner = newRealOwner;\n    }', 'contract_name': 'MultisigOwnable', 'contract_code': '{\n    address public realOwner;\n\n    constructor() {\n        realOwner = msg.sender;\n    }\n\n    modifier onlyRealOwner() {\n        require(realOwner == msg.sender, "MultisigOwnable: caller is not the real owner");\n        _;\n    }\n\n    function transferRealOwnership(address newRealOwner) public onlyRealOwner {\n        realOwner = newRealOwner;\n    }\n\n    function transferLowerOwnership(address newOwner) public onlyRealOwner {\n        _transferOwnership(newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'MultisigOwnable.transferLowerOwnership', 'start_line': 554, 'end_line': 556, 'offset_start': 17796, 'offset_end': 17911, 'content': 'function transferLowerOwnership(address newOwner) public onlyRealOwner {\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'MultisigOwnable', 'contract_code': '{\n    address public realOwner;\n\n    constructor() {\n        realOwner = msg.sender;\n    }\n\n    modifier onlyRealOwner() {\n        require(realOwner == msg.sender, "MultisigOwnable: caller is not the real owner");\n        _;\n    }\n\n    function transferRealOwnership(address newRealOwner) public onlyRealOwner {\n        realOwner = newRealOwner;\n    }\n\n    function transferLowerOwnership(address newOwner) public onlyRealOwner {\n        _transferOwnership(newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.tor', 'start_line': 586, 'end_line': 588, 'offset_start': 18813, 'offset_end': 18875, 'content': 'constructor() {\n        _transferOwnership(_msgSender());\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.owner', 'start_line': 593, 'end_line': 595, 'offset_start': 18952, 'offset_end': 19036, 'content': 'function owner() public view virtual returns (address) {\n        return _owner;\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.renounceOwnership', 'start_line': 612, 'end_line': 614, 'offset_start': 19584, 'offset_end': 19684, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable.transferOwnership', 'start_line': 620, 'end_line': 623, 'offset_start': 19834, 'offset_end': 20031, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
{'type': 'FunctionDefinition', 'name': 'Ownable._transferOwnership', 'start_line': 629, 'end_line': 633, 'offset_start': 20186, 'offset_end': 20372, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'Ownable', 'contract_code': '{\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), "Ownable: caller is not the owner");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), "Ownable: new owner is the zero address");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x36e5913bf48ccbd361875d09c0a20a4c144da896/0x36e5913bf48ccbd361875d09c0a20a4c144da896.sol'}
