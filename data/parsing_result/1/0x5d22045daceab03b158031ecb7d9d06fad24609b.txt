{'type': 'FunctionDefinition', 'name': 'MainDispatcherBase.', 'start_line': 31, 'end_line': 33, 'offset_start': 1086, 'offset_end': 1171, 'content': 'receive() external payable {\n        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");\n    }', 'contract_name': 'MainDispatcherBase', 'contract_code': '{\n    using Addresses for address;\n\n    /*\n      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).\n      We don\'t expect to receive such, thus block them.\n    */\n    receive() external payable {\n        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");\n    }\n\n    fallback() external payable {\n        address subContractAddress = getSubContract(msg.sig);\n        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don"t know the out size yet.\n            let result := delegatecall(gas(), subContractAddress, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /*\n      1. Extract subcontracts.\n      2. Verify correct sub-contract initializer size.\n      3. Extract sub-contract initializer data.\n      4. Call sub-contract initializer.\n\n      The init data bytes passed to initialize are structed as following:\n      I. N slots (uin256 size) addresses of the deployed sub-contracts.\n      II. An address of an external initialization contract (optional, or ZERO_ADDRESS).\n      III. (Up to) N bytes sections of the sub-contracts initializers.\n\n      If already initialized (i.e. upgrade) we expect the init data to be consistent with this.\n      and if a different size of init data is expected when upgrading, the initializerSize should\n      reflect this.\n\n      If an external initializer contract is not used, ZERO_ADDRESS is passed in its slot.\n      If the external initializer contract is used, all the remaining init data is passed to it,\n      and internal initialization will not occur.\n\n      External Initialization Contract\n      --------------------------------\n      External Initialization Contract (EIC) is a hook for custom initialization.\n      Typically in an upgrade flow, the expected initialization contains only the addresses of\n      the sub-contracts. Normal initialization of the sub-contracts is such that is not needed\n      in an upgrade, and actually may be very dangerous, as changing of state on a working system\n      may corrupt it.\n\n      In the event that some state initialization is required, the EIC is a hook that allows this.\n      It may be deployed and called specifically for this purpose.\n\n      The address of the EIC must be provided (if at all) when a new implementation is added to\n      a Proxy contract (as part of the initialization vector).\n      Hence, it is considered part of the code open to reviewers prior to a time-locked upgrade.\n\n      When a custom initialization is performed using an EIC,\n      the main dispatcher initialize extracts and stores the sub-contracts addresses, and then\n      yields to the EIC, skipping the rest of its initialization code.\n\n\n      Flow of MainDispatcher initialize\n      ---------------------------------\n      1. Extraction and assignment of subcontracts addresses\n         Main dispatcher expects a valid and consistent set of addresses in the passed data.\n         It validates that, extracts the addresses from the data, and validates that the addresses\n         are of the expected type and order. Then those addresses are stored.\n\n      2. Extraction of EIC address\n         The address of the EIC is extracted from the data.\n         External Initializer Contract is optional. ZERO_ADDRESS indicates it is not used.\n\n      3a. EIC is used\n          Dispatcher calls the EIC initialize function with the remaining data.\n          Note - In this option 3b is not performed.\n\n      3b. EIC is not used\n          If there is additional initialization data then:\n          I. Sentitenl function is called to permit subcontracts initialization.\n          II. Dispatcher loops through the subcontracts and for each one it extracts the\n              initializing data and passes it to the subcontract\'s initialize function.\n\n    */\n    function initialize(bytes calldata data) external virtual notCalledDirectly {\n        // Number of sub-contracts.\n        uint256 nSubContracts = getNumSubcontracts();\n\n        // We support currently 4 bits per contract, i.e. 16, reserving 00 leads to 15.\n        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");\n\n        // Sum of subcontract initializers. Aggregated for verification near the end.\n        uint256 totalInitSizes = 0;\n\n        // Offset (within data) of sub-contract initializer vector.\n        // Just past the sub-contract+eic addresses.\n        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);\n\n        // Init data MUST include addresses for all sub-contracts + EIC.\n        require(data.length >= initDataContractsOffset, "SUB_CONTRACTS_NOT_PROVIDED");\n\n        // Size of passed data, excluding sub-contract addresses.\n        uint256 additionalDataSize = data.length - initDataContractsOffset;\n\n        // Extract & update contract addresses.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            validateSubContractIndex(nContract, contractAddress);\n\n            // Contracts are indexed from 1 and 0 is not in use here.\n            setSubContractAddress(nContract, contractAddress);\n        }\n\n        // Check if we have an external initializer contract.\n        address externalInitializerAddr = abi.decode(\n            data[initDataContractsOffset - 32:initDataContractsOffset],\n            (address)\n        );\n\n        // 3(a). Yield to EIC initialization.\n        if (externalInitializerAddr != address(0x0)) {\n            callExternalInitializer(externalInitializerAddr, data[initDataContractsOffset:]);\n            return;\n        }\n\n        // 3(b). Subcontracts initialization.\n        // I. If no init data passed besides sub-contracts, return.\n        if (additionalDataSize == 0) {\n            return;\n        }\n\n        // Just to be on the safe side.\n        assert(externalInitializerAddr == address(0x0));\n\n        // II. Gate further initialization.\n        initializationSentinel();\n\n        // III. Loops through the subcontracts, extracts their data and calls their initializer.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            // The initializerSize is called via delegatecall, so that it can relate to the state,\n            // and not only to the new contract code. (e.g. return 0 if state-intialized else 192).\n            // NOLINTNEXTLINE: controlled-delegatecall low-level-calls calls-loop.\n            (bool success, bytes memory returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector)\n            );\n            require(success, string(returndata));\n            uint256 initSize = abi.decode(returndata, (uint256));\n            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n\n            if (initSize == 0) {\n                continue;\n            }\n\n            // Call sub-contract initializer.\n            // NOLINTNEXTLINE: controlled-delegatecall calls-loop.\n            (success, returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(\n                    this.initialize.selector,\n                    data[initDataContractsOffset:initDataContractsOffset + initSize]\n                )\n            );\n            require(success, string(returndata));\n            totalInitSizes += initSize;\n            initDataContractsOffset += initSize;\n        }\n        require(additionalDataSize == totalInitSizes, "MISMATCHING_INIT_DATA_SIZE");\n    }\n\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata extInitData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, extInitData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcherBase.', 'start_line': 35, 'end_line': 61, 'offset_start': 1178, 'offset_end': 2196, 'content': 'fallback() external payable {\n        address subContractAddress = getSubContract(msg.sig);\n        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don"t know the out size yet.\n            let result := delegatecall(gas(), subContractAddress, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }', 'contract_name': 'MainDispatcherBase', 'contract_code': '{\n    using Addresses for address;\n\n    /*\n      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).\n      We don\'t expect to receive such, thus block them.\n    */\n    receive() external payable {\n        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");\n    }\n\n    fallback() external payable {\n        address subContractAddress = getSubContract(msg.sig);\n        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don"t know the out size yet.\n            let result := delegatecall(gas(), subContractAddress, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /*\n      1. Extract subcontracts.\n      2. Verify correct sub-contract initializer size.\n      3. Extract sub-contract initializer data.\n      4. Call sub-contract initializer.\n\n      The init data bytes passed to initialize are structed as following:\n      I. N slots (uin256 size) addresses of the deployed sub-contracts.\n      II. An address of an external initialization contract (optional, or ZERO_ADDRESS).\n      III. (Up to) N bytes sections of the sub-contracts initializers.\n\n      If already initialized (i.e. upgrade) we expect the init data to be consistent with this.\n      and if a different size of init data is expected when upgrading, the initializerSize should\n      reflect this.\n\n      If an external initializer contract is not used, ZERO_ADDRESS is passed in its slot.\n      If the external initializer contract is used, all the remaining init data is passed to it,\n      and internal initialization will not occur.\n\n      External Initialization Contract\n      --------------------------------\n      External Initialization Contract (EIC) is a hook for custom initialization.\n      Typically in an upgrade flow, the expected initialization contains only the addresses of\n      the sub-contracts. Normal initialization of the sub-contracts is such that is not needed\n      in an upgrade, and actually may be very dangerous, as changing of state on a working system\n      may corrupt it.\n\n      In the event that some state initialization is required, the EIC is a hook that allows this.\n      It may be deployed and called specifically for this purpose.\n\n      The address of the EIC must be provided (if at all) when a new implementation is added to\n      a Proxy contract (as part of the initialization vector).\n      Hence, it is considered part of the code open to reviewers prior to a time-locked upgrade.\n\n      When a custom initialization is performed using an EIC,\n      the main dispatcher initialize extracts and stores the sub-contracts addresses, and then\n      yields to the EIC, skipping the rest of its initialization code.\n\n\n      Flow of MainDispatcher initialize\n      ---------------------------------\n      1. Extraction and assignment of subcontracts addresses\n         Main dispatcher expects a valid and consistent set of addresses in the passed data.\n         It validates that, extracts the addresses from the data, and validates that the addresses\n         are of the expected type and order. Then those addresses are stored.\n\n      2. Extraction of EIC address\n         The address of the EIC is extracted from the data.\n         External Initializer Contract is optional. ZERO_ADDRESS indicates it is not used.\n\n      3a. EIC is used\n          Dispatcher calls the EIC initialize function with the remaining data.\n          Note - In this option 3b is not performed.\n\n      3b. EIC is not used\n          If there is additional initialization data then:\n          I. Sentitenl function is called to permit subcontracts initialization.\n          II. Dispatcher loops through the subcontracts and for each one it extracts the\n              initializing data and passes it to the subcontract\'s initialize function.\n\n    */\n    function initialize(bytes calldata data) external virtual notCalledDirectly {\n        // Number of sub-contracts.\n        uint256 nSubContracts = getNumSubcontracts();\n\n        // We support currently 4 bits per contract, i.e. 16, reserving 00 leads to 15.\n        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");\n\n        // Sum of subcontract initializers. Aggregated for verification near the end.\n        uint256 totalInitSizes = 0;\n\n        // Offset (within data) of sub-contract initializer vector.\n        // Just past the sub-contract+eic addresses.\n        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);\n\n        // Init data MUST include addresses for all sub-contracts + EIC.\n        require(data.length >= initDataContractsOffset, "SUB_CONTRACTS_NOT_PROVIDED");\n\n        // Size of passed data, excluding sub-contract addresses.\n        uint256 additionalDataSize = data.length - initDataContractsOffset;\n\n        // Extract & update contract addresses.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            validateSubContractIndex(nContract, contractAddress);\n\n            // Contracts are indexed from 1 and 0 is not in use here.\n            setSubContractAddress(nContract, contractAddress);\n        }\n\n        // Check if we have an external initializer contract.\n        address externalInitializerAddr = abi.decode(\n            data[initDataContractsOffset - 32:initDataContractsOffset],\n            (address)\n        );\n\n        // 3(a). Yield to EIC initialization.\n        if (externalInitializerAddr != address(0x0)) {\n            callExternalInitializer(externalInitializerAddr, data[initDataContractsOffset:]);\n            return;\n        }\n\n        // 3(b). Subcontracts initialization.\n        // I. If no init data passed besides sub-contracts, return.\n        if (additionalDataSize == 0) {\n            return;\n        }\n\n        // Just to be on the safe side.\n        assert(externalInitializerAddr == address(0x0));\n\n        // II. Gate further initialization.\n        initializationSentinel();\n\n        // III. Loops through the subcontracts, extracts their data and calls their initializer.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            // The initializerSize is called via delegatecall, so that it can relate to the state,\n            // and not only to the new contract code. (e.g. return 0 if state-intialized else 192).\n            // NOLINTNEXTLINE: controlled-delegatecall low-level-calls calls-loop.\n            (bool success, bytes memory returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector)\n            );\n            require(success, string(returndata));\n            uint256 initSize = abi.decode(returndata, (uint256));\n            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n\n            if (initSize == 0) {\n                continue;\n            }\n\n            // Call sub-contract initializer.\n            // NOLINTNEXTLINE: controlled-delegatecall calls-loop.\n            (success, returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(\n                    this.initialize.selector,\n                    data[initDataContractsOffset:initDataContractsOffset + initSize]\n                )\n            );\n            require(success, string(returndata));\n            totalInitSizes += initSize;\n            initDataContractsOffset += initSize;\n        }\n        require(additionalDataSize == totalInitSizes, "MISMATCHING_INIT_DATA_SIZE");\n    }\n\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata extInitData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, extInitData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcherBase.initialize', 'start_line': 124, 'end_line': 218, 'offset_start': 5377, 'offset_end': 9499, 'content': 'function initialize(bytes calldata data) external virtual notCalledDirectly {\n        // Number of sub-contracts.\n        uint256 nSubContracts = getNumSubcontracts();\n\n        // We support currently 4 bits per contract, i.e. 16, reserving 00 leads to 15.\n        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");\n\n        // Sum of subcontract initializers. Aggregated for verification near the end.\n        uint256 totalInitSizes = 0;\n\n        // Offset (within data) of sub-contract initializer vector.\n        // Just past the sub-contract+eic addresses.\n        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);\n\n        // Init data MUST include addresses for all sub-contracts + EIC.\n        require(data.length >= initDataContractsOffset, "SUB_CONTRACTS_NOT_PROVIDED");\n\n        // Size of passed data, excluding sub-contract addresses.\n        uint256 additionalDataSize = data.length - initDataContractsOffset;\n\n        // Extract & update contract addresses.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            validateSubContractIndex(nContract, contractAddress);\n\n            // Contracts are indexed from 1 and 0 is not in use here.\n            setSubContractAddress(nContract, contractAddress);\n        }\n\n        // Check if we have an external initializer contract.\n        address externalInitializerAddr = abi.decode(\n            data[initDataContractsOffset - 32:initDataContractsOffset],\n            (address)\n        );\n\n        // 3(a). Yield to EIC initialization.\n        if (externalInitializerAddr != address(0x0)) {\n            callExternalInitializer(externalInitializerAddr, data[initDataContractsOffset:]);\n            return;\n        }\n\n        // 3(b). Subcontracts initialization.\n        // I. If no init data passed besides sub-contracts, return.\n        if (additionalDataSize == 0) {\n            return;\n        }\n\n        // Just to be on the safe side.\n        assert(externalInitializerAddr == address(0x0));\n\n        // II. Gate further initialization.\n        initializationSentinel();\n\n        // III. Loops through the subcontracts, extracts their data and calls their initializer.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            // The initializerSize is called via delegatecall, so that it can relate to the state,\n            // and not only to the new contract code. (e.g. return 0 if state-intialized else 192).\n            // NOLINTNEXTLINE: controlled-delegatecall low-level-calls calls-loop.\n            (bool success, bytes memory returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector)\n            );\n            require(success, string(returndata));\n            uint256 initSize = abi.decode(returndata, (uint256));\n            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n\n            if (initSize == 0) {\n                continue;\n            }\n\n            // Call sub-contract initializer.\n            // NOLINTNEXTLINE: controlled-delegatecall calls-loop.\n            (success, returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(\n                    this.initialize.selector,\n                    data[initDataContractsOffset:initDataContractsOffset + initSize]\n                )\n            );\n            require(success, string(returndata));\n            totalInitSizes += initSize;\n            initDataContractsOffset += initSize;\n        }\n        require(additionalDataSize == totalInitSizes, "MISMATCHING_INIT_DATA_SIZE");\n    }', 'contract_name': 'MainDispatcherBase', 'contract_code': '{\n    using Addresses for address;\n\n    /*\n      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).\n      We don\'t expect to receive such, thus block them.\n    */\n    receive() external payable {\n        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");\n    }\n\n    fallback() external payable {\n        address subContractAddress = getSubContract(msg.sig);\n        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don"t know the out size yet.\n            let result := delegatecall(gas(), subContractAddress, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /*\n      1. Extract subcontracts.\n      2. Verify correct sub-contract initializer size.\n      3. Extract sub-contract initializer data.\n      4. Call sub-contract initializer.\n\n      The init data bytes passed to initialize are structed as following:\n      I. N slots (uin256 size) addresses of the deployed sub-contracts.\n      II. An address of an external initialization contract (optional, or ZERO_ADDRESS).\n      III. (Up to) N bytes sections of the sub-contracts initializers.\n\n      If already initialized (i.e. upgrade) we expect the init data to be consistent with this.\n      and if a different size of init data is expected when upgrading, the initializerSize should\n      reflect this.\n\n      If an external initializer contract is not used, ZERO_ADDRESS is passed in its slot.\n      If the external initializer contract is used, all the remaining init data is passed to it,\n      and internal initialization will not occur.\n\n      External Initialization Contract\n      --------------------------------\n      External Initialization Contract (EIC) is a hook for custom initialization.\n      Typically in an upgrade flow, the expected initialization contains only the addresses of\n      the sub-contracts. Normal initialization of the sub-contracts is such that is not needed\n      in an upgrade, and actually may be very dangerous, as changing of state on a working system\n      may corrupt it.\n\n      In the event that some state initialization is required, the EIC is a hook that allows this.\n      It may be deployed and called specifically for this purpose.\n\n      The address of the EIC must be provided (if at all) when a new implementation is added to\n      a Proxy contract (as part of the initialization vector).\n      Hence, it is considered part of the code open to reviewers prior to a time-locked upgrade.\n\n      When a custom initialization is performed using an EIC,\n      the main dispatcher initialize extracts and stores the sub-contracts addresses, and then\n      yields to the EIC, skipping the rest of its initialization code.\n\n\n      Flow of MainDispatcher initialize\n      ---------------------------------\n      1. Extraction and assignment of subcontracts addresses\n         Main dispatcher expects a valid and consistent set of addresses in the passed data.\n         It validates that, extracts the addresses from the data, and validates that the addresses\n         are of the expected type and order. Then those addresses are stored.\n\n      2. Extraction of EIC address\n         The address of the EIC is extracted from the data.\n         External Initializer Contract is optional. ZERO_ADDRESS indicates it is not used.\n\n      3a. EIC is used\n          Dispatcher calls the EIC initialize function with the remaining data.\n          Note - In this option 3b is not performed.\n\n      3b. EIC is not used\n          If there is additional initialization data then:\n          I. Sentitenl function is called to permit subcontracts initialization.\n          II. Dispatcher loops through the subcontracts and for each one it extracts the\n              initializing data and passes it to the subcontract\'s initialize function.\n\n    */\n    function initialize(bytes calldata data) external virtual notCalledDirectly {\n        // Number of sub-contracts.\n        uint256 nSubContracts = getNumSubcontracts();\n\n        // We support currently 4 bits per contract, i.e. 16, reserving 00 leads to 15.\n        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");\n\n        // Sum of subcontract initializers. Aggregated for verification near the end.\n        uint256 totalInitSizes = 0;\n\n        // Offset (within data) of sub-contract initializer vector.\n        // Just past the sub-contract+eic addresses.\n        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);\n\n        // Init data MUST include addresses for all sub-contracts + EIC.\n        require(data.length >= initDataContractsOffset, "SUB_CONTRACTS_NOT_PROVIDED");\n\n        // Size of passed data, excluding sub-contract addresses.\n        uint256 additionalDataSize = data.length - initDataContractsOffset;\n\n        // Extract & update contract addresses.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            validateSubContractIndex(nContract, contractAddress);\n\n            // Contracts are indexed from 1 and 0 is not in use here.\n            setSubContractAddress(nContract, contractAddress);\n        }\n\n        // Check if we have an external initializer contract.\n        address externalInitializerAddr = abi.decode(\n            data[initDataContractsOffset - 32:initDataContractsOffset],\n            (address)\n        );\n\n        // 3(a). Yield to EIC initialization.\n        if (externalInitializerAddr != address(0x0)) {\n            callExternalInitializer(externalInitializerAddr, data[initDataContractsOffset:]);\n            return;\n        }\n\n        // 3(b). Subcontracts initialization.\n        // I. If no init data passed besides sub-contracts, return.\n        if (additionalDataSize == 0) {\n            return;\n        }\n\n        // Just to be on the safe side.\n        assert(externalInitializerAddr == address(0x0));\n\n        // II. Gate further initialization.\n        initializationSentinel();\n\n        // III. Loops through the subcontracts, extracts their data and calls their initializer.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            // The initializerSize is called via delegatecall, so that it can relate to the state,\n            // and not only to the new contract code. (e.g. return 0 if state-intialized else 192).\n            // NOLINTNEXTLINE: controlled-delegatecall low-level-calls calls-loop.\n            (bool success, bytes memory returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector)\n            );\n            require(success, string(returndata));\n            uint256 initSize = abi.decode(returndata, (uint256));\n            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n\n            if (initSize == 0) {\n                continue;\n            }\n\n            // Call sub-contract initializer.\n            // NOLINTNEXTLINE: controlled-delegatecall calls-loop.\n            (success, returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(\n                    this.initialize.selector,\n                    data[initDataContractsOffset:initDataContractsOffset + initSize]\n                )\n            );\n            require(success, string(returndata));\n            totalInitSizes += initSize;\n            initDataContractsOffset += initSize;\n        }\n        require(additionalDataSize == totalInitSizes, "MISMATCHING_INIT_DATA_SIZE");\n    }\n\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata extInitData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, extInitData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcherBase.callExternalInitializer', 'start_line': 220, 'end_line': 231, 'offset_start': 9506, 'offset_end': 10049, 'content': 'function callExternalInitializer(address externalInitializerAddr, bytes calldata extInitData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, extInitData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }', 'contract_name': 'MainDispatcherBase', 'contract_code': '{\n    using Addresses for address;\n\n    /*\n      This entry point serves only transactions with empty calldata. (i.e. pure value transfer tx).\n      We don\'t expect to receive such, thus block them.\n    */\n    receive() external payable {\n        revert("CONTRACT_NOT_EXPECTED_TO_RECEIVE");\n    }\n\n    fallback() external payable {\n        address subContractAddress = getSubContract(msg.sig);\n        require(subContractAddress != address(0x0), "NO_CONTRACT_FOR_FUNCTION");\n\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 for now, as we don"t know the out size yet.\n            let result := delegatecall(gas(), subContractAddress, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /*\n      1. Extract subcontracts.\n      2. Verify correct sub-contract initializer size.\n      3. Extract sub-contract initializer data.\n      4. Call sub-contract initializer.\n\n      The init data bytes passed to initialize are structed as following:\n      I. N slots (uin256 size) addresses of the deployed sub-contracts.\n      II. An address of an external initialization contract (optional, or ZERO_ADDRESS).\n      III. (Up to) N bytes sections of the sub-contracts initializers.\n\n      If already initialized (i.e. upgrade) we expect the init data to be consistent with this.\n      and if a different size of init data is expected when upgrading, the initializerSize should\n      reflect this.\n\n      If an external initializer contract is not used, ZERO_ADDRESS is passed in its slot.\n      If the external initializer contract is used, all the remaining init data is passed to it,\n      and internal initialization will not occur.\n\n      External Initialization Contract\n      --------------------------------\n      External Initialization Contract (EIC) is a hook for custom initialization.\n      Typically in an upgrade flow, the expected initialization contains only the addresses of\n      the sub-contracts. Normal initialization of the sub-contracts is such that is not needed\n      in an upgrade, and actually may be very dangerous, as changing of state on a working system\n      may corrupt it.\n\n      In the event that some state initialization is required, the EIC is a hook that allows this.\n      It may be deployed and called specifically for this purpose.\n\n      The address of the EIC must be provided (if at all) when a new implementation is added to\n      a Proxy contract (as part of the initialization vector).\n      Hence, it is considered part of the code open to reviewers prior to a time-locked upgrade.\n\n      When a custom initialization is performed using an EIC,\n      the main dispatcher initialize extracts and stores the sub-contracts addresses, and then\n      yields to the EIC, skipping the rest of its initialization code.\n\n\n      Flow of MainDispatcher initialize\n      ---------------------------------\n      1. Extraction and assignment of subcontracts addresses\n         Main dispatcher expects a valid and consistent set of addresses in the passed data.\n         It validates that, extracts the addresses from the data, and validates that the addresses\n         are of the expected type and order. Then those addresses are stored.\n\n      2. Extraction of EIC address\n         The address of the EIC is extracted from the data.\n         External Initializer Contract is optional. ZERO_ADDRESS indicates it is not used.\n\n      3a. EIC is used\n          Dispatcher calls the EIC initialize function with the remaining data.\n          Note - In this option 3b is not performed.\n\n      3b. EIC is not used\n          If there is additional initialization data then:\n          I. Sentitenl function is called to permit subcontracts initialization.\n          II. Dispatcher loops through the subcontracts and for each one it extracts the\n              initializing data and passes it to the subcontract\'s initialize function.\n\n    */\n    function initialize(bytes calldata data) external virtual notCalledDirectly {\n        // Number of sub-contracts.\n        uint256 nSubContracts = getNumSubcontracts();\n\n        // We support currently 4 bits per contract, i.e. 16, reserving 00 leads to 15.\n        require(nSubContracts <= 15, "TOO_MANY_SUB_CONTRACTS");\n\n        // Sum of subcontract initializers. Aggregated for verification near the end.\n        uint256 totalInitSizes = 0;\n\n        // Offset (within data) of sub-contract initializer vector.\n        // Just past the sub-contract+eic addresses.\n        uint256 initDataContractsOffset = 32 * (nSubContracts + 1);\n\n        // Init data MUST include addresses for all sub-contracts + EIC.\n        require(data.length >= initDataContractsOffset, "SUB_CONTRACTS_NOT_PROVIDED");\n\n        // Size of passed data, excluding sub-contract addresses.\n        uint256 additionalDataSize = data.length - initDataContractsOffset;\n\n        // Extract & update contract addresses.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            validateSubContractIndex(nContract, contractAddress);\n\n            // Contracts are indexed from 1 and 0 is not in use here.\n            setSubContractAddress(nContract, contractAddress);\n        }\n\n        // Check if we have an external initializer contract.\n        address externalInitializerAddr = abi.decode(\n            data[initDataContractsOffset - 32:initDataContractsOffset],\n            (address)\n        );\n\n        // 3(a). Yield to EIC initialization.\n        if (externalInitializerAddr != address(0x0)) {\n            callExternalInitializer(externalInitializerAddr, data[initDataContractsOffset:]);\n            return;\n        }\n\n        // 3(b). Subcontracts initialization.\n        // I. If no init data passed besides sub-contracts, return.\n        if (additionalDataSize == 0) {\n            return;\n        }\n\n        // Just to be on the safe side.\n        assert(externalInitializerAddr == address(0x0));\n\n        // II. Gate further initialization.\n        initializationSentinel();\n\n        // III. Loops through the subcontracts, extracts their data and calls their initializer.\n        for (uint256 nContract = 1; nContract <= nSubContracts; nContract++) {\n            // Extract sub-contract address.\n            address contractAddress = abi.decode(\n                data[32 * (nContract - 1):32 * nContract],\n                (address)\n            );\n\n            // The initializerSize is called via delegatecall, so that it can relate to the state,\n            // and not only to the new contract code. (e.g. return 0 if state-intialized else 192).\n            // NOLINTNEXTLINE: controlled-delegatecall low-level-calls calls-loop.\n            (bool success, bytes memory returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(SubContractor(contractAddress).initializerSize.selector)\n            );\n            require(success, string(returndata));\n            uint256 initSize = abi.decode(returndata, (uint256));\n            require(initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n            require(totalInitSizes + initSize <= additionalDataSize, "INVALID_INITIALIZER_SIZE");\n\n            if (initSize == 0) {\n                continue;\n            }\n\n            // Call sub-contract initializer.\n            // NOLINTNEXTLINE: controlled-delegatecall calls-loop.\n            (success, returndata) = contractAddress.delegatecall(\n                abi.encodeWithSelector(\n                    this.initialize.selector,\n                    data[initDataContractsOffset:initDataContractsOffset + initSize]\n                )\n            );\n            require(success, string(returndata));\n            totalInitSizes += initSize;\n            initDataContractsOffset += initSize;\n        }\n        require(additionalDataSize == totalInitSizes, "MISMATCHING_INIT_DATA_SIZE");\n    }\n\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata extInitData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), "NOT_A_CONTRACT");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, extInitData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'StarkExchange.getNumSubcontracts', 'start_line': 267, 'end_line': 269, 'offset_start': 11531, 'offset_end': 11626, 'content': 'function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }', 'contract_name': 'StarkExchange', 'contract_code': '{\n    string public constant VERSION = "4.5.2-bl";\n\n    // Salt for a 8 bit unique spread of all relevant selectors. Pre-caclulated.\n    // ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n    uint256 constant MAGIC_SALT = 3548735;\n    uint256 constant IDX_MAP_0 = 0x2002000001052120022000230001320000120003000005400010002000000225;\n    uint256 constant IDX_MAP_1 = 0x5303000002002010520200113001010101000000000130050030000020021050;\n    uint256 constant IDX_MAP_2 = 0x2100221120103200050010000000050000002006022030052200200020020003;\n    uint256 constant IDX_MAP_3 = 0x210003200050000000103520000201500240120000002000200300430020004;\n\n    // ---------- End of auto-generated code. ----------\n\n    function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }\n\n    function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }\n\n    function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }\n\n    function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }\n\n    function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'StarkExchange.magicSalt', 'start_line': 271, 'end_line': 273, 'offset_start': 11633, 'offset_end': 11728, 'content': 'function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }', 'contract_name': 'StarkExchange', 'contract_code': '{\n    string public constant VERSION = "4.5.2-bl";\n\n    // Salt for a 8 bit unique spread of all relevant selectors. Pre-caclulated.\n    // ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n    uint256 constant MAGIC_SALT = 3548735;\n    uint256 constant IDX_MAP_0 = 0x2002000001052120022000230001320000120003000005400010002000000225;\n    uint256 constant IDX_MAP_1 = 0x5303000002002010520200113001010101000000000130050030000020021050;\n    uint256 constant IDX_MAP_2 = 0x2100221120103200050010000000050000002006022030052200200020020003;\n    uint256 constant IDX_MAP_3 = 0x210003200050000000103520000201500240120000002000200300430020004;\n\n    // ---------- End of auto-generated code. ----------\n\n    function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }\n\n    function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }\n\n    function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }\n\n    function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }\n\n    function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'StarkExchange.handlerMapSection', 'start_line': 275, 'end_line': 286, 'offset_start': 11735, 'offset_end': 12128, 'content': 'function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }', 'contract_name': 'StarkExchange', 'contract_code': '{\n    string public constant VERSION = "4.5.2-bl";\n\n    // Salt for a 8 bit unique spread of all relevant selectors. Pre-caclulated.\n    // ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n    uint256 constant MAGIC_SALT = 3548735;\n    uint256 constant IDX_MAP_0 = 0x2002000001052120022000230001320000120003000005400010002000000225;\n    uint256 constant IDX_MAP_1 = 0x5303000002002010520200113001010101000000000130050030000020021050;\n    uint256 constant IDX_MAP_2 = 0x2100221120103200050010000000050000002006022030052200200020020003;\n    uint256 constant IDX_MAP_3 = 0x210003200050000000103520000201500240120000002000200300430020004;\n\n    // ---------- End of auto-generated code. ----------\n\n    function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }\n\n    function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }\n\n    function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }\n\n    function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }\n\n    function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'StarkExchange.expectedIdByIndex', 'start_line': 288, 'end_line': 304, 'offset_start': 12135, 'offset_end': 12795, 'content': 'function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }', 'contract_name': 'StarkExchange', 'contract_code': '{\n    string public constant VERSION = "4.5.2-bl";\n\n    // Salt for a 8 bit unique spread of all relevant selectors. Pre-caclulated.\n    // ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n    uint256 constant MAGIC_SALT = 3548735;\n    uint256 constant IDX_MAP_0 = 0x2002000001052120022000230001320000120003000005400010002000000225;\n    uint256 constant IDX_MAP_1 = 0x5303000002002010520200113001010101000000000130050030000020021050;\n    uint256 constant IDX_MAP_2 = 0x2100221120103200050010000000050000002006022030052200200020020003;\n    uint256 constant IDX_MAP_3 = 0x210003200050000000103520000201500240120000002000200300430020004;\n\n    // ---------- End of auto-generated code. ----------\n\n    function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }\n\n    function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }\n\n    function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }\n\n    function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }\n\n    function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'StarkExchange.initializationSentinel', 'start_line': 306, 'end_line': 316, 'offset_start': 12802, 'offset_end': 13369, 'content': 'function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }', 'contract_name': 'StarkExchange', 'contract_code': '{\n    string public constant VERSION = "4.5.2-bl";\n\n    // Salt for a 8 bit unique spread of all relevant selectors. Pre-caclulated.\n    // ---------- The following code was auto-generated. PLEASE DO NOT EDIT. ----------\n    uint256 constant MAGIC_SALT = 3548735;\n    uint256 constant IDX_MAP_0 = 0x2002000001052120022000230001320000120003000005400010002000000225;\n    uint256 constant IDX_MAP_1 = 0x5303000002002010520200113001010101000000000130050030000020021050;\n    uint256 constant IDX_MAP_2 = 0x2100221120103200050010000000050000002006022030052200200020020003;\n    uint256 constant IDX_MAP_3 = 0x210003200050000000103520000201500240120000002000200300430020004;\n\n    // ---------- End of auto-generated code. ----------\n\n    function getNumSubcontracts() internal pure override returns (uint256) {\n        return 6;\n    }\n\n    function magicSalt() internal pure override returns (uint256) {\n        return MAGIC_SALT;\n    }\n\n    function handlerMapSection(uint256 section) internal pure override returns (uint256) {\n        if (section == 0) {\n            return IDX_MAP_0;\n        } else if (section == 1) {\n            return IDX_MAP_1;\n        } else if (section == 2) {\n            return IDX_MAP_2;\n        } else if (section == 3) {\n            return IDX_MAP_3;\n        }\n        revert("BAD_IDX_MAP_SECTION");\n    }\n\n    function expectedIdByIndex(uint256 index) internal pure override returns (string memory id) {\n        if (index == 1) {\n            id = "StarkWare_AllVerifiers_2022_2";\n        } else if (index == 2) {\n            id = "StarkWare_TokensAndRamping_2024_3";\n        } else if (index == 3) {\n            id = "StarkWare_StarkExState_2022_5";\n        } else if (index == 4) {\n            id = "StarkWare_ForcedActions_2022_3";\n        } else if (index == 5) {\n            id = "StarkWare_OnchainVaults_2022_2";\n        } else if (index == 6) {\n            id = "StarkWare_ProxyUtils_2022_2";\n        } else {\n            revert("UNEXPECTED_INDEX");\n        }\n    }\n\n    function initializationSentinel() internal view override {\n        string memory REVERT_MSG = "INITIALIZATION_BLOCKED";\n        // This initializer sets roots etc. It must not be applied twice.\n        // I.e. it can run only when the state is still empty.\n        require(validiumVaultRoot == 0, REVERT_MSG);\n        require(validiumTreeHeight == 0, REVERT_MSG);\n        require(rollupVaultRoot == 0, REVERT_MSG);\n        require(rollupTreeHeight == 0, REVERT_MSG);\n        require(orderRoot == 0, REVERT_MSG);\n        require(orderTreeHeight == 0, REVERT_MSG);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'BlockDirectCall.tor', 'start_line': 346, 'end_line': 348, 'offset_start': 14410, 'offset_end': 14470, 'content': 'constructor() internal {\n        this_ = address(this);\n    }', 'contract_name': 'BlockDirectCall', 'contract_code': '{\n    address immutable this_;\n\n    constructor() internal {\n        this_ = address(this);\n    }\n\n    modifier notCalledDirectly() {\n        require(this_ != address(this), "DIRECT_CALL_DISALLOWED");\n        _;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'Addresses.isContract', 'start_line': 379, 'end_line': 385, 'offset_start': 15352, 'offset_end': 15541, 'content': 'function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }', 'contract_name': 'Addresses', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(""); // NOLINT: low-level-calls.\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\'t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n        }\n    }\n\n    /*\n      Validates that the passed contract address is of a real contract,\n      and that its id hash (as infered fromn identify()) matched the expected one.\n    */\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), "ADDRESS_NOT_CONTRACT");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature("identify()")\n        );\n        require(success, "FAILED_TO_IDENTIFY_CONTRACT");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            "UNEXPECTED_CONTRACT_IDENTIFIER"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'Addresses.performEthTransfer', 'start_line': 387, 'end_line': 390, 'offset_start': 15548, 'offset_end': 15765, 'content': 'function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(""); // NOLINT: low-level-calls.\n        require(success, "ETH_TRANSFER_FAILED");\n    }', 'contract_name': 'Addresses', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(""); // NOLINT: low-level-calls.\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\'t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n        }\n    }\n\n    /*\n      Validates that the passed contract address is of a real contract,\n      and that its id hash (as infered fromn identify()) matched the expected one.\n    */\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), "ADDRESS_NOT_CONTRACT");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature("identify()")\n        );\n        require(success, "FAILED_TO_IDENTIFY_CONTRACT");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            "UNEXPECTED_CONTRACT_IDENTIFIER"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'Addresses.safeTokenContractCall', 'start_line': 397, 'end_line': 406, 'offset_start': 15975, 'offset_end': 16426, 'content': 'function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n        }\n    }', 'contract_name': 'Addresses', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(""); // NOLINT: low-level-calls.\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\'t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n        }\n    }\n\n    /*\n      Validates that the passed contract address is of a real contract,\n      and that its id hash (as infered fromn identify()) matched the expected one.\n    */\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), "ADDRESS_NOT_CONTRACT");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature("identify()")\n        );\n        require(success, "FAILED_TO_IDENTIFY_CONTRACT");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            "UNEXPECTED_CONTRACT_IDENTIFIER"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'Addresses.validateContractId', 'start_line': 412, 'end_line': 423, 'offset_start': 16602, 'offset_end': 17203, 'content': 'function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), "ADDRESS_NOT_CONTRACT");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature("identify()")\n        );\n        require(success, "FAILED_TO_IDENTIFY_CONTRACT");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            "UNEXPECTED_CONTRACT_IDENTIFIER"\n        );\n    }', 'contract_name': 'Addresses', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(""); // NOLINT: low-level-calls.\n        require(success, "ETH_TRANSFER_FAILED");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\'t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), "BAD_TOKEN_ADDRESS");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length > 0) {\n            require(abi.decode(returndata, (bool)), "TOKEN_OPERATION_FAILED");\n        }\n    }\n\n    /*\n      Validates that the passed contract address is of a real contract,\n      and that its id hash (as infered fromn identify()) matched the expected one.\n    */\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), "ADDRESS_NOT_CONTRACT");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature("identify()")\n        );\n        require(success, "FAILED_TO_IDENTIFY_CONTRACT");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            "UNEXPECTED_CONTRACT_IDENTIFIER"\n        );\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MGovernance._isGovernor', 'start_line': 471, 'end_line': 471, 'offset_start': 18975, 'offset_end': 19054, 'content': 'function _isGovernor(address testGovernor) internal view virtual returns (bool);', 'contract_name': 'MGovernance', 'contract_code': '{\n    function _isGovernor(address testGovernor) internal view virtual returns (bool);\n\n    /*\n      Allows calling the function only by a Governor.\n    */\n    modifier onlyGovernance() {\n        require(_isGovernor(msg.sender), "ONLY_GOVERNANCE");\n        _;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'SubContractor.initialize', 'start_line': 642, 'end_line': 642, 'offset_start': 25758, 'offset_end': 25807, 'content': 'function initialize(bytes calldata data) external;', 'contract_name': 'SubContractor', 'contract_code': '{\n    function initialize(bytes calldata data) external;\n\n    function initializerSize() external view returns (uint256);\n\n    /*\n      Returns an array with selectors for validation.\n      These selectors are the critical ones for maintaining self custody and anti censorship.\n      During the upgrade process, as part of the sub-contract validation, the MainDispatcher\n      validates that the selectos are mapped to the correct sub-contract.\n    */\n    function validatedSelectors() external pure returns (bytes4[] memory);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'SubContractor.initializerSize', 'start_line': 644, 'end_line': 644, 'offset_start': 25814, 'offset_end': 25872, 'content': 'function initializerSize() external view returns (uint256);', 'contract_name': 'SubContractor', 'contract_code': '{\n    function initialize(bytes calldata data) external;\n\n    function initializerSize() external view returns (uint256);\n\n    /*\n      Returns an array with selectors for validation.\n      These selectors are the critical ones for maintaining self custody and anti censorship.\n      During the upgrade process, as part of the sub-contract validation, the MainDispatcher\n      validates that the selectos are mapped to the correct sub-contract.\n    */\n    function validatedSelectors() external pure returns (bytes4[] memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'SubContractor.validatedSelectors', 'start_line': 652, 'end_line': 652, 'offset_start': 26208, 'offset_end': 26277, 'content': 'function validatedSelectors() external pure returns (bytes4[] memory);', 'contract_name': 'SubContractor', 'contract_code': '{\n    function initialize(bytes calldata data) external;\n\n    function initializerSize() external view returns (uint256);\n\n    /*\n      Returns an array with selectors for validation.\n      These selectors are the critical ones for maintaining self custody and anti censorship.\n      During the upgrade process, as part of the sub-contract validation, the MainDispatcher\n      validates that the selectos are mapped to the correct sub-contract.\n    */\n    function validatedSelectors() external pure returns (bytes4[] memory);\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.magicSalt', 'start_line': 679, 'end_line': 679, 'offset_start': 27138, 'offset_end': 27198, 'content': 'function magicSalt() internal pure virtual returns (uint256);', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.handlerMapSection', 'start_line': 681, 'end_line': 681, 'offset_start': 27205, 'offset_end': 27288, 'content': 'function handlerMapSection(uint256 section) internal pure virtual returns (uint256);', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.expectedIdByIndex', 'start_line': 683, 'end_line': 683, 'offset_start': 27295, 'offset_end': 27385, 'content': 'function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.validateSubContractIndex', 'start_line': 685, 'end_line': 703, 'offset_start': 27392, 'offset_end': 28260, 'content': 'function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.handlingContractId', 'start_line': 705, 'end_line': 708, 'offset_start': 28267, 'offset_end': 28463, 'content': 'function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.getSubContractIndex', 'start_line': 719, 'end_line': 725, 'offset_start': 28919, 'offset_end': 29316, 'content': 'function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.getSubContract', 'start_line': 731, 'end_line': 733, 'offset_start': 29475, 'offset_end': 29621, 'content': 'function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'MainDispatcher.setSubContractAddress', 'start_line': 735, 'end_line': 737, 'offset_start': 29628, 'offset_end': 29776, 'content': 'function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }', 'contract_name': 'MainDispatcher', 'contract_code': '{\n    uint256 constant SUBCONTRACT_BITS = 4;\n\n    function magicSalt() internal pure virtual returns (uint256);\n\n    function handlerMapSection(uint256 section) internal pure virtual returns (uint256);\n\n    function expectedIdByIndex(uint256 index) internal pure virtual returns (string memory id);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure override {\n        string memory id = SubContractor(subContract).identify();\n        bytes32 hashed_expected_id = keccak256(abi.encodePacked(expectedIdByIndex(index)));\n        require(\n            hashed_expected_id == keccak256(abi.encodePacked(id)),\n            "MISPLACED_INDEX_OR_BAD_CONTRACT_ID"\n        );\n\n        // Gets the list of critical selectors from the sub-contract and checks that the selector\n        // is mapped to that sub-contract.\n        bytes4[] memory selectorsToValidate = SubContractor(subContract).validatedSelectors();\n\n        for (uint256 i = 0; i < selectorsToValidate.length; i++) {\n            require(\n                getSubContractIndex(selectorsToValidate[i]) == index,\n                "INCONSISTENT_DISPATCHER_MAP"\n            );\n        }\n    }\n\n    function handlingContractId(bytes4 selector) external pure virtual returns (string memory id) {\n        uint256 index = getSubContractIndex(selector);\n        return expectedIdByIndex(index);\n    }\n\n    /*\n      Returns the index in subContracts where the address of the sub-contract implementing\n      the function with the queried selector is held.\n\n      Note: The nature of the sub-contracts handler map is such that all the required selectors\n      are mapped. However, other selectors, such that are not implemented in any subcontract,\n      may also return a sub-contract address.\n      This behavior is by-design, and not a problem.\n    */\n    function getSubContractIndex(bytes4 selector) internal pure returns (uint256) {\n        uint256 location = 0xFF & uint256(keccak256(abi.encodePacked(selector, magicSalt())));\n        uint256 offset = (SUBCONTRACT_BITS * location) % 256;\n\n        // We have 64 locations in each register, hence the >> 6 (i.e. location // 64).\n        return (handlerMapSection(location >> 6) >> offset) & 0xF;\n    }\n\n    /*\n      Returns the address of the sub-contract that would be delegated to handle a call\n      with the queried selector. (see note above).\n    */\n    function getSubContract(bytes4 selector) public view override returns (address) {\n        return subContracts[getSubContractIndex(selector)];\n    }\n\n    function setSubContractAddress(uint256 index, address subContractAddress) internal override {\n        subContracts[index] = subContractAddress;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'Identity.identify', 'start_line': 763, 'end_line': 763, 'offset_start': 30612, 'offset_end': 30669, 'content': 'function identify() external pure returns (string memory);', 'contract_name': 'Identity', 'contract_code': '{\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify() external pure returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDispatcherBase.getSubContract', 'start_line': 856, 'end_line': 856, 'offset_start': 34186, 'offset_end': 34264, 'content': 'function getSubContract(bytes4 selector) public view virtual returns (address);', 'contract_name': 'IDispatcherBase', 'contract_code': '{\n    function getSubContract(bytes4 selector) public view virtual returns (address);\n\n    function setSubContractAddress(uint256 index, address subContract) internal virtual;\n\n    function getNumSubcontracts() internal pure virtual returns (uint256);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;\n\n    /*\n      Ensures initializer can be called. Reverts otherwise.\n    */\n    function initializationSentinel() internal view virtual;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDispatcherBase.setSubContractAddress', 'start_line': 858, 'end_line': 858, 'offset_start': 34271, 'offset_end': 34354, 'content': 'function setSubContractAddress(uint256 index, address subContract) internal virtual;', 'contract_name': 'IDispatcherBase', 'contract_code': '{\n    function getSubContract(bytes4 selector) public view virtual returns (address);\n\n    function setSubContractAddress(uint256 index, address subContract) internal virtual;\n\n    function getNumSubcontracts() internal pure virtual returns (uint256);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;\n\n    /*\n      Ensures initializer can be called. Reverts otherwise.\n    */\n    function initializationSentinel() internal view virtual;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDispatcherBase.getNumSubcontracts', 'start_line': 860, 'end_line': 860, 'offset_start': 34361, 'offset_end': 34430, 'content': 'function getNumSubcontracts() internal pure virtual returns (uint256);', 'contract_name': 'IDispatcherBase', 'contract_code': '{\n    function getSubContract(bytes4 selector) public view virtual returns (address);\n\n    function setSubContractAddress(uint256 index, address subContract) internal virtual;\n\n    function getNumSubcontracts() internal pure virtual returns (uint256);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;\n\n    /*\n      Ensures initializer can be called. Reverts otherwise.\n    */\n    function initializationSentinel() internal view virtual;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDispatcherBase.validateSubContractIndex', 'start_line': 862, 'end_line': 862, 'offset_start': 34437, 'offset_end': 34528, 'content': 'function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;', 'contract_name': 'IDispatcherBase', 'contract_code': '{\n    function getSubContract(bytes4 selector) public view virtual returns (address);\n\n    function setSubContractAddress(uint256 index, address subContract) internal virtual;\n\n    function getNumSubcontracts() internal pure virtual returns (uint256);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;\n\n    /*\n      Ensures initializer can be called. Reverts otherwise.\n    */\n    function initializationSentinel() internal view virtual;\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
{'type': 'FunctionDefinition', 'name': 'IDispatcherBase.initializationSentinel', 'start_line': 867, 'end_line': 867, 'offset_start': 34609, 'offset_end': 34664, 'content': 'function initializationSentinel() internal view virtual;', 'contract_name': 'IDispatcherBase', 'contract_code': '{\n    function getSubContract(bytes4 selector) public view virtual returns (address);\n\n    function setSubContractAddress(uint256 index, address subContract) internal virtual;\n\n    function getNumSubcontracts() internal pure virtual returns (uint256);\n\n    function validateSubContractIndex(uint256 index, address subContract) internal pure virtual;\n\n    /*\n      Ensures initializer can be called. Reverts otherwise.\n    */\n    function initializationSentinel() internal view virtual;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x5d22045daceab03b158031ecb7d9d06fad24609b/0x5d22045daceab03b158031ecb7d9d06fad24609b.sol'}
