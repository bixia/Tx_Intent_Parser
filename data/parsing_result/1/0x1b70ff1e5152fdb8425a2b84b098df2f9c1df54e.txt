{'type': 'FunctionDefinition', 'name': 'IStoneVault.deposit', 'start_line': 5, 'end_line': 5, 'offset_start': 85, 'offset_end': 149, 'content': 'function deposit() external payable returns (uint256 mintAmount);', 'contract_name': 'IStoneVault', 'contract_code': '{\n    function deposit() external payable returns (uint256 mintAmount);\n\n    function requestWithdraw(uint256 _shares) external;\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);\n\n    function cancelWithdraw(uint256 _shares) external;\n\n    function rollToNextRound() external;\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStoneVault.requestWithdraw', 'start_line': 7, 'end_line': 7, 'offset_start': 156, 'offset_end': 206, 'content': 'function requestWithdraw(uint256 _shares) external;', 'contract_name': 'IStoneVault', 'contract_code': '{\n    function deposit() external payable returns (uint256 mintAmount);\n\n    function requestWithdraw(uint256 _shares) external;\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);\n\n    function cancelWithdraw(uint256 _shares) external;\n\n    function rollToNextRound() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStoneVault.instantWithdraw', 'start_line': 9, 'end_line': 12, 'offset_start': 213, 'offset_end': 336, 'content': 'function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);', 'contract_name': 'IStoneVault', 'contract_code': '{\n    function deposit() external payable returns (uint256 mintAmount);\n\n    function requestWithdraw(uint256 _shares) external;\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);\n\n    function cancelWithdraw(uint256 _shares) external;\n\n    function rollToNextRound() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStoneVault.cancelWithdraw', 'start_line': 14, 'end_line': 14, 'offset_start': 343, 'offset_end': 392, 'content': 'function cancelWithdraw(uint256 _shares) external;', 'contract_name': 'IStoneVault', 'contract_code': '{\n    function deposit() external payable returns (uint256 mintAmount);\n\n    function requestWithdraw(uint256 _shares) external;\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);\n\n    function cancelWithdraw(uint256 _shares) external;\n\n    function rollToNextRound() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStoneVault.rollToNextRound', 'start_line': 16, 'end_line': 16, 'offset_start': 399, 'offset_end': 434, 'content': 'function rollToNextRound() external;', 'contract_name': 'IStoneVault', 'contract_code': '{\n    function deposit() external payable returns (uint256 mintAmount);\n\n    function requestWithdraw(uint256 _shares) external;\n\n    function instantWithdraw(\n        uint256 _amount,\n        uint256 _shares\n    ) external returns (uint256 actualWithdrawn);\n\n    function cancelWithdraw(uint256 _shares) external;\n\n    function rollToNextRound() external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard.tor', 'start_line': 57, 'end_line': 59, 'offset_start': 2236, 'offset_end': 2288, 'content': 'constructor() {\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantBefore', 'start_line': 74, 'end_line': 80, 'offset_start': 2775, 'offset_end': 3061, 'content': 'function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantAfter', 'start_line': 82, 'end_line': 86, 'offset_start': 3068, 'offset_end': 3276, 'content': 'function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._reentrancyGuardEntered', 'start_line': 92, 'end_line': 94, 'offset_start': 3456, 'offset_end': 3562, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot\'s contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler\'s defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction\'s gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'DepositBridge.tor', 'start_line': 119, 'end_line': 124, 'offset_start': 4156, 'offset_end': 4317, 'content': 'constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }', 'contract_name': 'DepositBridge', 'contract_code': '{\n    address public immutable stone;\n    address payable public immutable vault;\n\n    uint16 public immutable dstChainId;\n\n    event BridgeTo(\n        address indexed srcAddr,\n        bytes dstAddr,\n        uint256 etherAmount,\n        uint256 stoneAmount,\n        uint256 gasPaid\n    );\n\n    constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }\n\n    function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }\n\n    receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'DepositBridge.bridgeTo', 'start_line': 126, 'end_line': 137, 'offset_start': 4324, 'offset_end': 4644, 'content': 'function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }', 'contract_name': 'DepositBridge', 'contract_code': '{\n    address public immutable stone;\n    address payable public immutable vault;\n\n    uint16 public immutable dstChainId;\n\n    event BridgeTo(\n        address indexed srcAddr,\n        bytes dstAddr,\n        uint256 etherAmount,\n        uint256 stoneAmount,\n        uint256 gasPaid\n    );\n\n    constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }\n\n    function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }\n\n    receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'DepositBridge.bridge', 'start_line': 139, 'end_line': 168, 'offset_start': 4651, 'offset_end': 5510, 'content': 'function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }', 'contract_name': 'DepositBridge', 'contract_code': '{\n    address public immutable stone;\n    address payable public immutable vault;\n\n    uint16 public immutable dstChainId;\n\n    event BridgeTo(\n        address indexed srcAddr,\n        bytes dstAddr,\n        uint256 etherAmount,\n        uint256 stoneAmount,\n        uint256 gasPaid\n    );\n\n    constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }\n\n    function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }\n\n    receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'DepositBridge.estimateSendFee', 'start_line': 170, 'end_line': 182, 'offset_start': 5517, 'offset_end': 5869, 'content': 'function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }', 'contract_name': 'DepositBridge', 'contract_code': '{\n    address public immutable stone;\n    address payable public immutable vault;\n\n    uint16 public immutable dstChainId;\n\n    event BridgeTo(\n        address indexed srcAddr,\n        bytes dstAddr,\n        uint256 etherAmount,\n        uint256 stoneAmount,\n        uint256 gasPaid\n    );\n\n    constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }\n\n    function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }\n\n    receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'DepositBridge.', 'start_line': 184, 'end_line': 194, 'offset_start': 5876, 'offset_end': 6226, 'content': 'receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }', 'contract_name': 'DepositBridge', 'contract_code': '{\n    address public immutable stone;\n    address payable public immutable vault;\n\n    uint16 public immutable dstChainId;\n\n    event BridgeTo(\n        address indexed srcAddr,\n        bytes dstAddr,\n        uint256 etherAmount,\n        uint256 stoneAmount,\n        uint256 gasPaid\n    );\n\n    constructor(address _stone, address payable _vault, uint16 _dstChainId) {\n        stone = _stone;\n        vault = _vault;\n\n        dstChainId = _dstChainId;\n    }\n\n    function bridgeTo(\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable returns (uint256 stoneMinted) {\n        stoneMinted = bridge(\n            msg.sender,\n            _amount,\n            _dstAddress,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function bridge(\n        address _srcAddr,\n        uint256 _amount,\n        bytes calldata _dstAddress,\n        uint256 _gasPaidForCrossChain\n    ) public payable nonReentrant returns (uint256 stoneMinted) {\n        require(msg.value >= _amount + _gasPaidForCrossChain, "wrong amount");\n\n        IStoneVault stoneVault = IStoneVault(vault);\n        stoneMinted = stoneVault.deposit{value: _amount}();\n\n        IStone stoneToken = IStone(stone);\n        stoneToken.sendFrom{value: _gasPaidForCrossChain}(\n            address(this),\n            dstChainId,\n            _dstAddress,\n            stoneMinted,\n            payable(_srcAddr),\n            address(0),\n            bytes("")\n        );\n\n        emit BridgeTo(\n            _srcAddr,\n            _dstAddress,\n            _amount,\n            stoneMinted,\n            _gasPaidForCrossChain\n        );\n    }\n\n    function estimateSendFee(\n        uint256 _amount,\n        bytes calldata _dstAddress\n    ) public view returns (uint nativeFee, uint zroFee) {\n        return\n            IStone(stone).estimateSendFee(\n                dstChainId,\n                _dstAddress,\n                _amount,\n                false,\n                bytes("")\n            );\n    }\n\n    receive() external payable {\n        bytes memory dstAddr = abi.encodePacked(msg.sender);\n\n        (uint nativeFee, ) = this.estimateSendFee(msg.value, dstAddr);\n\n        require(msg.value > nativeFee, "too little");\n\n        uint256 amount = msg.value - nativeFee;\n\n        this.bridge{value: msg.value}(msg.sender, amount, dstAddr, nativeFee);\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStone.sendFrom', 'start_line': 201, 'end_line': 209, 'offset_start': 6311, 'offset_end': 6574, 'content': 'function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;', 'contract_name': 'IStone', 'contract_code': '{\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
{'type': 'FunctionDefinition', 'name': 'IStone.estimateSendFee', 'start_line': 211, 'end_line': 217, 'offset_start': 6581, 'offset_end': 6809, 'content': 'function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);', 'contract_name': 'IStone', 'contract_code': '{\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes calldata _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) external view returns (uint nativeFee, uint zroFee);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/1/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e/0x1b70ff1e5152fdb8425a2b84b098df2f9c1df54e.sol'}
