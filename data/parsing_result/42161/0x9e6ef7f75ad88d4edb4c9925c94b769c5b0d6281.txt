{'type': 'FunctionDefinition', 'name': 'Address.isContract', 'start_line': 4, 'end_line': 8, 'offset_start': 55, 'offset_end': 224, 'content': 'function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 9, 'end_line': 13, 'offset_start': 230, 'offset_end': 542, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 14, 'end_line': 16, 'offset_start': 548, 'offset_end': 718, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 17, 'end_line': 19, 'offset_start': 724, 'offset_end': 916, 'content': 'function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 20, 'end_line': 22, 'offset_start': 922, 'offset_end': 1145, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 23, 'end_line': 28, 'offset_start': 1151, 'offset_end': 1613, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 29, 'end_line': 31, 'offset_start': 1619, 'offset_end': 1815, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 32, 'end_line': 36, 'offset_start': 1821, 'offset_end': 2176, 'content': 'function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 37, 'end_line': 39, 'offset_start': 2182, 'offset_end': 2379, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 40, 'end_line': 44, 'offset_start': 2385, 'offset_end': 2741, 'content': 'function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._verifyCallResult', 'start_line': 45, 'end_line': 58, 'offset_start': 2747, 'offset_end': 3248, 'content': 'function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, "Address: insufficient balance");\n        (bool success, ) = recipient.call{ value: amount }("");\n        require(success, "Address: unable to send value, recipient may have reverted");\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, "Address: low-level call failed");\n    }\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, "Address: low-level call with value failed");\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, "Address: insufficient balance for call");\n        require(isContract(target), "Address: call to non-contract");\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, "Address: low-level static call failed");\n    }\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), "Address: static call to non-contract");\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, "Address: low-level delegate call failed");\n    }\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), "Address: delegate call to non-contract");\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            if (returndata.length > 0) {\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 62, 'end_line': 75, 'offset_start': 3304, 'offset_end': 3767, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 76, 'end_line': 82, 'offset_start': 3773, 'offset_end': 4226, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.toEthSignedMessageHash', 'start_line': 83, 'end_line': 85, 'offset_start': 4232, 'offset_end': 4402, 'content': 'function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        if (signature.length != 65) {\n            revert("ECDSA: invalid signature length");\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n        return recover(hash, v, r, s);\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, "ECDSA: invalid signature \'s\' value");\n        require(v == 27 || v == 28, "ECDSA: invalid signature \'v\' value");\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), "ECDSA: invalid signature");\n        return signer;\n    }\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19Ethereum Signed Message:\\n32", hash));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.totalSupply', 'start_line': 89, 'end_line': 89, 'offset_start': 4461, 'offset_end': 4515, 'content': 'function totalSupply() external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.balanceOf', 'start_line': 90, 'end_line': 90, 'offset_start': 4521, 'offset_end': 4588, 'content': 'function balanceOf(address account) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transfer', 'start_line': 91, 'end_line': 91, 'offset_start': 4594, 'offset_end': 4670, 'content': 'function transfer(address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.allowance', 'start_line': 92, 'end_line': 92, 'offset_start': 4676, 'offset_end': 4758, 'content': 'function allowance(address owner, address spender) external view returns (uint256);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.approve', 'start_line': 93, 'end_line': 93, 'offset_start': 4764, 'offset_end': 4837, 'content': 'function approve(address spender, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC20.transferFrom', 'start_line': 94, 'end_line': 94, 'offset_start': 4843, 'offset_end': 4939, 'content': 'function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);', 'contract_name': 'IERC20', 'contract_code': '{\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.tor', 'start_line': 177, 'end_line': 187, 'offset_start': 7179, 'offset_end': 7532, 'content': 'constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.activateCampaign', 'start_line': 188, 'end_line': 196, 'offset_start': 7538, 'offset_end': 7806, 'content': 'function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claim', 'start_line': 197, 'end_line': 217, 'offset_start': 7812, 'offset_end': 8458, 'content': 'function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claim', 'start_line': 218, 'end_line': 226, 'offset_start': 8464, 'offset_end': 8728, 'content': 'function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatch', 'start_line': 227, 'end_line': 261, 'offset_start': 8734, 'offset_end': 9869, 'content': 'function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatch', 'start_line': 262, 'end_line': 270, 'offset_start': 9875, 'offset_end': 10183, 'content': 'function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimCapped', 'start_line': 271, 'end_line': 295, 'offset_start': 10189, 'offset_end': 11046, 'content': 'function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimCapped', 'start_line': 296, 'end_line': 305, 'offset_start': 11052, 'offset_end': 11356, 'content': 'function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatchCapped', 'start_line': 306, 'end_line': 354, 'offset_start': 11362, 'offset_end': 12919, 'content': 'function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.claimBatchCapped', 'start_line': 355, 'end_line': 364, 'offset_start': 12925, 'offset_end': 13273, 'content': 'function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.forge', 'start_line': 365, 'end_line': 400, 'offset_start': 13279, 'offset_end': 14349, 'content': 'function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.forge', 'start_line': 401, 'end_line': 410, 'offset_start': 14355, 'offset_end': 14664, 'content': 'function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.', 'start_line': 411, 'end_line': 416, 'offset_start': 14670, 'offset_end': 14852, 'content': 'receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.', 'start_line': 417, 'end_line': 422, 'offset_start': 14858, 'offset_end': 15066, 'content': 'fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateGalaxySigner', 'start_line': 423, 'end_line': 429, 'offset_start': 15072, 'offset_end': 15310, 'content': 'function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateCampaignSetter', 'start_line': 430, 'end_line': 436, 'offset_start': 15316, 'offset_end': 15560, 'content': 'function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateManager', 'start_line': 437, 'end_line': 443, 'offset_start': 15566, 'offset_end': 15787, 'content': 'function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.updateTreasureManager', 'start_line': 444, 'end_line': 453, 'offset_start': 15793, 'offset_end': 16060, 'content': 'function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2.setPause', 'start_line': 454, 'end_line': 456, 'offset_start': 16066, 'offset_end': 16151, 'content': 'function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hash', 'start_line': 457, 'end_line': 479, 'offset_start': 16157, 'offset_end': 16776, 'content': 'function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashCapped', 'start_line': 480, 'end_line': 504, 'offset_start': 16782, 'offset_end': 17467, 'content': 'function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashBatch', 'start_line': 505, 'end_line': 527, 'offset_start': 17473, 'offset_end': 18199, 'content': 'function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashBatchCapped', 'start_line': 528, 'end_line': 552, 'offset_start': 18205, 'offset_end': 18997, 'content': 'function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._hashForge', 'start_line': 553, 'end_line': 577, 'offset_start': 19003, 'offset_end': 19738, 'content': 'function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._verify', 'start_line': 578, 'end_line': 584, 'offset_start': 19744, 'offset_end': 19914, 'content': 'function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._setFees', 'start_line': 585, 'end_line': 601, 'offset_start': 19920, 'offset_end': 20386, 'content': 'function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._payFees', 'start_line': 602, 'end_line': 625, 'offset_start': 20392, 'offset_end': 21255, 'content': 'function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyCampaignSetter', 'start_line': 626, 'end_line': 628, 'offset_start': 21261, 'offset_end': 21400, 'content': 'function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyManager', 'start_line': 629, 'end_line': 631, 'offset_start': 21406, 'offset_end': 21523, 'content': 'function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyTreasuryManager', 'start_line': 632, 'end_line': 637, 'offset_start': 21529, 'offset_end': 21706, 'content': 'function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SpaceStationV2._validateOnlyNotPaused', 'start_line': 638, 'end_line': 640, 'offset_start': 21712, 'offset_end': 21811, 'content': 'function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }', 'contract_name': 'SpaceStationV2', 'contract_code': '{\n    using Address for address;\n    using SafeMath for uint256;\n    event EventActivateCampaign(uint256 _cid);\n    event EventClaim(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimCapped(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventClaimBatch(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    event EventClaimBatchCapped(\n        uint256 _cid,\n        uint256[] _dummyIdArr,\n        uint256[] _nftIDArr,\n        IStarNFT _starNFT,\n        address _sender,\n        uint256 _minted,\n        uint256 _cap\n    );\n    event EventForge(\n        uint256 _cid,\n        uint256 _dummyId,\n        uint256 _nftID,\n        IStarNFT _starNFT,\n        address _sender\n    );\n    modifier onlyCampaignSetter() {\n        _validateOnlyCampaignSetter();\n        _;\n    }\n    modifier onlyManager() {\n        _validateOnlyManager();\n        _;\n    }\n    modifier onlyTreasuryManager() {\n        _validateOnlyTreasuryManager();\n        _;\n    }\n    modifier onlyNoPaused() {\n        _validateOnlyNotPaused();\n        _;\n    }\n    struct CampaignFeeConfig {\n        address erc20; \n        uint256 erc20Fee; \n        uint256 platformFee; \n    }\n    bool public paused;\n    address public galaxy_signer;\n    address public campaign_setter;\n    address public manager;\n    address public treasury_manager;\n    mapping(uint256 => CampaignFeeConfig) public campaignFeeConfigs;\n    mapping(uint256 => bool) public hasMinted;\n    mapping(uint256 => uint256) public numMinted;\n    constructor(\n        address _galaxy_signer,\n        address _campaign_setter,\n        address _contract_manager,\n        address _treasury_manager\n    ) EIP712("Galaxy", "1.0.0") {\n        galaxy_signer = _galaxy_signer;\n        campaign_setter = _campaign_setter;\n        manager = _contract_manager;\n        treasury_manager = _treasury_manager;\n    }\n    function activateCampaign(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) external onlyCampaignSetter {\n        _setFees(_cid, _platformFee, _erc20Fee, _erc20);\n        emit EventActivateCampaign(_cid);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hash(_cid, _starNFT, _dummyId, _powah, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventClaim(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function claim(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claim(_cid, _starNFT, _dummyId, _powah, msg.sender, _signature);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatch(_cid, _starNFT, _dummyIdArr, _powahArr, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        emit EventClaimBatch(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo);\n    }\n    function claimBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatch(_cid, _starNFT, _dummyIdArr, _powahArr, msg.sender, _signature);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(numMinted[_cid] < _cap, "Reached cap limit");\n        require(\n            _verify(\n                _hashCapped(_cid, _starNFT, _dummyId, _powah, _cap, _mintTo),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        numMinted[_cid] = numMinted[_cid] + 1;\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        uint256 minted = numMinted[_cid];\n        emit EventClaimCapped(_cid, _dummyId, nftID, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimCapped(_cid, _starNFT, _dummyId, _powah, _cap, msg.sender, _signature);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(\n            _dummyIdArr.length > 0,\n            "Array(_dummyIdArr) should not be empty"\n        );\n        require(\n            _powahArr.length == _dummyIdArr.length,\n            "Array(_powahArr) length mismatch"\n        );\n        require(\n            numMinted[_cid] + _dummyIdArr.length <= _cap,\n            "Reached cap limit"\n        );\n        for (uint256 i = 0; i < _dummyIdArr.length; i++) {\n            require(!hasMinted[_dummyIdArr[i]], "Already minted");\n            hasMinted[_dummyIdArr[i]] = true;\n        }\n        require(\n            _verify(\n                _hashBatchCapped(\n                    _cid,\n                    _starNFT,\n                    _dummyIdArr,\n                    _powahArr,\n                    _cap,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        numMinted[_cid] = numMinted[_cid] + _dummyIdArr.length;\n        _payFees(_cid, _dummyIdArr.length);\n        uint256[] memory nftIdArr = _starNFT.mintBatch(\n            _mintTo,\n            _powahArr.length,\n            _powahArr\n        );\n        uint256 minted = numMinted[_cid];\n        emit EventClaimBatchCapped(_cid, _dummyIdArr, nftIdArr, _starNFT, _mintTo, minted, _cap);\n    }\n    function claimBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        claimBatchCapped(_cid, _starNFT, _dummyIdArr, _powahArr, _cap, msg.sender, _signature);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _mintTo,\n        bytes calldata _signature\n    ) public payable onlyNoPaused {\n        require(!hasMinted[_dummyId], "Already minted");\n        require(\n            _verify(\n                _hashForge(\n                    _cid,\n                    _starNFT,\n                    _nftIDs,\n                    _dummyId,\n                    _powah,\n                    _mintTo\n                ),\n                _signature\n            ),\n            "Invalid signature"\n        );\n        hasMinted[_dummyId] = true;\n        for (uint256 i = 0; i < _nftIDs.length; i++) {\n            require(\n                _starNFT.isOwnerOf(_mintTo, _nftIDs[i]),\n                "Not the owner"\n            );\n        }\n        _starNFT.burnBatch(_mintTo, _nftIDs);\n        _payFees(_cid, 1);\n        uint256 nftID = _starNFT.mint(_mintTo, _powah);\n        emit EventForge(_cid, _dummyId, nftID, _starNFT, _mintTo);\n    }\n    function forge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        bytes calldata _signature\n    ) external payable onlyNoPaused {\n        forge(_cid, _starNFT, _nftIDs, _dummyId, _powah, msg.sender, _signature);\n    }\n    receive() external payable {\n        (bool success, ) = treasury_manager.call{value: msg.value}(\n            new bytes(0)\n        );\n        require(success, "Transfer failed");\n    }\n    fallback() external payable {\n        if (msg.value > 0) {\n            (bool success, ) = treasury_manager.call{value: msg.value}(new bytes(0));\n            require(success, "Transfer failed");\n        }\n    }\n    function updateGalaxySigner(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Galaxy signer address must not be null address"\n        );\n        galaxy_signer = newAddress;\n    }\n    function updateCampaignSetter(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Campaign setter address must not be null address"\n        );\n        campaign_setter = newAddress;\n    }\n    function updateManager(address newAddress) external onlyManager {\n        require(\n            newAddress != address(0),\n            "Manager address must not be null address"\n        );\n        manager = newAddress;\n    }\n    function updateTreasureManager(address payable newAddress)\n    external\n    onlyTreasuryManager\n    {\n        require(\n            newAddress != address(0),\n            "Treasure manager must not be null address"\n        );\n        treasury_manager = newAddress;\n    }\n    function setPause(bool _paused) external onlyManager {\n        paused = _paused;\n    }\n    function _hash(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256 _dummyId,\n        uint256 _powah,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256 dummyId,uint256 powah,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    _dummyId,\n                    _powah,\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatch(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _account\n                )\n            )\n        );\n    }\n    function _hashBatchCapped(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _dummyIdArr,\n        uint256[] calldata _powahArr,\n        uint256 _cap,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] dummyIdArr,uint256[] powahArr,uint256 cap,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_dummyIdArr)),\n                    keccak256(abi.encodePacked(_powahArr)),\n                    _cap,\n                    _account\n                )\n            )\n        );\n    }\n    function _hashForge(\n        uint256 _cid,\n        IStarNFT _starNFT,\n        uint256[] calldata _nftIDs,\n        uint256 _dummyId,\n        uint256 _powah,\n        address _account\n    ) public view returns (bytes32) {\n        return\n        _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    keccak256(\n                        "NFT(uint256 cid,address starNFT,uint256[] nftIDs,uint256 dummyId,uint256 powah,address account)"\n                    ),\n                    _cid,\n                    _starNFT,\n                    keccak256(abi.encodePacked(_nftIDs)),\n                    _dummyId,\n                    _powah,\n                    _account\n                )\n            )\n        );\n    }\n    function _verify(bytes32 hash, bytes calldata signature)\n    public\n    view\n    returns (bool)\n    {\n        return ECDSA.recover(hash, signature) == galaxy_signer;\n    }\n    function _setFees(\n        uint256 _cid,\n        uint256 _platformFee,\n        uint256 _erc20Fee,\n        address _erc20\n    ) private {\n        require(\n            (_erc20 == address(0) && _erc20Fee == 0) ||\n            (_erc20 != address(0) && _erc20Fee != 0),\n            "Invalid erc20 fee requirement arguments"\n        );\n        campaignFeeConfigs[_cid] = CampaignFeeConfig(\n            _erc20,\n            _erc20Fee,\n            _platformFee\n        );\n    }\n    function _payFees(uint256 _cid, uint256 amount) private {\n        require(amount > 0, "Must mint more than 0");\n        CampaignFeeConfig memory feeConf = campaignFeeConfigs[_cid];\n        if (feeConf.platformFee > 0) {\n            require(\n                msg.value >= feeConf.platformFee.mul(amount),\n                "Insufficient Payment"\n            );\n            (bool success, ) = treasury_manager.call{value: msg.value}(\n                new bytes(0)\n            );\n            require(success, "Transfer platformFee failed");\n        }\n        if (feeConf.erc20Fee > 0) {\n            require(\n                IERC20(feeConf.erc20).transferFrom(\n                    msg.sender,\n                    treasury_manager,\n                    feeConf.erc20Fee.mul(amount)\n                ),\n                "Transfer erc20Fee failed"\n            );\n        }\n    }\n    function _validateOnlyCampaignSetter() internal view {\n        require(msg.sender == campaign_setter, "Only campaignSetter can call");\n    }\n    function _validateOnlyManager() internal view {\n        require(msg.sender == manager, "Only manager can call");\n    }\n    function _validateOnlyTreasuryManager() internal view {\n        require(\n            msg.sender == treasury_manager,\n            "Only treasury manager can call"\n        );\n    }\n    function _validateOnlyNotPaused() internal view {\n        require(!paused, "Contract paused");\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.isOwnerOf', 'start_line': 644, 'end_line': 644, 'offset_start': 21863, 'offset_end': 21928, 'content': 'function isOwnerOf(address, uint256) external view returns (bool);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.getNumMinted', 'start_line': 645, 'end_line': 645, 'offset_start': 21934, 'offset_end': 21989, 'content': 'function getNumMinted() external view returns (uint256);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.mint', 'start_line': 646, 'end_line': 646, 'offset_start': 21995, 'offset_end': 22067, 'content': 'function mint(address account, uint256 powah) external returns (uint256);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.mintBatch', 'start_line': 647, 'end_line': 647, 'offset_start': 22073, 'offset_end': 22189, 'content': 'function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.burn', 'start_line': 648, 'end_line': 648, 'offset_start': 22195, 'offset_end': 22246, 'content': 'function burn(address account, uint256 id) external;', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'IStarNFT.burnBatch', 'start_line': 649, 'end_line': 649, 'offset_start': 22252, 'offset_end': 22320, 'content': 'function burnBatch(address account, uint256[] calldata ids) external;', 'contract_name': 'IStarNFT', 'contract_code': '{\n    function isOwnerOf(address, uint256) external view returns (bool);\n    function getNumMinted() external view returns (uint256);\n    function mint(address account, uint256 powah) external returns (uint256);\n    function mintBatch(address account, uint256 amount, uint256[] calldata powahArr) external returns (uint256[] memory);\n    function burn(address account, uint256 id) external;\n    function burnBatch(address account, uint256[] calldata ids) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712.tor', 'start_line': 658, 'end_line': 667, 'offset_start': 22624, 'offset_end': 23174, 'content': 'constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._domainSeparatorV4', 'start_line': 668, 'end_line': 674, 'offset_start': 23180, 'offset_end': 23462, 'content': 'function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._buildDomainSeparator', 'start_line': 675, 'end_line': 685, 'offset_start': 23468, 'offset_end': 23794, 'content': 'function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._hashTypedDataV4', 'start_line': 686, 'end_line': 688, 'offset_start': 23800, 'offset_end': 23982, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712._getChainId', 'start_line': 689, 'end_line': 694, 'offset_start': 23988, 'offset_end': 24133, 'content': 'function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }', 'contract_name': 'EIP712', 'contract_code': '{\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    constructor(string memory name, string memory version) internal {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = _getChainId();\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n    function _domainSeparatorV4() internal view virtual returns (bytes32) {\n        if (_getChainId() == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                _getChainId(),\n                address(this)\n            )\n        );\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return keccak256(abi.encodePacked("\\x19\\x01", _domainSeparatorV4(), structHash));\n    }\n    function _getChainId() private view returns (uint256 chainId) {\n        this; \n        assembly {\n            chainId := chainid()\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryAdd', 'start_line': 698, 'end_line': 702, 'offset_start': 24192, 'offset_end': 24365, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.trySub', 'start_line': 703, 'end_line': 706, 'offset_start': 24371, 'offset_end': 24521, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryMul', 'start_line': 707, 'end_line': 712, 'offset_start': 24527, 'offset_end': 24743, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryDiv', 'start_line': 713, 'end_line': 716, 'offset_start': 24749, 'offset_end': 24900, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.tryMod', 'start_line': 717, 'end_line': 720, 'offset_start': 24906, 'offset_end': 25057, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.add', 'start_line': 721, 'end_line': 725, 'offset_start': 25063, 'offset_end': 25237, 'content': 'function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 726, 'end_line': 729, 'offset_start': 25243, 'offset_end': 25397, 'content': 'function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mul', 'start_line': 730, 'end_line': 735, 'offset_start': 25403, 'offset_end': 25617, 'content': 'function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 736, 'end_line': 739, 'offset_start': 25623, 'offset_end': 25772, 'content': 'function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mod', 'start_line': 740, 'end_line': 743, 'offset_start': 25778, 'offset_end': 25925, 'content': 'function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.sub', 'start_line': 744, 'end_line': 747, 'offset_start': 25931, 'offset_end': 26093, 'content': 'function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.div', 'start_line': 748, 'end_line': 751, 'offset_start': 26099, 'offset_end': 26260, 'content': 'function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
{'type': 'FunctionDefinition', 'name': 'SafeMath.mod', 'start_line': 752, 'end_line': 755, 'offset_start': 26266, 'offset_end': 26427, 'content': 'function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }', 'contract_name': 'SafeMath', 'contract_code': '{\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, "SafeMath: addition overflow");\n        return c;\n    }\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, "SafeMath: subtraction overflow");\n        return a - b;\n    }\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, "SafeMath: multiplication overflow");\n        return c;\n    }\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: division by zero");\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, "SafeMath: modulo by zero");\n        return a % b;\n    }\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281/0x9e6ef7f75ad88d4edb4c9925c94b769c5b0d6281.sol'}
