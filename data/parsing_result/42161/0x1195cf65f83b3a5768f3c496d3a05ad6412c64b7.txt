{'type': 'FunctionDefinition', 'name': 'CUBE.tor', 'start_line': 123, 'end_line': 125, 'offset_start': 4747, 'offset_end': 4799, 'content': 'constructor() {\n        _disableInitializers();\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.cubeVersion', 'start_line': 126, 'end_line': 128, 'offset_start': 4805, 'offset_end': 4892, 'content': 'function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initialize', 'start_line': 129, 'end_line': 143, 'offset_start': 4898, 'offset_end': 5413, 'content': 'function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._authorizeUpgrade', 'start_line': 144, 'end_line': 148, 'offset_start': 5419, 'offset_end': 5544, 'content': 'function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.isQuestActive', 'start_line': 149, 'end_line': 151, 'offset_start': 5550, 'offset_end': 5657, 'content': 'function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.tokenURI', 'start_line': 152, 'end_line': 154, 'offset_start': 5663, 'offset_end': 5798, 'content': 'function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCube', 'start_line': 155, 'end_line': 167, 'offset_start': 5804, 'offset_end': 6164, 'content': 'function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.mintCubes', 'start_line': 168, 'end_line': 195, 'offset_start': 6170, 'offset_end': 6983, 'content': 'function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._mintCube', 'start_line': 196, 'end_line': 245, 'offset_start': 6989, 'offset_end': 8687, 'content': 'function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._validateSignature', 'start_line': 246, 'end_line': 255, 'offset_start': 8693, 'offset_end': 9063, 'content': 'function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._processPayouts', 'start_line': 256, 'end_line': 284, 'offset_start': 9069, 'offset_end': 10211, 'content': 'function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getSigner', 'start_line': 285, 'end_line': 292, 'offset_start': 10217, 'offset_end': 10430, 'content': 'function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._computeDigest', 'start_line': 293, 'end_line': 295, 'offset_start': 10436, 'offset_end': 10588, 'content': 'function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._getStructHash', 'start_line': 296, 'end_line': 310, 'offset_start': 10594, 'offset_end': 11127, 'content': 'function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeString', 'start_line': 311, 'end_line': 313, 'offset_start': 11133, 'offset_end': 11261, 'content': 'function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeTx', 'start_line': 314, 'end_line': 320, 'offset_start': 11267, 'offset_end': 11532, 'content': 'function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeCompletedTxs', 'start_line': 321, 'end_line': 334, 'offset_start': 11538, 'offset_end': 11972, 'content': 'function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipient', 'start_line': 335, 'end_line': 337, 'offset_start': 11978, 'offset_end': 12149, 'content': 'function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeRecipients', 'start_line': 338, 'end_line': 347, 'offset_start': 12155, 'offset_end': 12576, 'content': 'function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE._encodeReward', 'start_line': 348, 'end_line': 361, 'offset_start': 12582, 'offset_end': 13000, 'content': 'function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.setIsMintingActive', 'start_line': 362, 'end_line': 365, 'offset_start': 13006, 'offset_end': 13193, 'content': 'function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.withdraw', 'start_line': 366, 'end_line': 372, 'offset_start': 13199, 'offset_end': 13473, 'content': 'function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.initializeQuest', 'start_line': 373, 'end_line': 383, 'offset_start': 13479, 'offset_end': 13848, 'content': 'function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.unpublishQuest', 'start_line': 384, 'end_line': 387, 'offset_start': 13854, 'offset_end': 14004, 'content': 'function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'CUBE.supportsInterface', 'start_line': 388, 'end_line': 395, 'offset_start': 14010, 'offset_end': 14233, 'content': 'function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }', 'contract_name': 'CUBE', 'contract_code': '{\n    using ECDSA for bytes32;\n    error CUBE__IsNotSigner();\n    error CUBE__MintingIsNotActive();\n    error CUBE__FeeNotEnough();\n    error CUBE__SignatureAndCubesInputMismatch();\n    error CUBE__WithdrawFailed();\n    error CUBE__NonceAlreadyUsed();\n    error CUBE__TransferFailed();\n    error CUBE__BPSTooHigh();\n    error CUBE__ExcessiveFeePayout();\n    error CUBE__ExceedsContractBalance();\n    error CUBE__QuestNotActive();\n    uint256 internal s_nextTokenId;\n    bool public s_isMintingActive;\n    bytes32 public constant SIGNER_ROLE = keccak256("SIGNER");\n    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER");\n    bytes32 internal constant TX_DATA_HASH =\n        keccak256("TransactionData(string txHash,string networkChainId)");\n    bytes32 internal constant RECIPIENT_DATA_HASH =\n        keccak256("FeeRecipient(address recipient,uint16 BPS)");\n    bytes32 internal constant REWARD_DATA_HASH = keccak256(\n        "RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)"\n    );\n    bytes32 internal constant CUBE_DATA_HASH = keccak256(\n        "CubeData(uint256 questId,uint256 nonce,uint256 price,address toAddress,string walletProvider,string tokenURI,string embedOrigin,TransactionData[] transactions,FeeRecipient[] recipients,RewardData reward)FeeRecipient(address recipient,uint16 BPS)RewardData(address tokenAddress,uint256 chainId,uint256 amount,uint256 tokenId,uint8 tokenType,uint256 rakeBps,address factoryAddress)TransactionData(string txHash,string networkChainId)"\n    );\n    mapping(uint256 => uint256) internal s_questIssueNumbers;\n    mapping(uint256 => string) internal s_tokenURIs;\n    mapping(uint256 nonce => bool isConsumed) internal s_nonces;\n    mapping(uint256 => bool) internal s_quests;\n    enum QuestType {\n        QUEST,\n        STREAK\n    }\n    enum Difficulty {\n        BEGINNER,\n        INTERMEDIATE,\n        ADVANCED\n    }\n    event QuestMetadata(\n        uint256 indexed questId,\n        QuestType questType,\n        Difficulty difficulty,\n        string title,\n        string[] tags,\n        string[] communities\n    );\n    event CubeClaim(\n        uint256 indexed questId,\n        uint256 indexed tokenId,\n        address indexed claimer,\n        uint256 issueNumber,\n        string walletProvider,\n        string embedOrigin\n    );\n    event CubeTransaction(uint256 indexed cubeTokenId, string txHash, string networkChainId);\n    event TokenReward(\n        uint256 indexed cubeTokenId,\n        address indexed tokenAddress,\n        uint256 indexed chainId,\n        uint256 amount,\n        uint256 tokenId,\n        TokenType tokenType\n    );\n    event FeePayout(address indexed recipient, uint256 amount);\n    event MintingSwitch(bool isActive);\n    event ContractWithdrawal(uint256 amount);\n    event QuestDisabled(uint256 indexed questId);\n    struct CubeData {\n        uint256 questId;\n        uint256 nonce;\n        uint256 price;\n        address toAddress;\n        string walletProvider;\n        string tokenURI;\n        string embedOrigin;\n        TransactionData[] transactions;\n        FeeRecipient[] recipients;\n        RewardData reward;\n    }\n    struct FeeRecipient {\n        address recipient;\n        uint16 BPS;\n    }\n    struct RewardData {\n        address tokenAddress;\n        uint256 chainId;\n        uint256 amount;\n        uint256 tokenId;\n        TokenType tokenType;\n        uint256 rakeBps;\n        address factoryAddress;\n    }\n    struct TransactionData {\n        string txHash;\n        string networkChainId;\n    }\n    constructor() {\n        _disableInitializers();\n    }\n    function cubeVersion() external pure returns (string memory) {\n        return "2";\n    }\n    function initialize(\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        string memory _signingDomain,\n        string memory _signatureVersion,\n        address _admin\n    ) external initializer {\n        __ERC721_init(_tokenName, _tokenSymbol);\n        __EIP712_init(_signingDomain, _signatureVersion);\n        __AccessControl_init();\n        __UUPSUpgradeable_init();\n        __ReentrancyGuard_init();\n        s_isMintingActive = true;\n        _grantRole(DEFAULT_ADMIN_ROLE, _admin);\n    }\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyRole(UPGRADER_ROLE)\n    {}\n    function isQuestActive(uint256 questId) public view returns (bool) {\n        return s_quests[questId];\n    }\n    function tokenURI(uint256 _tokenId) public view override returns (string memory _tokenURI) {\n        return s_tokenURIs[_tokenId];\n    }\n    function mintCube(CubeData calldata cubeData, bytes calldata signature)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (msg.value < cubeData.price) {\n            revert CUBE__FeeNotEnough();\n        }\n        _mintCube(cubeData, signature);\n    }\n    function mintCubes(CubeData[] calldata cubeData, bytes[] calldata signatures)\n        external\n        payable\n        nonReentrant\n    {\n        if (!s_isMintingActive) {\n            revert CUBE__MintingIsNotActive();\n        }\n        if (cubeData.length != signatures.length) {\n            revert CUBE__SignatureAndCubesInputMismatch();\n        }\n        uint256 totalFee;\n        for (uint256 i = 0; i < cubeData.length;) {\n            totalFee = totalFee + cubeData[i].price;\n            unchecked {\n                ++i;\n            }\n        }\n        if (msg.value < totalFee) {\n            revert CUBE__FeeNotEnough();\n        }\n        for (uint256 i = 0; i < cubeData.length;) {\n            _mintCube(cubeData[i], signatures[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _mintCube(CubeData calldata data, bytes calldata signature) internal {\n        uint256 tokenId = s_nextTokenId;\n        _validateSignature(data, signature);\n        for (uint256 i = 0; i < data.transactions.length;) {\n            emit CubeTransaction(\n                tokenId, data.transactions[i].txHash, data.transactions[i].networkChainId\n            );\n            unchecked {\n                ++i;\n            }\n        }\n        s_tokenURIs[tokenId] = data.tokenURI;\n        unchecked {\n            ++s_questIssueNumbers[data.questId];\n            ++s_nextTokenId;\n        }\n        if (data.recipients.length > 0) {\n            _processPayouts(data);\n        }\n        _safeMint(data.toAddress, tokenId);\n        emit CubeClaim(\n            data.questId,\n            tokenId,\n            data.toAddress,\n            s_questIssueNumbers[data.questId],\n            data.walletProvider,\n            data.embedOrigin\n        );\n        if (data.reward.chainId != 0) {\n            if (data.reward.factoryAddress != address(0)) {\n                IFactory(data.reward.factoryAddress).distributeRewards(\n                    data.questId,\n                    data.reward.tokenAddress,\n                    data.toAddress,\n                    data.reward.amount,\n                    data.reward.tokenId,\n                    data.reward.tokenType,\n                    data.reward.rakeBps\n                );\n            }\n            emit TokenReward(\n                tokenId,\n                data.reward.tokenAddress,\n                data.reward.chainId,\n                data.reward.amount,\n                data.reward.tokenId,\n                data.reward.tokenType\n            );\n        }\n    }\n    function _validateSignature(CubeData calldata data, bytes calldata signature) internal {\n        address signer = _getSigner(data, signature);\n        if (!hasRole(SIGNER_ROLE, signer)) {\n            revert CUBE__IsNotSigner();\n        }\n        if (s_nonces[data.nonce]) {\n            revert CUBE__NonceAlreadyUsed();\n        }\n        s_nonces[data.nonce] = true;\n    }\n    function _processPayouts(CubeData calldata data) internal {\n        uint256 totalAmount;\n        uint16 maxBps = 10_000;\n        uint256 contractBalance = address(this).balance;\n        for (uint256 i = 0; i < data.recipients.length;) {\n            if (data.recipients[i].BPS > maxBps) {\n                revert CUBE__BPSTooHigh();\n            }\n            uint256 referralAmount = (data.price * data.recipients[i].BPS) / maxBps;\n            totalAmount = totalAmount + referralAmount;\n            if (totalAmount > data.price) {\n                revert CUBE__ExcessiveFeePayout();\n            }\n            if (totalAmount > contractBalance) {\n                revert CUBE__ExceedsContractBalance();\n            }\n            address recipient = data.recipients[i].recipient;\n            if (recipient != address(0)) {\n                (bool success,) = recipient.call{value: referralAmount}("");\n                if (!success) {\n                    revert CUBE__TransferFailed();\n                }\n                emit FeePayout(recipient, referralAmount);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n    function _getSigner(CubeData calldata data, bytes calldata sig)\n        internal\n        view\n        returns (address)\n    {\n        bytes32 digest = _computeDigest(data);\n        return digest.recover(sig);\n    }\n    function _computeDigest(CubeData calldata data) internal view returns (bytes32) {\n        return _hashTypedDataV4(keccak256(_getStructHash(data)));\n    }\n    function _getStructHash(CubeData calldata data) internal pure returns (bytes memory) {\n        return abi.encode(\n            CUBE_DATA_HASH,\n            data.questId,\n            data.nonce,\n            data.price,\n            data.toAddress,\n            _encodeString(data.walletProvider),\n            _encodeString(data.tokenURI),\n            _encodeString(data.embedOrigin),\n            _encodeCompletedTxs(data.transactions),\n            _encodeRecipients(data.recipients),\n            _encodeReward(data.reward)\n        );\n    }\n    function _encodeString(string calldata _string) internal pure returns (bytes32) {\n        return keccak256(bytes(_string));\n    }\n    function _encodeTx(TransactionData calldata transaction) internal pure returns (bytes memory) {\n        return abi.encode(\n            TX_DATA_HASH,\n            _encodeString(transaction.txHash),\n            _encodeString(transaction.networkChainId)\n        );\n    }\n    function _encodeCompletedTxs(TransactionData[] calldata txData)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32[] memory encodedTxs = new bytes32[](txData.length);\n        for (uint256 i = 0; i < txData.length;) {\n            encodedTxs[i] = keccak256(_encodeTx(txData[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedTxs));\n    }\n    function _encodeRecipient(FeeRecipient calldata data) internal pure returns (bytes memory) {\n        return abi.encode(RECIPIENT_DATA_HASH, data.recipient, data.BPS);\n    }\n    function _encodeRecipients(FeeRecipient[] calldata data) internal pure returns (bytes32) {\n        bytes32[] memory encodedRecipients = new bytes32[](data.length);\n        for (uint256 i = 0; i < data.length;) {\n            encodedRecipients[i] = keccak256(_encodeRecipient(data[i]));\n            unchecked {\n                ++i;\n            }\n        }\n        return keccak256(abi.encodePacked(encodedRecipients));\n    }\n    function _encodeReward(RewardData calldata data) internal pure returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                REWARD_DATA_HASH,\n                data.tokenAddress,\n                data.chainId,\n                data.amount,\n                data.tokenId,\n                data.tokenType,\n                data.rakeBps,\n                data.factoryAddress\n            )\n        );\n    }\n    function setIsMintingActive(bool _isMintingActive) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        s_isMintingActive = _isMintingActive;\n        emit MintingSwitch(_isMintingActive);\n    }\n    function withdraw() external onlyRole(DEFAULT_ADMIN_ROLE) {\n        (bool success,) = msg.sender.call{value: address(this).balance}("");\n        if (!success) {\n            revert CUBE__WithdrawFailed();\n        }\n        emit ContractWithdrawal(address(this).balance);\n    }\n    function initializeQuest(\n        uint256 questId,\n        string[] memory communities,\n        string memory title,\n        Difficulty difficulty,\n        QuestType questType,\n        string[] memory tags\n    ) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = true;\n        emit QuestMetadata(questId, questType, difficulty, title, tags, communities);\n    }\n    function unpublishQuest(uint256 questId) external onlyRole(SIGNER_ROLE) {\n        s_quests[questId] = false;\n        emit QuestDisabled(questId);\n    }\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721Upgradeable, AccessControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.hasRole', 'start_line': 441, 'end_line': 441, 'offset_start': 16244, 'offset_end': 16320, 'content': 'function hasRole(bytes32 role, address account) external view returns (bool);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.getRoleAdmin', 'start_line': 442, 'end_line': 442, 'offset_start': 16326, 'offset_end': 16393, 'content': 'function getRoleAdmin(bytes32 role) external view returns (bytes32);', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.grantRole', 'start_line': 443, 'end_line': 443, 'offset_start': 16399, 'offset_end': 16457, 'content': 'function grantRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.revokeRole', 'start_line': 444, 'end_line': 444, 'offset_start': 16463, 'offset_end': 16522, 'content': 'function revokeRole(bytes32 role, address account) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IAccessControl.renounceRole', 'start_line': 445, 'end_line': 445, 'offset_start': 16528, 'offset_end': 16600, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) external;', 'contract_name': 'IAccessControl', 'contract_code': '{\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n    error AccessControlBadConfirmation();\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n    function hasRole(bytes32 role, address account) external view returns (bool);\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n    function grantRole(bytes32 role, address account) external;\n    function revokeRole(bytes32 role, address account) external;\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 454, 'end_line': 472, 'offset_start': 16920, 'offset_end': 17519, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 473, 'end_line': 475, 'offset_start': 17525, 'offset_end': 17692, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 476, 'end_line': 480, 'offset_start': 17698, 'offset_end': 17871, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 481, 'end_line': 494, 'offset_start': 17877, 'offset_end': 18401, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 495, 'end_line': 497, 'offset_start': 18407, 'offset_end': 18554, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 498, 'end_line': 500, 'offset_start': 18560, 'offset_end': 18741, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.balanceOf', 'start_line': 508, 'end_line': 508, 'offset_start': 19139, 'offset_end': 19212, 'content': 'function balanceOf(address owner) external view returns (uint256 balance);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.ownerOf', 'start_line': 509, 'end_line': 509, 'offset_start': 19218, 'offset_end': 19289, 'content': 'function ownerOf(uint256 tokenId) external view returns (address owner);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 510, 'end_line': 510, 'offset_start': 19295, 'offset_end': 19393, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.safeTransferFrom', 'start_line': 511, 'end_line': 511, 'offset_start': 19399, 'offset_end': 19476, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.transferFrom', 'start_line': 512, 'end_line': 512, 'offset_start': 19482, 'offset_end': 19555, 'content': 'function transferFrom(address from, address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.approve', 'start_line': 513, 'end_line': 513, 'offset_start': 19561, 'offset_end': 19615, 'content': 'function approve(address to, uint256 tokenId) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.setApprovalForAll', 'start_line': 514, 'end_line': 514, 'offset_start': 19621, 'offset_end': 19689, 'content': 'function setApprovalForAll(address operator, bool approved) external;', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.getApproved', 'start_line': 515, 'end_line': 515, 'offset_start': 19695, 'offset_end': 19773, 'content': 'function getApproved(uint256 tokenId) external view returns (address operator);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721.isApprovedForAll', 'start_line': 516, 'end_line': 516, 'offset_start': 19779, 'offset_end': 19866, 'content': 'function isApprovedForAll(address owner, address operator) external view returns (bool);', 'contract_name': 'IERC721', 'contract_code': '{\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function transferFrom(address from, address to, uint256 tokenId) external;\n    function approve(address to, uint256 tokenId) external;\n    function setApprovalForAll(address operator, bool approved) external;\n    function getApproved(uint256 tokenId) external view returns (address operator);\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 527, 'end_line': 533, 'offset_start': 20037, 'offset_end': 20252, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 534, 'end_line': 539, 'offset_start': 20258, 'offset_end': 20446, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 540, 'end_line': 547, 'offset_start': 20452, 'offset_end': 20714, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 548, 'end_line': 553, 'offset_start': 20720, 'offset_end': 20909, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 554, 'end_line': 559, 'offset_start': 20915, 'offset_end': 21104, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 560, 'end_line': 562, 'offset_start': 21110, 'offset_end': 21213, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 563, 'end_line': 565, 'offset_start': 21219, 'offset_end': 21322, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 566, 'end_line': 568, 'offset_start': 21328, 'offset_end': 21443, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 569, 'end_line': 574, 'offset_start': 21449, 'offset_end': 21629, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 575, 'end_line': 612, 'offset_start': 21635, 'offset_end': 23102, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 613, 'end_line': 619, 'offset_start': 23108, 'offset_end': 23409, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 620, 'end_line': 635, 'offset_start': 23415, 'offset_end': 23995, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 636, 'end_line': 641, 'offset_start': 24001, 'offset_end': 24240, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 642, 'end_line': 678, 'offset_start': 24246, 'offset_end': 25228, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 679, 'end_line': 684, 'offset_start': 25234, 'offset_end': 25481, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 685, 'end_line': 717, 'offset_start': 25487, 'offset_end': 26402, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 718, 'end_line': 723, 'offset_start': 26408, 'offset_end': 26658, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 724, 'end_line': 748, 'offset_start': 26664, 'offset_end': 27326, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 749, 'end_line': 754, 'offset_start': 27332, 'offset_end': 27590, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 755, 'end_line': 757, 'offset_start': 27596, 'offset_end': 27717, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 761, 'end_line': 763, 'offset_start': 27771, 'offset_end': 27871, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 764, 'end_line': 766, 'offset_start': 27877, 'offset_end': 27977, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 767, 'end_line': 770, 'offset_start': 27983, 'offset_end': 28160, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 771, 'end_line': 775, 'offset_start': 28166, 'offset_end': 28302, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IBeacon.implementation', 'start_line': 779, 'end_line': 779, 'offset_start': 28355, 'offset_end': 28412, 'content': 'function implementation() external view returns (address);', 'contract_name': 'IBeacon', 'contract_code': '{\n    function implementation() external view returns (address);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.sendValue', 'start_line': 786, 'end_line': 794, 'offset_start': 28591, 'offset_end': 28920, 'content': 'function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCall', 'start_line': 795, 'end_line': 797, 'offset_start': 28926, 'offset_end': 29076, 'content': 'function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionCallWithValue', 'start_line': 798, 'end_line': 804, 'offset_start': 29082, 'offset_end': 29473, 'content': 'function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionStaticCall', 'start_line': 805, 'end_line': 808, 'offset_start': 29479, 'offset_end': 29732, 'content': 'function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.functionDelegateCall', 'start_line': 809, 'end_line': 812, 'offset_start': 29738, 'offset_end': 29990, 'content': 'function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResultFromTarget', 'start_line': 813, 'end_line': 826, 'offset_start': 29996, 'offset_end': 30407, 'content': 'function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address.verifyCallResult', 'start_line': 827, 'end_line': 833, 'offset_start': 30413, 'offset_end': 30636, 'content': 'function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Address._revert', 'start_line': 834, 'end_line': 843, 'offset_start': 30642, 'offset_end': 30960, 'content': 'function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }', 'contract_name': 'Address', 'contract_code': '{\n    error AddressInsufficientBalance(address account);\n    error AddressEmptyCode(address target);\n    error FailedInnerCall();\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, ) = recipient.call{value: amount}("");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n    function _revert(bytes memory returndata) private pure {\n        if (returndata.length > 0) {\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC1822Proxiable.proxiableUUID', 'start_line': 847, 'end_line': 847, 'offset_start': 31023, 'offset_end': 31079, 'content': 'function proxiableUUID() external view returns (bytes32);', 'contract_name': 'IERC1822Proxiable', 'contract_code': '{\n    function proxiableUUID() external view returns (bytes32);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getAddressSlot', 'start_line': 869, 'end_line': 873, 'offset_start': 31449, 'offset_end': 31595, 'content': 'function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBooleanSlot', 'start_line': 874, 'end_line': 878, 'offset_start': 31601, 'offset_end': 31747, 'content': 'function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytes32Slot', 'start_line': 879, 'end_line': 883, 'offset_start': 31753, 'offset_end': 31899, 'content': 'function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getUint256Slot', 'start_line': 884, 'end_line': 888, 'offset_start': 31905, 'offset_end': 32051, 'content': 'function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 889, 'end_line': 893, 'offset_start': 32057, 'offset_end': 32201, 'content': 'function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getStringSlot', 'start_line': 894, 'end_line': 898, 'offset_start': 32207, 'offset_end': 32365, 'content': 'function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 899, 'end_line': 903, 'offset_start': 32371, 'offset_end': 32513, 'content': 'function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'StorageSlot.getBytesSlot', 'start_line': 904, 'end_line': 908, 'offset_start': 32519, 'offset_end': 32674, 'content': 'function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }', 'contract_name': 'StorageSlot', 'contract_code': '{\n    struct AddressSlot {\n        address value;\n    }\n    struct BooleanSlot {\n        bool value;\n    }\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n    struct Uint256Slot {\n        uint256 value;\n    }\n    struct StringSlot {\n        string value;\n    }\n    struct BytesSlot {\n        bytes value;\n    }\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 921, 'end_line': 935, 'offset_start': 32989, 'offset_end': 33576, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 936, 'end_line': 940, 'offset_start': 33582, 'offset_end': 33836, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 941, 'end_line': 947, 'offset_start': 33842, 'offset_end': 34198, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 948, 'end_line': 952, 'offset_start': 34204, 'offset_end': 34453, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 953, 'end_line': 967, 'offset_start': 34459, 'offset_end': 35028, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 968, 'end_line': 972, 'offset_start': 35034, 'offset_end': 35293, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 973, 'end_line': 983, 'offset_start': 35299, 'offset_end': 35807, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC5267.eip712Domain', 'start_line': 988, 'end_line': 999, 'offset_start': 35894, 'offset_end': 36203, 'content': 'function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );', 'contract_name': 'IERC5267', 'contract_code': '{\n    event EIP712DomainChanged();\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.name', 'start_line': 1004, 'end_line': 1004, 'offset_start': 36315, 'offset_end': 36368, 'content': 'function name() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.symbol', 'start_line': 1005, 'end_line': 1005, 'offset_start': 36374, 'offset_end': 36429, 'content': 'function symbol() external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Metadata.tokenURI', 'start_line': 1006, 'end_line': 1006, 'offset_start': 36435, 'offset_end': 36507, 'content': 'function tokenURI(uint256 tokenId) external view returns (string memory);', 'contract_name': 'IERC721Metadata', 'contract_code': '{\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC165.supportsInterface', 'start_line': 1010, 'end_line': 1010, 'offset_start': 36560, 'offset_end': 36635, 'content': 'function supportsInterface(bytes4 interfaceId) external view returns (bool);', 'contract_name': 'IERC165', 'contract_code': '{\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init', 'start_line': 1016, 'end_line': 1017, 'offset_start': 36880, 'offset_end': 36937, 'content': 'function __ERC165_init() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.__ERC165_init_unchained', 'start_line': 1018, 'end_line': 1019, 'offset_start': 36943, 'offset_end': 37010, 'content': 'function __ERC165_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC165Upgradeable.supportsInterface', 'start_line': 1020, 'end_line': 1022, 'offset_start': 37016, 'offset_end': 37161, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }', 'contract_name': 'ERC165Upgradeable', 'contract_code': '{\n    function __ERC165_init() internal onlyInitializing {\n    }\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getERC721Storage', 'start_line': 1045, 'end_line': 1049, 'offset_start': 38534, 'offset_end': 38689, 'content': 'function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init', 'start_line': 1050, 'end_line': 1052, 'offset_start': 38695, 'offset_end': 38843, 'content': 'function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.__ERC721_init_unchained', 'start_line': 1053, 'end_line': 1057, 'offset_start': 38849, 'offset_end': 39067, 'content': 'function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.supportsInterface', 'start_line': 1058, 'end_line': 1063, 'offset_start': 39073, 'offset_end': 39383, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.balanceOf', 'start_line': 1064, 'end_line': 1070, 'offset_start': 39389, 'offset_end': 39653, 'content': 'function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.ownerOf', 'start_line': 1071, 'end_line': 1073, 'offset_start': 39659, 'offset_end': 39776, 'content': 'function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.name', 'start_line': 1074, 'end_line': 1077, 'offset_start': 39782, 'offset_end': 39927, 'content': 'function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.symbol', 'start_line': 1078, 'end_line': 1081, 'offset_start': 39933, 'offset_end': 40082, 'content': 'function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.tokenURI', 'start_line': 1082, 'end_line': 1086, 'offset_start': 40088, 'offset_end': 40341, 'content': 'function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._baseURI', 'start_line': 1087, 'end_line': 1089, 'offset_start': 40347, 'offset_end': 40438, 'content': 'function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.approve', 'start_line': 1090, 'end_line': 1092, 'offset_start': 40444, 'offset_end': 40556, 'content': 'function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.getApproved', 'start_line': 1093, 'end_line': 1096, 'offset_start': 40562, 'offset_end': 40714, 'content': 'function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.setApprovalForAll', 'start_line': 1097, 'end_line': 1099, 'offset_start': 40720, 'offset_end': 40863, 'content': 'function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.isApprovedForAll', 'start_line': 1100, 'end_line': 1103, 'offset_start': 40869, 'offset_end': 41078, 'content': 'function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.transferFrom', 'start_line': 1104, 'end_line': 1112, 'offset_start': 41084, 'offset_end': 41452, 'content': 'function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1113, 'end_line': 1115, 'offset_start': 41458, 'offset_end': 41589, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable.safeTransferFrom', 'start_line': 1116, 'end_line': 1119, 'offset_start': 41595, 'offset_end': 41802, 'content': 'function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._ownerOf', 'start_line': 1120, 'end_line': 1123, 'offset_start': 41808, 'offset_end': 41979, 'content': 'function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._getApproved', 'start_line': 1124, 'end_line': 1127, 'offset_start': 41985, 'offset_end': 42168, 'content': 'function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._isAuthorized', 'start_line': 1128, 'end_line': 1132, 'offset_start': 42174, 'offset_end': 42445, 'content': 'function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkAuthorized', 'start_line': 1133, 'end_line': 1141, 'offset_start': 42451, 'offset_end': 42818, 'content': 'function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._increaseBalance', 'start_line': 1142, 'end_line': 1147, 'offset_start': 42824, 'offset_end': 43033, 'content': 'function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._update', 'start_line': 1148, 'end_line': 1168, 'offset_start': 43039, 'offset_end': 43730, 'content': 'function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._mint', 'start_line': 1169, 'end_line': 1177, 'offset_start': 43736, 'offset_end': 44062, 'content': 'function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1178, 'end_line': 1180, 'offset_start': 44068, 'offset_end': 44167, 'content': 'function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeMint', 'start_line': 1181, 'end_line': 1184, 'offset_start': 44173, 'offset_end': 44354, 'content': 'function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._burn', 'start_line': 1185, 'end_line': 1190, 'offset_start': 44360, 'offset_end': 44586, 'content': 'function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._transfer', 'start_line': 1191, 'end_line': 1201, 'offset_start': 44592, 'offset_end': 45051, 'content': 'function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1202, 'end_line': 1204, 'offset_start': 45057, 'offset_end': 45184, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._safeTransfer', 'start_line': 1205, 'end_line': 1208, 'offset_start': 45190, 'offset_end': 45393, 'content': 'function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1209, 'end_line': 1211, 'offset_start': 45399, 'offset_end': 45518, 'content': 'function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._approve', 'start_line': 1212, 'end_line': 1224, 'offset_start': 45524, 'offset_end': 46078, 'content': 'function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._setApprovalForAll', 'start_line': 1225, 'end_line': 1232, 'offset_start': 46084, 'offset_end': 46452, 'content': 'function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._requireOwned', 'start_line': 1233, 'end_line': 1239, 'offset_start': 46458, 'offset_end': 46698, 'content': 'function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC721Upgradeable._checkOnERC721Received', 'start_line': 1240, 'end_line': 1256, 'offset_start': 46704, 'offset_end': 47430, 'content': 'function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }', 'contract_name': 'ERC721Upgradeable', 'contract_code': '{\n    using Strings for uint256;\n    struct ERC721Storage {\n        string _name;\n        string _symbol;\n        mapping(uint256 tokenId => address) _owners;\n        mapping(address owner => uint256) _balances;\n        mapping(uint256 tokenId => address) _tokenApprovals;\n        mapping(address owner => mapping(address operator => bool)) _operatorApprovals;\n    }\n    bytes32 private constant ERC721StorageLocation = 0x80bb2b638cc20bc4d0a60d66940f3ab4a00c1d7b313497ca82fb0b4ab0079300;\n    function _getERC721Storage() private pure returns (ERC721Storage storage $) {\n        assembly {\n            $.slot := ERC721StorageLocation\n        }\n    }\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC721Storage storage $ = _getERC721Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return $._balances[owner];\n    }\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n    function name() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._name;\n    }\n    function symbol() public view virtual returns (string memory) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._symbol;\n    }\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : "";\n    }\n    function _baseURI() internal view virtual returns (string memory) {\n        return "";\n    }\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n        return _getApproved(tokenId);\n    }\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._operatorApprovals[owner][operator];\n    }\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._owners[tokenId];\n    }\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        return $._tokenApprovals[tokenId];\n    }\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        unchecked {\n            $._balances[account] += value;\n        }\n    }\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        ERC721Storage storage $ = _getERC721Storage();\n        address from = _ownerOf(tokenId);\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n        if (from != address(0)) {\n            _approve(address(0), tokenId, address(0), false);\n            unchecked {\n                $._balances[from] -= 1;\n            }\n        }\n        if (to != address(0)) {\n            unchecked {\n                $._balances[to] += 1;\n            }\n        }\n        $._owners[tokenId] = to;\n        emit Transfer(from, to, tokenId);\n        return from;\n    }\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, "");\n    }\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, "");\n    }\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n        $._tokenApprovals[tokenId] = to;\n    }\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        ERC721Storage storage $ = _getERC721Storage();\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        $._operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 1261, 'end_line': 1267, 'offset_start': 47530, 'offset_end': 47803, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 1268, 'end_line': 1271, 'offset_start': 47809, 'offset_end': 48037, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 1272, 'end_line': 1274, 'offset_start': 48043, 'offset_end': 48233, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 1275, 'end_line': 1283, 'offset_start': 48239, 'offset_end': 48596, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IERC721Receiver.onERC721Received', 'start_line': 1287, 'end_line': 1292, 'offset_start': 48657, 'offset_end': 48816, 'content': 'function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);', 'contract_name': 'IERC721Receiver', 'contract_code': '{\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getImplementation', 'start_line': 1307, 'end_line': 1309, 'offset_start': 49501, 'offset_end': 49638, 'content': 'function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setImplementation', 'start_line': 1310, 'end_line': 1315, 'offset_start': 49644, 'offset_end': 49924, 'content': 'function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeToAndCall', 'start_line': 1316, 'end_line': 1324, 'offset_start': 49930, 'offset_end': 50263, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getAdmin', 'start_line': 1326, 'end_line': 1328, 'offset_start': 50380, 'offset_end': 50499, 'content': 'function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setAdmin', 'start_line': 1329, 'end_line': 1334, 'offset_start': 50505, 'offset_end': 50721, 'content': 'function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.changeAdmin', 'start_line': 1335, 'end_line': 1338, 'offset_start': 50727, 'offset_end': 50859, 'content': 'function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.getBeacon', 'start_line': 1340, 'end_line': 1342, 'offset_start': 50977, 'offset_end': 51098, 'content': 'function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._setBeacon', 'start_line': 1343, 'end_line': 1352, 'offset_start': 51104, 'offset_end': 51538, 'content': 'function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils.upgradeBeaconToAndCall', 'start_line': 1353, 'end_line': 1361, 'offset_start': 51544, 'offset_end': 51875, 'content': 'function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ERC1967Utils._checkNonPayable', 'start_line': 1362, 'end_line': 1366, 'offset_start': 51881, 'offset_end': 52002, 'content': 'function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }', 'contract_name': 'ERC1967Utils', 'contract_code': '{\n    event Upgraded(address indexed implementation);\n    event AdminChanged(address previousAdmin, address newAdmin);\n    event BeaconUpgraded(address indexed beacon);\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n    error ERC1967InvalidImplementation(address implementation);\n    error ERC1967InvalidAdmin(address admin);\n    error ERC1967InvalidBeacon(address beacon);\n    error ERC1967NonPayable();\n    function getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value;\n    }\n    function _setImplementation(address newImplementation) private {\n        if (newImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(newImplementation);\n        }\n        StorageSlot.getAddressSlot(IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n        if (data.length > 0) {\n            Address.functionDelegateCall(newImplementation, data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n    function getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(ADMIN_SLOT).value;\n    }\n    function _setAdmin(address newAdmin) private {\n        if (newAdmin == address(0)) {\n            revert ERC1967InvalidAdmin(address(0));\n        }\n        StorageSlot.getAddressSlot(ADMIN_SLOT).value = newAdmin;\n    }\n    function changeAdmin(address newAdmin) internal {\n        emit AdminChanged(getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n    bytes32 internal constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n    function getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(BEACON_SLOT).value;\n    }\n    function _setBeacon(address newBeacon) private {\n        if (newBeacon.code.length == 0) {\n            revert ERC1967InvalidBeacon(newBeacon);\n        }\n        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;\n        address beaconImplementation = IBeacon(newBeacon).implementation();\n        if (beaconImplementation.code.length == 0) {\n            revert ERC1967InvalidImplementation(beaconImplementation);\n        }\n    }\n    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        } else {\n            _checkNonPayable();\n        }\n    }\n    function _checkNonPayable() private {\n        if (msg.value > 0) {\n            revert ERC1967NonPayable();\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._getAccessControlStorage', 'start_line': 1383, 'end_line': 1387, 'offset_start': 52824, 'offset_end': 53000, 'content': 'function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init', 'start_line': 1392, 'end_line': 1393, 'offset_start': 53087, 'offset_end': 53151, 'content': 'function __AccessControl_init() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.__AccessControl_init_unchained', 'start_line': 1394, 'end_line': 1395, 'offset_start': 53157, 'offset_end': 53231, 'content': 'function __AccessControl_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.supportsInterface', 'start_line': 1396, 'end_line': 1398, 'offset_start': 53237, 'offset_end': 53438, 'content': 'function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.hasRole', 'start_line': 1399, 'end_line': 1402, 'offset_start': 53444, 'offset_end': 53650, 'content': 'function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1403, 'end_line': 1405, 'offset_start': 53656, 'offset_end': 53758, 'content': 'function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._checkRole', 'start_line': 1406, 'end_line': 1410, 'offset_start': 53764, 'offset_end': 53960, 'content': 'function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.getRoleAdmin', 'start_line': 1411, 'end_line': 1414, 'offset_start': 53966, 'offset_end': 54156, 'content': 'function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.grantRole', 'start_line': 1415, 'end_line': 1417, 'offset_start': 54162, 'offset_end': 54297, 'content': 'function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.revokeRole', 'start_line': 1418, 'end_line': 1420, 'offset_start': 54303, 'offset_end': 54440, 'content': 'function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable.renounceRole', 'start_line': 1421, 'end_line': 1426, 'offset_start': 54446, 'offset_end': 54689, 'content': 'function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._setRoleAdmin', 'start_line': 1427, 'end_line': 1432, 'offset_start': 54695, 'offset_end': 55012, 'content': 'function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._grantRole', 'start_line': 1433, 'end_line': 1442, 'offset_start': 55018, 'offset_end': 55404, 'content': 'function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'AccessControlUpgradeable._revokeRole', 'start_line': 1443, 'end_line': 1452, 'offset_start': 55410, 'offset_end': 55797, 'content': 'function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }', 'contract_name': 'AccessControlUpgradeable', 'contract_code': '{\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n    struct AccessControlStorage {\n        mapping(bytes32 role => RoleData) _roles;\n    }\n    bytes32 private constant AccessControlStorageLocation = 0x02dd7bc7dec4dceedda775e58dd541e08a116c6c53815c0bd028192f7b626800;\n    function _getAccessControlStorage() private pure returns (AccessControlStorage storage $) {\n        assembly {\n            $.slot := AccessControlStorageLocation\n        }\n    }\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n    function __AccessControl_init() internal onlyInitializing {\n    }\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].hasRole[account];\n    }\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        return $._roles[role].adminRole;\n    }\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n        _revokeRole(role, callerConfirmation);\n    }\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        $._roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (!hasRole(role, account)) {\n            $._roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        AccessControlStorage storage $ = _getAccessControlStorage();\n        if (hasRole(role, account)) {\n            $._roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._getReentrancyGuardStorage', 'start_line': 1463, 'end_line': 1467, 'offset_start': 56243, 'offset_end': 56425, 'content': 'function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init', 'start_line': 1469, 'end_line': 1471, 'offset_start': 56473, 'offset_end': 56583, 'content': 'function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable.__ReentrancyGuard_init_unchained', 'start_line': 1472, 'end_line': 1475, 'offset_start': 56589, 'offset_end': 56771, 'content': 'function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantBefore', 'start_line': 1481, 'end_line': 1487, 'offset_start': 56885, 'offset_end': 57129, 'content': 'function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._nonReentrantAfter', 'start_line': 1488, 'end_line': 1491, 'offset_start': 57135, 'offset_end': 57285, 'content': 'function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuardUpgradeable._reentrancyGuardEntered', 'start_line': 1492, 'end_line': 1495, 'offset_start': 57291, 'offset_end': 57471, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuardUpgradeable', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n    error ReentrancyGuardReentrantCall();\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        $._status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._getEIP712Storage', 'start_line': 1511, 'end_line': 1515, 'offset_start': 58216, 'offset_end': 58371, 'content': 'function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init', 'start_line': 1516, 'end_line': 1518, 'offset_start': 58377, 'offset_end': 58523, 'content': 'function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.__EIP712_init_unchained', 'start_line': 1519, 'end_line': 1525, 'offset_start': 58529, 'offset_end': 58803, 'content': 'function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._domainSeparatorV4', 'start_line': 1526, 'end_line': 1528, 'offset_start': 58809, 'offset_end': 58917, 'content': 'function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._buildDomainSeparator', 'start_line': 1529, 'end_line': 1531, 'offset_start': 58923, 'offset_end': 59113, 'content': 'function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._hashTypedDataV4', 'start_line': 1532, 'end_line': 1534, 'offset_start': 59119, 'offset_end': 59294, 'content': 'function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable.eip712Domain', 'start_line': 1535, 'end_line': 1560, 'offset_start': 59300, 'offset_end': 59990, 'content': 'function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Name', 'start_line': 1561, 'end_line': 1564, 'offset_start': 59996, 'offset_end': 60150, 'content': 'function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712Version', 'start_line': 1565, 'end_line': 1568, 'offset_start': 60156, 'offset_end': 60316, 'content': 'function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712NameHash', 'start_line': 1569, 'end_line': 1582, 'offset_start': 60322, 'offset_end': 60785, 'content': 'function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'EIP712Upgradeable._EIP712VersionHash', 'start_line': 1583, 'end_line': 1596, 'offset_start': 60791, 'offset_end': 61281, 'content': 'function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }', 'contract_name': 'EIP712Upgradeable', 'contract_code': '{\n    bytes32 private constant TYPE_HASH =\n        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");\n    struct EIP712Storage {\n        bytes32 _hashedName;\n        bytes32 _hashedVersion;\n        string _name;\n        string _version;\n    }\n    bytes32 private constant EIP712StorageLocation = 0xa16a46d94261c7517cc8ff89f61c0ce93598e3c849801011dee649a6a557d100;\n    function _getEIP712Storage() private pure returns (EIP712Storage storage $) {\n        assembly {\n            $.slot := EIP712StorageLocation\n        }\n    }\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        EIP712Storage storage $ = _getEIP712Storage();\n        $._name = name;\n        $._version = version;\n        $._hashedName = 0;\n        $._hashedVersion = 0;\n    }\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator();\n    }\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash(), block.chainid, address(this)));\n    }\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return MessageHashUtils.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n    function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        EIP712Storage storage $ = _getEIP712Storage();\n        require($._hashedName == 0 && $._hashedVersion == 0, "EIP712: Uninitialized");\n        return (\n            hex"0f", \n            _EIP712Name(),\n            _EIP712Version(),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n    function _EIP712Name() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._name;\n    }\n    function _EIP712Version() internal view virtual returns (string memory) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        return $._version;\n    }\n    function _EIP712NameHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory name = _EIP712Name();\n        if (bytes(name).length > 0) {\n            return keccak256(bytes(name));\n        } else {\n            bytes32 hashedName = $._hashedName;\n            if (hashedName != 0) {\n                return hashedName;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n    function _EIP712VersionHash() internal view returns (bytes32) {\n        EIP712Storage storage $ = _getEIP712Storage();\n        string memory version = _EIP712Version();\n        if (bytes(version).length > 0) {\n            return keccak256(bytes(version));\n        } else {\n            bytes32 hashedVersion = $._hashedVersion;\n            if (hashedVersion != 0) {\n                return hashedVersion;\n            } else {\n                return keccak256("");\n            }\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 1642, 'end_line': 1646, 'offset_start': 62795, 'offset_end': 62935, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1647, 'end_line': 1656, 'offset_start': 62941, 'offset_end': 63305, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1657, 'end_line': 1659, 'offset_start': 63311, 'offset_end': 63438, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1660, 'end_line': 1662, 'offset_start': 63444, 'offset_end': 63563, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 1663, 'end_line': 1667, 'offset_start': 63569, 'offset_end': 63738, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init', 'start_line': 1686, 'end_line': 1687, 'offset_start': 64425, 'offset_end': 64491, 'content': 'function __UUPSUpgradeable_init() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.__UUPSUpgradeable_init_unchained', 'start_line': 1688, 'end_line': 1689, 'offset_start': 64497, 'offset_end': 64573, 'content': 'function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.proxiableUUID', 'start_line': 1690, 'end_line': 1692, 'offset_start': 64579, 'offset_end': 64712, 'content': 'function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable.upgradeToAndCall', 'start_line': 1693, 'end_line': 1696, 'offset_start': 64718, 'offset_end': 64931, 'content': 'function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkProxy', 'start_line': 1697, 'end_line': 1704, 'offset_start': 64937, 'offset_end': 65169, 'content': 'function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._checkNotDelegated', 'start_line': 1705, 'end_line': 1709, 'offset_start': 65175, 'offset_end': 65332, 'content': 'function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._authorizeUpgrade', 'start_line': 1710, 'end_line': 1710, 'offset_start': 65338, 'offset_end': 65408, 'content': 'function _authorizeUpgrade(address newImplementation) internal virtual;', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'UUPSUpgradeable._upgradeToAndCallUUPS', 'start_line': 1711, 'end_line': 1720, 'offset_start': 65414, 'offset_end': 65905, 'content': 'function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }', 'contract_name': 'UUPSUpgradeable', 'contract_code': '{\n    address private immutable __self = address(this);\n    string public constant UPGRADE_INTERFACE_VERSION = "5.0.0";\n    error UUPSUnauthorizedCallContext();\n    error UUPSUnsupportedProxiableUUID(bytes32 slot);\n    modifier onlyProxy() {\n        _checkProxy();\n        _;\n    }\n    modifier notDelegated() {\n        _checkNotDelegated();\n        _;\n    }\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    function proxiableUUID() external view virtual notDelegated returns (bytes32) {\n        return ERC1967Utils.IMPLEMENTATION_SLOT;\n    }\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data);\n    }\n    function _checkProxy() internal view virtual {\n        if (\n            address(this) == __self || \n            ERC1967Utils.getImplementation() != __self \n        ) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _checkNotDelegated() internal view virtual {\n        if (address(this) != __self) {\n            revert UUPSUnauthorizedCallContext();\n        }\n    }\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {\n        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {\n                revert UUPSUnsupportedProxiableUUID(slot);\n            }\n            ERC1967Utils.upgradeToAndCall(newImplementation, data);\n        } catch {\n            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.distributeRewards', 'start_line': 1726, 'end_line': 1734, 'offset_start': 66054, 'offset_end': 66272, 'content': 'function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.withdrawFunds', 'start_line': 1735, 'end_line': 1741, 'offset_start': 66278, 'offset_end': 66437, 'content': 'function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.createEscrow', 'start_line': 1742, 'end_line': 1747, 'offset_start': 66443, 'offset_end': 66597, 'content': 'function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.updateEscrowAdmin', 'start_line': 1748, 'end_line': 1748, 'offset_start': 66603, 'offset_end': 66673, 'content': 'function updateEscrowAdmin(uint256 questId, address newAdmin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.addTokenToWhitelist', 'start_line': 1749, 'end_line': 1749, 'offset_start': 66679, 'offset_end': 66748, 'content': 'function addTokenToWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.removeTokenFromWhitelist', 'start_line': 1750, 'end_line': 1750, 'offset_start': 66754, 'offset_end': 66828, 'content': 'function removeTokenFromWhitelist(uint256 questId, address token) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'IFactory.initialize', 'start_line': 1751, 'end_line': 1751, 'offset_start': 66834, 'offset_end': 66877, 'content': 'function initialize(address admin) external;', 'contract_name': 'IFactory', 'contract_code': '{\n    function distributeRewards(\n        uint256 questId,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 rewardTokenId,\n        TokenType tokenType,\n        uint256 rakeBps\n    ) external;\n    function withdrawFunds(\n        uint256 questId,\n        address to,\n        address token,\n        uint256 tokenId,\n        TokenType tokenType\n    ) external;\n    function createEscrow(\n        uint256 questId,\n        address admin,\n        address[] memory whitelistedTokens,\n        address treasury\n    ) external;\n    function updateEscrowAdmin(uint256 questId, address newAdmin) external;\n    function addTokenToWhitelist(uint256 questId, address token) external;\n    function removeTokenFromWhitelist(uint256 questId, address token) external;\n    function initialize(address admin) external;\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 1756, 'end_line': 1757, 'offset_start': 67030, 'offset_end': 67088, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 1758, 'end_line': 1759, 'offset_start': 67094, 'offset_end': 67162, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 1760, 'end_line': 1762, 'offset_start': 67168, 'offset_end': 67263, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 1763, 'end_line': 1765, 'offset_start': 67269, 'offset_end': 67367, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7/0x1195cf65f83b3a5768f3c496d3a05ad6412c64b7.sol'}
