{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._getOwnableStorage', 'start_line': 10, 'end_line': 14, 'offset_start': 418, 'offset_end': 576, 'content': 'function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init', 'start_line': 18, 'end_line': 20, 'offset_start': 772, 'offset_end': 898, 'content': 'function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.__Ownable_init_unchained', 'start_line': 21, 'end_line': 26, 'offset_start': 904, 'offset_end': 1138, 'content': 'function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.owner', 'start_line': 31, 'end_line': 34, 'offset_start': 1211, 'offset_end': 1354, 'content': 'function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'public', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._checkOwner', 'start_line': 35, 'end_line': 39, 'offset_start': 1360, 'offset_end': 1521, 'content': 'function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.renounceOwnership', 'start_line': 40, 'end_line': 42, 'offset_start': 1527, 'offset_end': 1627, 'content': 'function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable.transferOwnership', 'start_line': 43, 'end_line': 48, 'offset_start': 1633, 'offset_end': 1847, 'content': 'function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'public', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'OwnableUpgradeable._transferOwnership', 'start_line': 49, 'end_line': 54, 'offset_start': 1853, 'offset_end': 2100, 'content': 'function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }', 'contract_name': 'OwnableUpgradeable', 'contract_code': '{\n    struct OwnableStorage {\n        address _owner;\n    }\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n    error OwnableUnauthorizedAccount(address account);\n    error OwnableInvalidOwner(address owner);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 59, 'end_line': 65, 'offset_start': 2200, 'offset_end': 2473, 'content': 'function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toEthSignedMessageHash', 'start_line': 66, 'end_line': 69, 'offset_start': 2479, 'offset_end': 2707, 'content': 'function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toDataWithIntendedValidatorHash', 'start_line': 70, 'end_line': 72, 'offset_start': 2713, 'offset_end': 2903, 'content': 'function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'MessageHashUtils.toTypedDataHash', 'start_line': 73, 'end_line': 81, 'offset_start': 2909, 'offset_end': 3266, 'content': 'function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }', 'contract_name': 'MessageHashUtils', 'contract_code': '{\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        assembly {\n            mstore(0x00, "\\x19Ethereum Signed Message:\\n32") \n            mstore(0x1c, messageHash) \n            digest := keccak256(0x00, 0x3c) \n        }\n    }\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat("\\x19Ethereum Signed Message:\\n", bytes(Strings.toString(message.length)), message));\n    }\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex"19_00", validator, data));\n    }\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex"19_01")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryAdd', 'start_line': 92, 'end_line': 98, 'offset_start': 3437, 'offset_end': 3652, 'content': 'function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.trySub', 'start_line': 99, 'end_line': 104, 'offset_start': 3658, 'offset_end': 3846, 'content': 'function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMul', 'start_line': 105, 'end_line': 112, 'offset_start': 3852, 'offset_end': 4114, 'content': 'function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryDiv', 'start_line': 113, 'end_line': 118, 'offset_start': 4120, 'offset_end': 4309, 'content': 'function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.tryMod', 'start_line': 119, 'end_line': 124, 'offset_start': 4315, 'offset_end': 4504, 'content': 'function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.max', 'start_line': 125, 'end_line': 127, 'offset_start': 4510, 'offset_end': 4613, 'content': 'function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.min', 'start_line': 128, 'end_line': 130, 'offset_start': 4619, 'offset_end': 4722, 'content': 'function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.average', 'start_line': 131, 'end_line': 133, 'offset_start': 4728, 'offset_end': 4843, 'content': 'function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.ceilDiv', 'start_line': 134, 'end_line': 139, 'offset_start': 4849, 'offset_end': 5029, 'content': 'function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 140, 'end_line': 177, 'offset_start': 5035, 'offset_end': 6502, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.mulDiv', 'start_line': 178, 'end_line': 184, 'offset_start': 6508, 'offset_end': 6809, 'content': 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 185, 'end_line': 200, 'offset_start': 6815, 'offset_end': 7395, 'content': 'function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.sqrt', 'start_line': 201, 'end_line': 206, 'offset_start': 7401, 'offset_end': 7640, 'content': 'function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 207, 'end_line': 243, 'offset_start': 7646, 'offset_end': 8628, 'content': 'function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log2', 'start_line': 244, 'end_line': 249, 'offset_start': 8634, 'offset_end': 8881, 'content': 'function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 250, 'end_line': 282, 'offset_start': 8887, 'offset_end': 9802, 'content': 'function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log10', 'start_line': 283, 'end_line': 288, 'offset_start': 9808, 'offset_end': 10058, 'content': 'function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 289, 'end_line': 313, 'offset_start': 10064, 'offset_end': 10726, 'content': 'function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.log256', 'start_line': 314, 'end_line': 319, 'offset_start': 10732, 'offset_end': 10990, 'content': 'function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Math.unsignedRoundsUp', 'start_line': 320, 'end_line': 322, 'offset_start': 10996, 'offset_end': 11117, 'content': 'function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }', 'contract_name': 'Math', 'contract_code': '{\n    error MathOverflowedMulDiv();\n    enum Rounding {\n        Floor, \n        Ceil, \n        Trunc, \n        Expand \n    }\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a & b) + (a ^ b) / 2;\n    }\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            return a / b;\n        }\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            uint256 prod0 = x * y; \n            uint256 prod1; \n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n            uint256 remainder;\n            assembly {\n                remainder := mulmod(x, y, denominator)\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                denominator := div(denominator, twos)\n                prod0 := div(prod0, twos)\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            inverse *= 2 - denominator * inverse; \n            result = prod0 * inverse;\n            return result;\n        }\n    }\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 result = 1 << (log2(a) >> 1);\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary._daysFromDate', 'start_line': 337, 'end_line': 349, 'offset_start': 11594, 'offset_end': 12092, 'content': 'function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary._daysToDate', 'start_line': 350, 'end_line': 365, 'offset_start': 12098, 'offset_end': 12700, 'content': 'function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.timestampFromDate', 'start_line': 366, 'end_line': 368, 'offset_start': 12706, 'offset_end': 12882, 'content': 'function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.timestampFromDateTime', 'start_line': 369, 'end_line': 371, 'offset_start': 12888, 'offset_end': 13170, 'content': 'function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.timestampToDate', 'start_line': 372, 'end_line': 374, 'offset_start': 13176, 'offset_end': 13350, 'content': 'function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.timestampToDateTime', 'start_line': 375, 'end_line': 382, 'offset_start': 13356, 'offset_end': 13788, 'content': 'function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.isValidDate', 'start_line': 383, 'end_line': 390, 'offset_start': 13794, 'offset_end': 14109, 'content': 'function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.isValidDateTime', 'start_line': 391, 'end_line': 397, 'offset_start': 14115, 'offset_end': 14409, 'content': 'function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.isLeapYear', 'start_line': 398, 'end_line': 401, 'offset_start': 14415, 'offset_end': 14599, 'content': 'function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary._isLeapYear', 'start_line': 402, 'end_line': 404, 'offset_start': 14605, 'offset_end': 14761, 'content': 'function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.isWeekDay', 'start_line': 405, 'end_line': 407, 'offset_start': 14767, 'offset_end': 14899, 'content': 'function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.isWeekEnd', 'start_line': 408, 'end_line': 410, 'offset_start': 14905, 'offset_end': 15037, 'content': 'function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getDaysInMonth', 'start_line': 411, 'end_line': 414, 'offset_start': 15043, 'offset_end': 15259, 'content': 'function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary._getDaysInMonth', 'start_line': 415, 'end_line': 423, 'offset_start': 15265, 'offset_end': 15647, 'content': 'function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getDayOfWeek', 'start_line': 424, 'end_line': 427, 'offset_start': 15653, 'offset_end': 15827, 'content': 'function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getYear', 'start_line': 428, 'end_line': 430, 'offset_start': 15833, 'offset_end': 15967, 'content': 'function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getMonth', 'start_line': 431, 'end_line': 433, 'offset_start': 15973, 'offset_end': 16110, 'content': 'function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getDay', 'start_line': 434, 'end_line': 436, 'offset_start': 16116, 'offset_end': 16247, 'content': 'function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getHour', 'start_line': 437, 'end_line': 440, 'offset_start': 16253, 'offset_end': 16415, 'content': 'function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getMinute', 'start_line': 441, 'end_line': 444, 'offset_start': 16421, 'offset_end': 16592, 'content': 'function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.getSecond', 'start_line': 445, 'end_line': 447, 'offset_start': 16598, 'offset_end': 16724, 'content': 'function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addYears', 'start_line': 448, 'end_line': 457, 'offset_start': 16730, 'offset_end': 17214, 'content': 'function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addMonths', 'start_line': 458, 'end_line': 469, 'offset_start': 17220, 'offset_end': 17780, 'content': 'function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addDays', 'start_line': 470, 'end_line': 473, 'offset_start': 17786, 'offset_end': 17983, 'content': 'function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addHours', 'start_line': 474, 'end_line': 477, 'offset_start': 17989, 'offset_end': 18190, 'content': 'function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addMinutes', 'start_line': 478, 'end_line': 481, 'offset_start': 18196, 'offset_end': 18405, 'content': 'function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.addSeconds', 'start_line': 482, 'end_line': 485, 'offset_start': 18411, 'offset_end': 18599, 'content': 'function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subYears', 'start_line': 486, 'end_line': 495, 'offset_start': 18605, 'offset_end': 19089, 'content': 'function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subMonths', 'start_line': 496, 'end_line': 507, 'offset_start': 19095, 'offset_end': 19684, 'content': 'function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subDays', 'start_line': 508, 'end_line': 511, 'offset_start': 19690, 'offset_end': 19887, 'content': 'function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subHours', 'start_line': 512, 'end_line': 515, 'offset_start': 19893, 'offset_end': 20094, 'content': 'function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subMinutes', 'start_line': 516, 'end_line': 519, 'offset_start': 20100, 'offset_end': 20309, 'content': 'function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.subSeconds', 'start_line': 520, 'end_line': 523, 'offset_start': 20315, 'offset_end': 20503, 'content': 'function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffYears', 'start_line': 524, 'end_line': 529, 'offset_start': 20509, 'offset_end': 20835, 'content': 'function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffMonths', 'start_line': 530, 'end_line': 535, 'offset_start': 20841, 'offset_end': 21230, 'content': 'function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffDays', 'start_line': 536, 'end_line': 539, 'offset_start': 21236, 'offset_end': 21445, 'content': 'function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffHours', 'start_line': 540, 'end_line': 543, 'offset_start': 21451, 'offset_end': 21664, 'content': 'function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffMinutes', 'start_line': 544, 'end_line': 547, 'offset_start': 21670, 'offset_end': 21891, 'content': 'function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'BokkyPooBahsDateTimeLibrary.diffSeconds', 'start_line': 548, 'end_line': 551, 'offset_start': 21897, 'offset_end': 22095, 'content': 'function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }', 'contract_name': 'BokkyPooBahsDateTimeLibrary', 'contract_code': '{\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint constant SECONDS_PER_HOUR = 60 * 60;\n    uint constant SECONDS_PER_MINUTE = 60;\n    int constant OFFSET19700101 = 2440588;\n    uint constant DOW_MON = 1;\n    uint constant DOW_TUE = 2;\n    uint constant DOW_WED = 3;\n    uint constant DOW_THU = 4;\n    uint constant DOW_FRI = 5;\n    uint constant DOW_SAT = 6;\n    uint constant DOW_SUN = 7;\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\n        require(year >= 1970);\n        int _year = int(year);\n        int _month = int(month);\n        int _day = int(day);\n        int __days = _day\n        - 32075\n        + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\n        + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\n        - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\n        - OFFSET19700101;\n        _days = uint(__days);\n    }\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\n        int __days = int(_days);\n        int L = __days + 68569 + OFFSET19700101;\n        int N = 4 * L / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int _year = 4000 * (L + 1) / 1461001;\n        L = L - 1461 * _year / 4 + 31;\n        int _month = 80 * L / 2447;\n        int _day = L - 2447 * _month / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n        year = uint(_year);\n        month = uint(_month);\n        day = uint(_day);\n    }\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\n    }\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n        secs = secs % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n        second = secs % SECONDS_PER_MINUTE;\n    }\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\n        if (year >= 1970 && month > 0 && month <= 12) {\n            uint daysInMonth = _getDaysInMonth(year, month);\n            if (day > 0 && day <= daysInMonth) {\n                valid = true;\n            }\n        }\n    }\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\n        if (isValidDate(year, month, day)) {\n            if (hour < 24 && minute < 60 && second < 60) {\n                valid = true;\n            }\n        }\n    }\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\n    }\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\n    }\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\n        uint _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = (_days + 3) % 7 + 1;\n    }\n    function getYear(uint timestamp) internal pure returns (uint year) {\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getMonth(uint timestamp) internal pure returns (uint month) {\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getDay(uint timestamp) internal pure returns (uint day) {\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n    function getHour(uint timestamp) internal pure returns (uint hour) {\n        uint secs = timestamp % SECONDS_PER_DAY;\n        hour = secs / SECONDS_PER_HOUR;\n    }\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\n        uint secs = timestamp % SECONDS_PER_HOUR;\n        minute = secs / SECONDS_PER_MINUTE;\n    }\n    function getSecond(uint timestamp) internal pure returns (uint second) {\n        second = timestamp % SECONDS_PER_MINUTE;\n    }\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year += _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        month += _months;\n        year += (month - 1) / 12;\n        month = (month - 1) % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\n        require(newTimestamp >= timestamp);\n    }\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\n        require(newTimestamp >= timestamp);\n    }\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp >= timestamp);\n    }\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp + _seconds;\n        require(newTimestamp >= timestamp);\n    }\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        year -= _years;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        uint yearMonth = year * 12 + (month - 1) - _months;\n        year = yearMonth / 12;\n        month = yearMonth % 12 + 1;\n        uint daysInMonth = _getDaysInMonth(year, month);\n        if (day > daysInMonth) {\n            day = daysInMonth;\n        }\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\n        require(newTimestamp <= timestamp);\n    }\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\n        require(newTimestamp <= timestamp);\n    }\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\n        require(newTimestamp <= timestamp);\n    }\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\n        newTimestamp = timestamp - _seconds;\n        require(newTimestamp <= timestamp);\n    }\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _years = toYear - fromYear;\n    }\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\n        require(fromTimestamp <= toTimestamp);\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\n    }\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\n        require(fromTimestamp <= toTimestamp);\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\n    }\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\n        require(fromTimestamp <= toTimestamp);\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\n    }\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\n        require(fromTimestamp <= toTimestamp);\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\n    }\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\n        require(fromTimestamp <= toTimestamp);\n        _seconds = toTimestamp - fromTimestamp;\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.max', 'start_line': 555, 'end_line': 557, 'offset_start': 22149, 'offset_end': 22249, 'content': 'function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.min', 'start_line': 558, 'end_line': 560, 'offset_start': 22255, 'offset_end': 22355, 'content': 'function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.average', 'start_line': 561, 'end_line': 564, 'offset_start': 22361, 'offset_end': 22538, 'content': 'function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'SignedMath.abs', 'start_line': 565, 'end_line': 569, 'offset_start': 22544, 'offset_end': 22680, 'content': 'function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }', 'contract_name': 'SignedMath', 'contract_code': '{\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.initialize', 'start_line': 613, 'end_line': 619, 'offset_start': 24733, 'offset_end': 24905, 'content': 'function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.initializeV2', 'start_line': 620, 'end_line': 627, 'offset_start': 24911, 'offset_end': 25247, 'content': 'function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.openSpot', 'start_line': 628, 'end_line': 639, 'offset_start': 25253, 'offset_end': 25687, 'content': "function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], 'Already Used Nonce');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.claimTreasure', 'start_line': 640, 'end_line': 651, 'offset_start': 25693, 'offset_end': 26189, 'content': "function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], 'Already Used Nonce');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.claimCashback', 'start_line': 652, 'end_line': 663, 'offset_start': 26195, 'offset_end': 26691, 'content': "function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], 'Already Used Nonce');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.pay', 'start_line': 664, 'end_line': 682, 'offset_start': 26697, 'offset_end': 27429, 'content': "function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, 'Item Not Registered');\n        require(msg.value >= item.price, 'Insufficient Value');\n        address user = msg.sender;\n        require(!_isContract(user), 'ONLY EOA');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}('');\n        if (refund > 0) {\n            user.call{value: refund}('');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': 'payable', 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.getCumulativeGoldAmount', 'start_line': 683, 'end_line': 685, 'offset_start': 27435, 'offset_end': 27583, 'content': 'function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'external', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.transferSigner', 'start_line': 686, 'end_line': 690, 'offset_start': 27589, 'offset_end': 27772, 'content': 'function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.addItem', 'start_line': 691, 'end_line': 693, 'offset_start': 27778, 'offset_end': 28005, 'content': 'function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.addItems', 'start_line': 694, 'end_line': 700, 'offset_start': 28011, 'offset_end': 28603, 'content': "function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, 'Invalid Item');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._addItem', 'start_line': 701, 'end_line': 706, 'offset_start': 28609, 'offset_end': 29072, 'content': "function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, 'Item Already Registered');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, 'Invalid Limit');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.updateItem', 'start_line': 707, 'end_line': 709, 'offset_start': 29078, 'offset_end': 29311, 'content': 'function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt.updateItems', 'start_line': 710, 'end_line': 716, 'offset_start': 29317, 'offset_end': 29915, 'content': "function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, 'Invalid Item');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'external', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._updateItem', 'start_line': 717, 'end_line': 726, 'offset_start': 29921, 'offset_end': 30514, 'content': "function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, 'Item Not Registered');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, 'Invalid Limit');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._checkDailyPayLimit', 'start_line': 727, 'end_line': 739, 'offset_start': 30520, 'offset_end': 31263, 'content': "function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, 'Daily Limit is 0');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, 'Exceed Daily Pay Limit');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._verifyOpenSpotSignature', 'start_line': 740, 'end_line': 754, 'offset_start': 31269, 'offset_end': 31665, 'content': 'function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._verifyClaimTreasureSignature', 'start_line': 755, 'end_line': 767, 'offset_start': 31671, 'offset_end': 32026, 'content': 'function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._verifyClaimCashbackSignature', 'start_line': 768, 'end_line': 780, 'offset_start': 32032, 'offset_end': 32387, 'content': 'function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._verifySignature', 'start_line': 781, 'end_line': 787, 'offset_start': 32393, 'offset_end': 32657, 'content': "function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, 'Invalid Signature');\n    }", 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'TreasureHunt._isContract', 'start_line': 788, 'end_line': 794, 'offset_start': 32663, 'offset_end': 32846, 'content': 'function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }', 'contract_name': 'TreasureHunt', 'contract_code': '{\n    using ECDSA for bytes32;\n    event OpenSpot(address user, uint256 gameId, uint256 tileCount, uint256 nonce, bytes signature);\n    event ClaimTreasure(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event ClaimCashback(address user, uint256 goldAmount, uint256 nonce, bytes signature);\n    event TransferSigner(address oldSigner, address newSigner);\n    event Pay(address user, uint256 itemId, uint256 price, uint256 refund, string itemType, uint256 amount);\n    event AddItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    event UpdateItem(uint256 itemId, uint256 price, bool isUnlimited, string itemType, uint256 amount, uint256 dailyLimit);\n    enum TileType {\n        NONE,\n        GOLD,\n        TICKET,\n        TREASURE\n    }\n    struct CumulativeGoldAmount {\n        uint256 claimTreasureGoldAmount;\n        uint256 claimCashbackGoldAmount;\n    }\n    address public signer;\n    mapping(address => mapping(uint256 => bool)) openSpotNonce;\n    mapping(address => mapping(uint256 => bool)) claimTreasureNonce;\n    mapping(address => mapping(uint256 => bool)) claimCashbackNonce;\n    mapping(address => CumulativeGoldAmount) cumulativeGoldAmount;\n    struct Item {\n        uint256 price;\n        bool isRegistered;\n        bool isUnlimited;\n        string itemType;\n        uint256 amount;\n        uint256 dailyLimit;\n    }\n    mapping(address => mapping(uint256 => uint256)) public userPayTime; \n    mapping(address => mapping(uint256 => uint256)) public userDailyPayCount; \n    mapping(uint256 => Item) public items; \n    address public treasury;\n    function initialize(\n        address initialOwner,\n        address _signer\n    ) external initializer {\n        __Ownable_init(initialOwner);\n        signer = _signer;\n    }\n    function initializeV2(\n        address _treasury\n    ) external reinitializer(2) {\n        treasury = _treasury;\n        items[0] = Item(300000000000000, true, false, "gold", 1000, 1); \n        items[1] = Item(450000000000000, true, false, "gold", 1500, 1); \n        items[2] = Item(750000000000000, true, false, "gold", 2500, 1); \n    }\n    function openSpot(\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!openSpotNonce[user][nonce], \'Already Used Nonce\');\n        _verifyOpenSpotSignature(user, gameId, tileCount, nonce, signature);\n        openSpotNonce[user][nonce] = true;\n        emit OpenSpot(user, gameId, tileCount, nonce, signature);\n    }\n    function claimTreasure(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimTreasureNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimTreasureSignature(user, goldAmount, nonce, signature);\n        claimTreasureNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimTreasureGoldAmount += goldAmount;\n        emit ClaimTreasure(user, goldAmount, nonce, signature);\n    }\n    function claimCashback(\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) external {\n        address user = msg.sender;\n        require(!claimCashbackNonce[user][nonce], \'Already Used Nonce\');\n        _verifyClaimCashbackSignature(user, goldAmount, nonce, signature);\n        claimCashbackNonce[user][nonce] = true;\n        cumulativeGoldAmount[user].claimCashbackGoldAmount += goldAmount;\n        emit ClaimCashback(user, goldAmount, nonce, signature);\n    }\n    function pay(uint256 itemId) external payable nonReentrant {\n        Item memory item = items[itemId];\n        require(item.isRegistered, \'Item Not Registered\');\n        require(msg.value >= item.price, \'Insufficient Value\');\n        address user = msg.sender;\n        require(!_isContract(user), \'ONLY EOA\');\n        if(!item.isUnlimited) {\n            _checkDailyPayLimit(itemId, user);\n        }\n        uint256 refund = 0;\n        if (msg.value - item.price > 0) {\n            refund = msg.value - item.price;\n        }\n        treasury.call{value: item.price}(\'\');\n        if (refund > 0) {\n            user.call{value: refund}(\'\');\n        }\n        emit Pay(user, itemId, item.price, refund, item.itemType, item.amount);\n    }\n    function getCumulativeGoldAmount(address user) external view returns (CumulativeGoldAmount memory) {\n        return cumulativeGoldAmount[user];\n    }\n    function transferSigner(address newSigner) external onlyOwner {\n        address oldSigner = signer;\n        signer = newSigner;\n        emit TransferSigner(oldSigner, newSigner);\n    }\n    function addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _addItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function addItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _addItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _addItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(!items[itemId].isRegistered, \'Item Already Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId] = Item(price, true, isUnlimited, itemType, amount, dailyLimit);\n        emit AddItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) external onlyOwner {\n        _updateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function updateItems(uint256[] memory itemIds, uint256[] memory prices, bool[] memory isUnlimited, string[] memory itemTypes, uint256[] memory amounts, uint256[] memory dailyLimits) external onlyOwner {\n        uint256 length = itemIds.length;\n        require(prices.length == length && isUnlimited.length == length && itemTypes.length == length && amounts.length == length && dailyLimits.length == length, \'Invalid Item\');\n        for(uint256 i = 0; i < itemIds.length; i++) {\n            _updateItem(itemIds[i], prices[i], isUnlimited[i], itemTypes[i], amounts[i], dailyLimits[i]);\n        }\n    }\n    function _updateItem(uint256 itemId, uint256 price, bool isUnlimited, string memory itemType, uint256 amount, uint256 dailyLimit) internal {\n        require(items[itemId].isRegistered, \'Item Not Registered\');\n        require(isUnlimited ? dailyLimit == 0 : dailyLimit > 0, \'Invalid Limit\');\n        items[itemId].price = price;\n        items[itemId].isUnlimited = isUnlimited;\n        items[itemId].itemType = itemType;\n        items[itemId].amount = amount;\n        items[itemId].dailyLimit = dailyLimit;\n        emit UpdateItem(itemId, price, isUnlimited, itemType, amount, dailyLimit);\n    }\n    function _checkDailyPayLimit(uint256 itemId, address user) internal {\n        require(items[itemId].dailyLimit > 0, \'Daily Limit is 0\');\n        uint256 lastTime = userPayTime[user][itemId];\n        uint256 currentTime = block.timestamp;\n        uint256 remainOneDayInSecond = BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY - (lastTime % BokkyPooBahsDateTimeLibrary.SECONDS_PER_DAY);\n        if (lastTime == 0 || lastTime + remainOneDayInSecond >= currentTime) {\n            require(userDailyPayCount[user][itemId] < items[itemId].dailyLimit, \'Exceed Daily Pay Limit\');\n            userDailyPayCount[user][itemId]++;\n        } else {\n            userDailyPayCount[user][itemId] = 1;\n        }\n        userPayTime[user][itemId] = currentTime;\n    }\n    function _verifyOpenSpotSignature(\n        address user,\n        uint256 gameId,\n        uint256 tileCount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                gameId,\n                tileCount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimTreasureSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifyClaimCashbackSignature(\n        address user,\n        uint256 goldAmount,\n        uint256 nonce,\n        bytes memory signature\n    ) internal {\n        bytes32 messageHash = keccak256(abi.encode(\n                user,\n                goldAmount,\n                nonce\n            ));\n        _verifySignature(messageHash, signature);\n    }\n    function _verifySignature(\n        bytes32 messageHash,\n        bytes memory signature\n    ) internal {\n        address _signer = MessageHashUtils.toEthSignedMessageHash(messageHash).recover(signature);\n        require(signer == _signer, \'Invalid Signature\');\n    }\n    function _isContract(address addr) internal view returns (bool) {\n        uint32 size;\n        assembly {\n            size := extcodesize(addr)\n        }\n        return size > 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 807, 'end_line': 821, 'offset_start': 33161, 'offset_end': 33748, 'content': 'function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 822, 'end_line': 826, 'offset_start': 33754, 'offset_end': 34008, 'content': 'function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 827, 'end_line': 833, 'offset_start': 34014, 'offset_end': 34370, 'content': 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 834, 'end_line': 838, 'offset_start': 34376, 'offset_end': 34625, 'content': 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.tryRecover', 'start_line': 839, 'end_line': 853, 'offset_start': 34631, 'offset_end': 35200, 'content': 'function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA.recover', 'start_line': 854, 'end_line': 858, 'offset_start': 35206, 'offset_end': 35465, 'content': 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ECDSA._throwError', 'start_line': 859, 'end_line': 869, 'offset_start': 35471, 'offset_end': 35979, 'content': 'function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }', 'contract_name': 'ECDSA', 'contract_code': '{\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n    error ECDSAInvalidSignature();\n    error ECDSAInvalidSignatureLength(uint256 length);\n    error ECDSAInvalidSignatureS(bytes32 s);\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; \n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard.tor', 'start_line': 877, 'end_line': 879, 'offset_start': 36207, 'offset_end': 36258, 'content': 'constructor() {\n        _status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    uint256 private _status;\n    error ReentrancyGuardReentrantCall();\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        _status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'default', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantBefore', 'start_line': 885, 'end_line': 890, 'offset_start': 36372, 'offset_end': 36539, 'content': 'function _nonReentrantBefore() private {\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        _status = ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    uint256 private _status;\n    error ReentrancyGuardReentrantCall();\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        _status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._nonReentrantAfter', 'start_line': 891, 'end_line': 893, 'offset_start': 36545, 'offset_end': 36620, 'content': 'function _nonReentrantAfter() private {\n        _status = NOT_ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    uint256 private _status;\n    error ReentrancyGuardReentrantCall();\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        _status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'private', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ReentrancyGuard._reentrancyGuardEntered', 'start_line': 894, 'end_line': 896, 'offset_start': 36626, 'offset_end': 36731, 'content': 'function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }', 'contract_name': 'ReentrancyGuard', 'contract_code': '{\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n    uint256 private _status;\n    error ReentrancyGuardReentrantCall();\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n    function _nonReentrantBefore() private {\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n        _status = ENTERED;\n    }\n    function _nonReentrantAfter() private {\n        _status = NOT_ENTERED;\n    }\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toString', 'start_line': 905, 'end_line': 923, 'offset_start': 37051, 'offset_end': 37650, 'content': 'function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toStringSigned', 'start_line': 924, 'end_line': 926, 'offset_start': 37656, 'offset_end': 37823, 'content': 'function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 927, 'end_line': 931, 'offset_start': 37829, 'offset_end': 38002, 'content': 'function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 932, 'end_line': 945, 'offset_start': 38008, 'offset_end': 38532, 'content': 'function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.toHexString', 'start_line': 946, 'end_line': 948, 'offset_start': 38538, 'offset_end': 38685, 'content': 'function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Strings.equal', 'start_line': 949, 'end_line': 951, 'offset_start': 38691, 'offset_end': 38872, 'content': 'function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }', 'contract_name': 'Strings', 'contract_code': '{\n    bytes16 private constant HEX_DIGITS = "0123456789abcdef";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));\n    }\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = "0";\n        buffer[1] = "x";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init', 'start_line': 956, 'end_line': 957, 'offset_start': 39025, 'offset_end': 39083, 'content': 'function __Context_init() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable.__Context_init_unchained', 'start_line': 958, 'end_line': 959, 'offset_start': 39089, 'offset_end': 39157, 'content': 'function __Context_init_unchained() internal onlyInitializing {\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [None], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgSender', 'start_line': 960, 'end_line': 962, 'offset_start': 39163, 'offset_end': 39258, 'content': 'function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._msgData', 'start_line': 963, 'end_line': 965, 'offset_start': 39264, 'offset_end': 39362, 'content': 'function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'ContextUpgradeable._contextSuffixLength', 'start_line': 966, 'end_line': 968, 'offset_start': 39368, 'offset_end': 39464, 'content': 'function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }', 'contract_name': 'ContextUpgradeable', 'contract_code': '{\n    function __Context_init() internal onlyInitializing {\n    }\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._checkInitializing', 'start_line': 1014, 'end_line': 1018, 'offset_start': 40978, 'offset_end': 41118, 'content': 'function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._disableInitializers', 'start_line': 1019, 'end_line': 1028, 'offset_start': 41124, 'offset_end': 41488, 'content': 'function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': None, 'returnParameters': [], 'visibility': 'internal', 'node_count': 4, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializedVersion', 'start_line': 1029, 'end_line': 1031, 'offset_start': 41494, 'offset_end': 41621, 'content': 'function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._isInitializing', 'start_line': 1032, 'end_line': 1034, 'offset_start': 41627, 'offset_end': 41746, 'content': 'function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'view', 'returnParameters': None, 'visibility': 'internal', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
{'type': 'FunctionDefinition', 'name': 'Initializable._getInitializableStorage', 'start_line': 1035, 'end_line': 1039, 'offset_start': 41752, 'offset_end': 41921, 'content': 'function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }', 'contract_name': 'Initializable', 'contract_code': '{\n    struct InitializableStorage {\n        uint64 _initialized;\n        bool _initializing;\n    }\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n    error InvalidInitialization();\n    error NotInitializing();\n    event Initialized(uint64 version);\n    modifier initializer() {\n        InitializableStorage storage $ = _getInitializableStorage();\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n    modifier reinitializer(uint64 version) {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n    function _disableInitializers() internal virtual {\n        InitializableStorage storage $ = _getInitializableStorage();\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}', 'modifiers': [], 'stateMutability': 'pure', 'returnParameters': None, 'visibility': 'private', 'node_count': 5, 'relative_file_path': './testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol', 'absolute_file_path': '/Users/oker/okx/Token-Check/testDownload/42161/0x6e098fbe183e0f5c50662a361690a1b215e2a68e/0x6e098fbe183e0f5c50662a361690a1b215e2a68e.sol'}
